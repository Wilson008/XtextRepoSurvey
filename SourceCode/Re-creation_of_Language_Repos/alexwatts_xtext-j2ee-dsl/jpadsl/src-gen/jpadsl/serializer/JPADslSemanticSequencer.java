/*
 * generated by Xtext 2.35.0
 */
package jpadsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import jpadsl.jPADsl.Cacheable;
import jpadsl.jPADsl.DataType;
import jpadsl.jPADsl.DatabaseMode;
import jpadsl.jPADsl.EmbeddedUniqueIdentifer;
import jpadsl.jPADsl.Entity;
import jpadsl.jPADsl.IdAttribute;
import jpadsl.jPADsl.Import;
import jpadsl.jPADsl.JPADslPackage;
import jpadsl.jPADsl.ManyToManyMappedByRelationshipAttribute;
import jpadsl.jPADsl.ManyToManyRelationshipAttribute;
import jpadsl.jPADsl.ManyToOneJoinColumnRelationShipAttribute;
import jpadsl.jPADsl.ManyToOneJoinTableRelationShipAttribute;
import jpadsl.jPADsl.ManyToOneMappedByRelationShipAttribute;
import jpadsl.jPADsl.Model;
import jpadsl.jPADsl.OneToManyJoinColumnRelationshipAttribute;
import jpadsl.jPADsl.OneToManyJoinTableRelationshipAttribute;
import jpadsl.jPADsl.OneToManyMappedByRelationshipAttribute;
import jpadsl.jPADsl.OneToOneMappedByRelationshipAttribute;
import jpadsl.jPADsl.OneToOneRelationshipAttribute;
import jpadsl.jPADsl.Operation;
import jpadsl.jPADsl.PackageDeclaration;
import jpadsl.jPADsl.ReadOnly;
import jpadsl.jPADsl.ReadOnlyInternalAttribute;
import jpadsl.jPADsl.Reference;
import jpadsl.jPADsl.StaticAttribute;
import jpadsl.jPADsl.TransientAttribute;
import jpadsl.jPADsl.TypeRef;
import jpadsl.jPADsl.UniqueIdentiferColumn;
import jpadsl.jPADsl.UpdatableInternalAttribute;
import jpadsl.services.JPADslGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class JPADslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private JPADslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == JPADslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case JPADslPackage.CACHEABLE:
				sequence_Cacheable(context, (Cacheable) semanticObject); 
				return; 
			case JPADslPackage.DATA_TYPE:
				sequence_DataType(context, (DataType) semanticObject); 
				return; 
			case JPADslPackage.DATABASE_MODE:
				sequence_DatabaseMode(context, (DatabaseMode) semanticObject); 
				return; 
			case JPADslPackage.EMBEDDED_UNIQUE_IDENTIFER:
				sequence_EmbeddedUniqueIdentifer(context, (EmbeddedUniqueIdentifer) semanticObject); 
				return; 
			case JPADslPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case JPADslPackage.ID_ATTRIBUTE:
				sequence_IdAttribute(context, (IdAttribute) semanticObject); 
				return; 
			case JPADslPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case JPADslPackage.MANY_TO_MANY_MAPPED_BY_RELATIONSHIP_ATTRIBUTE:
				sequence_ManyToManyMappedByRelationshipAttribute(context, (ManyToManyMappedByRelationshipAttribute) semanticObject); 
				return; 
			case JPADslPackage.MANY_TO_MANY_RELATIONSHIP_ATTRIBUTE:
				sequence_ManyToManyRelationshipAttribute(context, (ManyToManyRelationshipAttribute) semanticObject); 
				return; 
			case JPADslPackage.MANY_TO_ONE_JOIN_COLUMN_RELATION_SHIP_ATTRIBUTE:
				sequence_ManyToOneJoinColumnRelationShipAttribute(context, (ManyToOneJoinColumnRelationShipAttribute) semanticObject); 
				return; 
			case JPADslPackage.MANY_TO_ONE_JOIN_TABLE_RELATION_SHIP_ATTRIBUTE:
				sequence_ManyToOneJoinTableRelationShipAttribute(context, (ManyToOneJoinTableRelationShipAttribute) semanticObject); 
				return; 
			case JPADslPackage.MANY_TO_ONE_MAPPED_BY_RELATION_SHIP_ATTRIBUTE:
				sequence_ManyToOneMappedByRelationShipAttribute(context, (ManyToOneMappedByRelationShipAttribute) semanticObject); 
				return; 
			case JPADslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case JPADslPackage.ONE_TO_MANY_JOIN_COLUMN_RELATIONSHIP_ATTRIBUTE:
				sequence_OneToManyJoinColumnRelationshipAttribute(context, (OneToManyJoinColumnRelationshipAttribute) semanticObject); 
				return; 
			case JPADslPackage.ONE_TO_MANY_JOIN_TABLE_RELATIONSHIP_ATTRIBUTE:
				sequence_OneToManyJoinTableRelationshipAttribute(context, (OneToManyJoinTableRelationshipAttribute) semanticObject); 
				return; 
			case JPADslPackage.ONE_TO_MANY_MAPPED_BY_RELATIONSHIP_ATTRIBUTE:
				sequence_OneToManyMappedByRelationshipAttribute(context, (OneToManyMappedByRelationshipAttribute) semanticObject); 
				return; 
			case JPADslPackage.ONE_TO_ONE_MAPPED_BY_RELATIONSHIP_ATTRIBUTE:
				sequence_OneToOneMappedByRelationshipAttribute(context, (OneToOneMappedByRelationshipAttribute) semanticObject); 
				return; 
			case JPADslPackage.ONE_TO_ONE_RELATIONSHIP_ATTRIBUTE:
				sequence_OneToOneRelationshipAttribute(context, (OneToOneRelationshipAttribute) semanticObject); 
				return; 
			case JPADslPackage.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case JPADslPackage.PACKAGE_DECLARATION:
				sequence_PackageDeclaration(context, (PackageDeclaration) semanticObject); 
				return; 
			case JPADslPackage.PARAMETER:
				sequence_Parameter(context, (jpadsl.jPADsl.Parameter) semanticObject); 
				return; 
			case JPADslPackage.READ_ONLY:
				sequence_ReadOnly(context, (ReadOnly) semanticObject); 
				return; 
			case JPADslPackage.READ_ONLY_INTERNAL_ATTRIBUTE:
				sequence_ReadOnlyInternalAttribute(context, (ReadOnlyInternalAttribute) semanticObject); 
				return; 
			case JPADslPackage.REFERENCE:
				sequence_Reference(context, (Reference) semanticObject); 
				return; 
			case JPADslPackage.STATIC_ATTRIBUTE:
				sequence_StaticAttribute(context, (StaticAttribute) semanticObject); 
				return; 
			case JPADslPackage.TRANSIENT_ATTRIBUTE:
				sequence_TransientAttribute(context, (TransientAttribute) semanticObject); 
				return; 
			case JPADslPackage.TYPE_REF:
				sequence_TypeRef(context, (TypeRef) semanticObject); 
				return; 
			case JPADslPackage.UNIQUE_IDENTIFER_COLUMN:
				sequence_UniqueIdentiferColumn(context, (UniqueIdentiferColumn) semanticObject); 
				return; 
			case JPADslPackage.UPDATABLE_INTERNAL_ATTRIBUTE:
				sequence_UpdatableInternalAttribute(context, (UpdatableInternalAttribute) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Cacheable returns Cacheable
	 *
	 * Constraint:
	 *     {Cacheable}
	 * </pre>
	 */
	protected void sequence_Cacheable(ISerializationContext context, Cacheable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractElement returns DataType
	 *     Type returns DataType
	 *     DataType returns DataType
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_DataType(ISerializationContext context, DataType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDataTypeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DatabaseMode returns DatabaseMode
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_DatabaseMode(ISerializationContext context, DatabaseMode semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.DATABASE_MODE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.DATABASE_MODE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDatabaseModeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Identifier returns EmbeddedUniqueIdentifer
	 *     EmbeddedUniqueIdentifer returns EmbeddedUniqueIdentifer
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_EmbeddedUniqueIdentifer(ISerializationContext context, EmbeddedUniqueIdentifer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.IDENTIFIER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.IDENTIFIER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEmbeddedUniqueIdentiferAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractElement returns Entity
	 *     Type returns Entity
	 *     Entity returns Entity
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         databaseVendor=[DatabaseMode|ID]? 
	 *         superType=[Entity|ID]? 
	 *         readOnly=ReadOnly? 
	 *         cacheable=Cacheable? 
	 *         identifier=Identifier 
	 *         imports+=Import* 
	 *         features+=Feature*
	 *     )
	 * </pre>
	 */
	protected void sequence_Entity(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Feature returns IdAttribute
	 *     StructuralFeature returns IdAttribute
	 *     Attribute returns IdAttribute
	 *     InternalAttribute returns IdAttribute
	 *     IdAttribute returns IdAttribute
	 *     TypedElement returns IdAttribute
	 *
	 * Constraint:
	 *     (name=ID type=TypeRef)
	 * </pre>
	 */
	protected void sequence_IdAttribute(ISerializationContext context, IdAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIdAttributeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getIdAttributeAccess().getTypeTypeRefParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractElement returns Import
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildCard
	 * </pre>
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildCardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractElement returns ManyToManyMappedByRelationshipAttribute
	 *     Feature returns ManyToManyMappedByRelationshipAttribute
	 *     StructuralFeature returns ManyToManyMappedByRelationshipAttribute
	 *     Attribute returns ManyToManyMappedByRelationshipAttribute
	 *     RelationshipAttribute returns ManyToManyMappedByRelationshipAttribute
	 *     MultipleRelationshipAttribute returns ManyToManyMappedByRelationshipAttribute
	 *     ManyToManyMappedByRelationshipAttribute returns ManyToManyMappedByRelationshipAttribute
	 *     TypedElement returns ManyToManyMappedByRelationshipAttribute
	 *
	 * Constraint:
	 *     (name=ID type=TypeRef)
	 * </pre>
	 */
	protected void sequence_ManyToManyMappedByRelationshipAttribute(ISerializationContext context, ManyToManyMappedByRelationshipAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getManyToManyMappedByRelationshipAttributeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getManyToManyMappedByRelationshipAttributeAccess().getTypeTypeRefParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractElement returns ManyToManyRelationshipAttribute
	 *     Feature returns ManyToManyRelationshipAttribute
	 *     StructuralFeature returns ManyToManyRelationshipAttribute
	 *     Attribute returns ManyToManyRelationshipAttribute
	 *     RelationshipAttribute returns ManyToManyRelationshipAttribute
	 *     MultipleRelationshipAttribute returns ManyToManyRelationshipAttribute
	 *     ManyToManyRelationshipAttribute returns ManyToManyRelationshipAttribute
	 *     TypedElement returns ManyToManyRelationshipAttribute
	 *
	 * Constraint:
	 *     (name=ID type=TypeRef)
	 * </pre>
	 */
	protected void sequence_ManyToManyRelationshipAttribute(ISerializationContext context, ManyToManyRelationshipAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getManyToManyRelationshipAttributeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getManyToManyRelationshipAttributeAccess().getTypeTypeRefParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractElement returns ManyToOneJoinColumnRelationShipAttribute
	 *     Feature returns ManyToOneJoinColumnRelationShipAttribute
	 *     StructuralFeature returns ManyToOneJoinColumnRelationShipAttribute
	 *     Attribute returns ManyToOneJoinColumnRelationShipAttribute
	 *     RelationshipAttribute returns ManyToOneJoinColumnRelationShipAttribute
	 *     SingularRelationshipAttribute returns ManyToOneJoinColumnRelationShipAttribute
	 *     ManyToOneJoinColumnRelationShipAttribute returns ManyToOneJoinColumnRelationShipAttribute
	 *     TypedElement returns ManyToOneJoinColumnRelationShipAttribute
	 *
	 * Constraint:
	 *     (name=ID type=TypeRef joinColumnOverride=STRING?)
	 * </pre>
	 */
	protected void sequence_ManyToOneJoinColumnRelationShipAttribute(ISerializationContext context, ManyToOneJoinColumnRelationShipAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractElement returns ManyToOneJoinTableRelationShipAttribute
	 *     Feature returns ManyToOneJoinTableRelationShipAttribute
	 *     StructuralFeature returns ManyToOneJoinTableRelationShipAttribute
	 *     Attribute returns ManyToOneJoinTableRelationShipAttribute
	 *     RelationshipAttribute returns ManyToOneJoinTableRelationShipAttribute
	 *     SingularRelationshipAttribute returns ManyToOneJoinTableRelationShipAttribute
	 *     ManyToOneJoinTableRelationShipAttribute returns ManyToOneJoinTableRelationShipAttribute
	 *     TypedElement returns ManyToOneJoinTableRelationShipAttribute
	 *
	 * Constraint:
	 *     (name=ID type=TypeRef)
	 * </pre>
	 */
	protected void sequence_ManyToOneJoinTableRelationShipAttribute(ISerializationContext context, ManyToOneJoinTableRelationShipAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getManyToOneJoinTableRelationShipAttributeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getManyToOneJoinTableRelationShipAttributeAccess().getTypeTypeRefParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractElement returns ManyToOneMappedByRelationShipAttribute
	 *     Feature returns ManyToOneMappedByRelationShipAttribute
	 *     StructuralFeature returns ManyToOneMappedByRelationShipAttribute
	 *     Attribute returns ManyToOneMappedByRelationShipAttribute
	 *     RelationshipAttribute returns ManyToOneMappedByRelationShipAttribute
	 *     SingularRelationshipAttribute returns ManyToOneMappedByRelationShipAttribute
	 *     ManyToOneMappedByRelationShipAttribute returns ManyToOneMappedByRelationShipAttribute
	 *     TypedElement returns ManyToOneMappedByRelationShipAttribute
	 *
	 * Constraint:
	 *     (name=ID type=TypeRef)
	 * </pre>
	 */
	protected void sequence_ManyToOneMappedByRelationShipAttribute(ISerializationContext context, ManyToOneMappedByRelationShipAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getManyToOneMappedByRelationShipAttributeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getManyToOneMappedByRelationShipAttributeAccess().getTypeTypeRefParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     elements+=AbstractElement+
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractElement returns OneToManyJoinColumnRelationshipAttribute
	 *     Feature returns OneToManyJoinColumnRelationshipAttribute
	 *     StructuralFeature returns OneToManyJoinColumnRelationshipAttribute
	 *     Attribute returns OneToManyJoinColumnRelationshipAttribute
	 *     RelationshipAttribute returns OneToManyJoinColumnRelationshipAttribute
	 *     MultipleRelationshipAttribute returns OneToManyJoinColumnRelationshipAttribute
	 *     OneToManyJoinColumnRelationshipAttribute returns OneToManyJoinColumnRelationshipAttribute
	 *     TypedElement returns OneToManyJoinColumnRelationshipAttribute
	 *
	 * Constraint:
	 *     (name=ID type=TypeRef)
	 * </pre>
	 */
	protected void sequence_OneToManyJoinColumnRelationshipAttribute(ISerializationContext context, OneToManyJoinColumnRelationshipAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOneToManyJoinColumnRelationshipAttributeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOneToManyJoinColumnRelationshipAttributeAccess().getTypeTypeRefParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractElement returns OneToManyJoinTableRelationshipAttribute
	 *     Feature returns OneToManyJoinTableRelationshipAttribute
	 *     StructuralFeature returns OneToManyJoinTableRelationshipAttribute
	 *     Attribute returns OneToManyJoinTableRelationshipAttribute
	 *     RelationshipAttribute returns OneToManyJoinTableRelationshipAttribute
	 *     MultipleRelationshipAttribute returns OneToManyJoinTableRelationshipAttribute
	 *     OneToManyJoinTableRelationshipAttribute returns OneToManyJoinTableRelationshipAttribute
	 *     TypedElement returns OneToManyJoinTableRelationshipAttribute
	 *
	 * Constraint:
	 *     (name=ID type=TypeRef)
	 * </pre>
	 */
	protected void sequence_OneToManyJoinTableRelationshipAttribute(ISerializationContext context, OneToManyJoinTableRelationshipAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOneToManyJoinTableRelationshipAttributeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOneToManyJoinTableRelationshipAttributeAccess().getTypeTypeRefParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractElement returns OneToManyMappedByRelationshipAttribute
	 *     Feature returns OneToManyMappedByRelationshipAttribute
	 *     StructuralFeature returns OneToManyMappedByRelationshipAttribute
	 *     Attribute returns OneToManyMappedByRelationshipAttribute
	 *     RelationshipAttribute returns OneToManyMappedByRelationshipAttribute
	 *     MultipleRelationshipAttribute returns OneToManyMappedByRelationshipAttribute
	 *     OneToManyMappedByRelationshipAttribute returns OneToManyMappedByRelationshipAttribute
	 *     TypedElement returns OneToManyMappedByRelationshipAttribute
	 *
	 * Constraint:
	 *     (name=ID type=TypeRef)
	 * </pre>
	 */
	protected void sequence_OneToManyMappedByRelationshipAttribute(ISerializationContext context, OneToManyMappedByRelationshipAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOneToManyMappedByRelationshipAttributeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOneToManyMappedByRelationshipAttributeAccess().getTypeTypeRefParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractElement returns OneToOneMappedByRelationshipAttribute
	 *     Feature returns OneToOneMappedByRelationshipAttribute
	 *     StructuralFeature returns OneToOneMappedByRelationshipAttribute
	 *     Attribute returns OneToOneMappedByRelationshipAttribute
	 *     RelationshipAttribute returns OneToOneMappedByRelationshipAttribute
	 *     SingularRelationshipAttribute returns OneToOneMappedByRelationshipAttribute
	 *     OneToOneMappedByRelationshipAttribute returns OneToOneMappedByRelationshipAttribute
	 *     TypedElement returns OneToOneMappedByRelationshipAttribute
	 *
	 * Constraint:
	 *     (name=ID type=TypeRef)
	 * </pre>
	 */
	protected void sequence_OneToOneMappedByRelationshipAttribute(ISerializationContext context, OneToOneMappedByRelationshipAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOneToOneMappedByRelationshipAttributeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOneToOneMappedByRelationshipAttributeAccess().getTypeTypeRefParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractElement returns OneToOneRelationshipAttribute
	 *     Feature returns OneToOneRelationshipAttribute
	 *     StructuralFeature returns OneToOneRelationshipAttribute
	 *     Attribute returns OneToOneRelationshipAttribute
	 *     RelationshipAttribute returns OneToOneRelationshipAttribute
	 *     SingularRelationshipAttribute returns OneToOneRelationshipAttribute
	 *     OneToOneRelationshipAttribute returns OneToOneRelationshipAttribute
	 *     TypedElement returns OneToOneRelationshipAttribute
	 *
	 * Constraint:
	 *     (name=ID type=TypeRef joinColumnOverride=STRING?)
	 * </pre>
	 */
	protected void sequence_OneToOneRelationshipAttribute(ISerializationContext context, OneToOneRelationshipAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Feature returns Operation
	 *     Operation returns Operation
	 *     TypedElement returns Operation
	 *
	 * Constraint:
	 *     (visibility=Visibility? name=ID (params+=Parameter params+=Parameter*)? type=TypeRef)
	 * </pre>
	 */
	protected void sequence_Operation(ISerializationContext context, Operation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractElement returns PackageDeclaration
	 *     PackageDeclaration returns PackageDeclaration
	 *
	 * Constraint:
	 *     (name=QualifiedName databaseModes+=DatabaseMode* elements+=AbstractElement*)
	 * </pre>
	 */
	protected void sequence_PackageDeclaration(ISerializationContext context, PackageDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Parameter returns Parameter
	 *     TypedElement returns Parameter
	 *
	 * Constraint:
	 *     (name=ID type=TypeRef)
	 * </pre>
	 */
	protected void sequence_Parameter(ISerializationContext context, jpadsl.jPADsl.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParameterAccess().getTypeTypeRefParserRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Feature returns ReadOnlyInternalAttribute
	 *     StructuralFeature returns ReadOnlyInternalAttribute
	 *     Attribute returns ReadOnlyInternalAttribute
	 *     InternalAttribute returns ReadOnlyInternalAttribute
	 *     ReadOnlyInternalAttribute returns ReadOnlyInternalAttribute
	 *     TypedElement returns ReadOnlyInternalAttribute
	 *
	 * Constraint:
	 *     (name=ID type=TypeRef)
	 * </pre>
	 */
	protected void sequence_ReadOnlyInternalAttribute(ISerializationContext context, ReadOnlyInternalAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReadOnlyInternalAttributeAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getReadOnlyInternalAttributeAccess().getTypeTypeRefParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReadOnly returns ReadOnly
	 *
	 * Constraint:
	 *     (tableName=STRING idColumn=STRING)
	 * </pre>
	 */
	protected void sequence_ReadOnly(ISerializationContext context, ReadOnly semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.READ_ONLY__TABLE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.READ_ONLY__TABLE_NAME));
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.READ_ONLY__ID_COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.READ_ONLY__ID_COLUMN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReadOnlyAccess().getTableNameSTRINGTerminalRuleCall_1_0(), semanticObject.getTableName());
		feeder.accept(grammarAccess.getReadOnlyAccess().getIdColumnSTRINGTerminalRuleCall_2_0(), semanticObject.getIdColumn());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Feature returns Reference
	 *     StructuralFeature returns Reference
	 *     Reference returns Reference
	 *     TypedElement returns Reference
	 *
	 * Constraint:
	 *     (name=ID type=TypeRef opposite=[Reference|ID]?)
	 * </pre>
	 */
	protected void sequence_Reference(ISerializationContext context, Reference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Feature returns StaticAttribute
	 *     StructuralFeature returns StaticAttribute
	 *     Attribute returns StaticAttribute
	 *     StaticAttribute returns StaticAttribute
	 *     TypedElement returns StaticAttribute
	 *
	 * Constraint:
	 *     (name=ID type=TypeRef)
	 * </pre>
	 */
	protected void sequence_StaticAttribute(ISerializationContext context, StaticAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStaticAttributeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getStaticAttributeAccess().getTypeTypeRefParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Feature returns TransientAttribute
	 *     StructuralFeature returns TransientAttribute
	 *     Attribute returns TransientAttribute
	 *     InternalAttribute returns TransientAttribute
	 *     TransientAttribute returns TransientAttribute
	 *     TypedElement returns TransientAttribute
	 *
	 * Constraint:
	 *     (name=ID type=TypeRef)
	 * </pre>
	 */
	protected void sequence_TransientAttribute(ISerializationContext context, TransientAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTransientAttributeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTransientAttributeAccess().getTypeTypeRefParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeRef returns TypeRef
	 *
	 * Constraint:
	 *     (referenced=[Type|ID] multi?='*'?)
	 * </pre>
	 */
	protected void sequence_TypeRef(ISerializationContext context, TypeRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Identifier returns UniqueIdentiferColumn
	 *     UniqueIdentiferColumn returns UniqueIdentiferColumn
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_UniqueIdentiferColumn(ISerializationContext context, UniqueIdentiferColumn semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.IDENTIFIER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.IDENTIFIER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUniqueIdentiferColumnAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Feature returns UpdatableInternalAttribute
	 *     StructuralFeature returns UpdatableInternalAttribute
	 *     Attribute returns UpdatableInternalAttribute
	 *     InternalAttribute returns UpdatableInternalAttribute
	 *     UpdatableInternalAttribute returns UpdatableInternalAttribute
	 *     TypedElement returns UpdatableInternalAttribute
	 *
	 * Constraint:
	 *     (name=ID type=TypeRef)
	 * </pre>
	 */
	protected void sequence_UpdatableInternalAttribute(ISerializationContext context, UpdatableInternalAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPADslPackage.Literals.TYPED_ELEMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpdatableInternalAttributeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getUpdatableInternalAttributeAccess().getTypeTypeRefParserRuleCall_3_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
}

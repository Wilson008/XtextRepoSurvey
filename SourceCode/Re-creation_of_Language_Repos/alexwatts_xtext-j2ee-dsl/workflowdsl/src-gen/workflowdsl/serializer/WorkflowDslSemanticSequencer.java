/*
 * generated by Xtext 2.35.0
 */
package workflowdsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import workflowdsl.services.WorkflowDslGrammarAccess;
import workflowdsl.workflowDsl.AssertFlow;
import workflowdsl.workflowDsl.AssertWait;
import workflowdsl.workflowDsl.AsyncronousServiceTask;
import workflowdsl.workflowDsl.BasicConnector;
import workflowdsl.workflowDsl.ClassName;
import workflowdsl.workflowDsl.ConditionalConnector;
import workflowdsl.workflowDsl.EndNode;
import workflowdsl.workflowDsl.Event;
import workflowdsl.workflowDsl.EventBasedInput;
import workflowdsl.workflowDsl.ExclusiveConverging;
import workflowdsl.workflowDsl.ExlcusiveDiverging;
import workflowdsl.workflowDsl.FireSignal;
import workflowdsl.workflowDsl.Import;
import workflowdsl.workflowDsl.MarketName;
import workflowdsl.workflowDsl.Model;
import workflowdsl.workflowDsl.OutputData;
import workflowdsl.workflowDsl.ParallelConverging;
import workflowdsl.workflowDsl.ParallelDiverging;
import workflowdsl.workflowDsl.ProcessVariable;
import workflowdsl.workflowDsl.Signal;
import workflowdsl.workflowDsl.StartNode;
import workflowdsl.workflowDsl.StringBasedConditionalVaraible;
import workflowdsl.workflowDsl.SyncronousServiceTask;
import workflowdsl.workflowDsl.TaskNameInput;
import workflowdsl.workflowDsl.Test;
import workflowdsl.workflowDsl.VariableBasedInput;
import workflowdsl.workflowDsl.WorkflowDefinition;
import workflowdsl.workflowDsl.WorkflowDslPackage;

@SuppressWarnings("all")
public class WorkflowDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private WorkflowDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == WorkflowDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case WorkflowDslPackage.ASSERT_FLOW:
				sequence_AssertFlow(context, (AssertFlow) semanticObject); 
				return; 
			case WorkflowDslPackage.ASSERT_WAIT:
				sequence_AssertWait(context, (AssertWait) semanticObject); 
				return; 
			case WorkflowDslPackage.ASYNCRONOUS_SERVICE_TASK:
				sequence_AsyncronousServiceTask(context, (AsyncronousServiceTask) semanticObject); 
				return; 
			case WorkflowDslPackage.BASIC_CONNECTOR:
				sequence_BasicConnector(context, (BasicConnector) semanticObject); 
				return; 
			case WorkflowDslPackage.CLASS_NAME:
				sequence_ClassName(context, (ClassName) semanticObject); 
				return; 
			case WorkflowDslPackage.CONDITIONAL_CONNECTOR:
				sequence_ConditionalConnector(context, (ConditionalConnector) semanticObject); 
				return; 
			case WorkflowDslPackage.END_NODE:
				sequence_EndNode(context, (EndNode) semanticObject); 
				return; 
			case WorkflowDslPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case WorkflowDslPackage.EVENT_BASED_INPUT:
				sequence_EventBasedInput(context, (EventBasedInput) semanticObject); 
				return; 
			case WorkflowDslPackage.EXCLUSIVE_CONVERGING:
				sequence_ExclusiveConverging(context, (ExclusiveConverging) semanticObject); 
				return; 
			case WorkflowDslPackage.EXLCUSIVE_DIVERGING:
				sequence_ExlcusiveDiverging(context, (ExlcusiveDiverging) semanticObject); 
				return; 
			case WorkflowDslPackage.FIRE_SIGNAL:
				sequence_FireSignal(context, (FireSignal) semanticObject); 
				return; 
			case WorkflowDslPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case WorkflowDslPackage.MARKET_NAME:
				sequence_MarketName(context, (MarketName) semanticObject); 
				return; 
			case WorkflowDslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case WorkflowDslPackage.OUTPUT_DATA:
				sequence_OutputData(context, (OutputData) semanticObject); 
				return; 
			case WorkflowDslPackage.PACKAGE:
				sequence_Package(context, (workflowdsl.workflowDsl.Package) semanticObject); 
				return; 
			case WorkflowDslPackage.PARALLEL_CONVERGING:
				sequence_ParallelConverging(context, (ParallelConverging) semanticObject); 
				return; 
			case WorkflowDslPackage.PARALLEL_DIVERGING:
				sequence_ParallelDiverging(context, (ParallelDiverging) semanticObject); 
				return; 
			case WorkflowDslPackage.PROCESS_VARIABLE:
				sequence_ProcessVariable(context, (ProcessVariable) semanticObject); 
				return; 
			case WorkflowDslPackage.SIGNAL:
				sequence_Signal(context, (Signal) semanticObject); 
				return; 
			case WorkflowDslPackage.START_NODE:
				sequence_StartNode(context, (StartNode) semanticObject); 
				return; 
			case WorkflowDslPackage.STRING_BASED_CONDITIONAL_VARAIBLE:
				sequence_StringBasedConditionalVaraible(context, (StringBasedConditionalVaraible) semanticObject); 
				return; 
			case WorkflowDslPackage.SYNCRONOUS_SERVICE_TASK:
				sequence_SyncronousServiceTask(context, (SyncronousServiceTask) semanticObject); 
				return; 
			case WorkflowDslPackage.TASK_NAME_INPUT:
				sequence_TaskNameInput(context, (TaskNameInput) semanticObject); 
				return; 
			case WorkflowDslPackage.TEST:
				sequence_Test(context, (Test) semanticObject); 
				return; 
			case WorkflowDslPackage.VARIABLE_BASED_INPUT:
				sequence_VariableBasedInput(context, (VariableBasedInput) semanticObject); 
				return; 
			case WorkflowDslPackage.WORKFLOW_DEFINITION:
				sequence_WorkflowDefinition(context, (WorkflowDefinition) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssertFlow returns AssertFlow
	 *
	 * Constraint:
	 *     nodes+=[Node|ID]+
	 * </pre>
	 */
	protected void sequence_AssertFlow(ISerializationContext context, AssertFlow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AssertWait returns AssertWait
	 *
	 * Constraint:
	 *     nodes+=[Node|ID]+
	 * </pre>
	 */
	protected void sequence_AssertWait(ISerializationContext context, AssertWait semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns AsyncronousServiceTask
	 *     ServiceTask returns AsyncronousServiceTask
	 *     AsyncronousServiceTask returns AsyncronousServiceTask
	 *
	 * Constraint:
	 *     (name=ID inputs+=InputData* output=OutputData?)
	 * </pre>
	 */
	protected void sequence_AsyncronousServiceTask(ISerializationContext context, AsyncronousServiceTask semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Connector returns BasicConnector
	 *     BasicConnector returns BasicConnector
	 *
	 * Constraint:
	 *     (from=[Node|ID] to=[Node|ID])
	 * </pre>
	 */
	protected void sequence_BasicConnector(ISerializationContext context, BasicConnector semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.CONNECTOR__FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.CONNECTOR__FROM));
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.CONNECTOR__TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.CONNECTOR__TO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBasicConnectorAccess().getFromNodeIDTerminalRuleCall_1_0_1(), semanticObject.eGet(WorkflowDslPackage.Literals.CONNECTOR__FROM, false));
		feeder.accept(grammarAccess.getBasicConnectorAccess().getToNodeIDTerminalRuleCall_2_0_1(), semanticObject.eGet(WorkflowDslPackage.Literals.CONNECTOR__TO, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ClassName returns ClassName
	 *
	 * Constraint:
	 *     className=STRING
	 * </pre>
	 */
	protected void sequence_ClassName(ISerializationContext context, ClassName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.CLASS_NAME__CLASS_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.CLASS_NAME__CLASS_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClassNameAccess().getClassNameSTRINGTerminalRuleCall_1_0(), semanticObject.getClassName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Connector returns ConditionalConnector
	 *     ConditionalConnector returns ConditionalConnector
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         from=[Node|ID] 
	 *         to=[Node|ID] 
	 *         event=[Event|ID] 
	 *         stringBasedConditionalExpression=[StringBasedConditionalVaraible|ID] 
	 *         value=STRING
	 *     )
	 * </pre>
	 */
	protected void sequence_ConditionalConnector(ISerializationContext context, ConditionalConnector semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.CONDITIONAL_CONNECTOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.CONDITIONAL_CONNECTOR__NAME));
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.CONNECTOR__FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.CONNECTOR__FROM));
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.CONNECTOR__TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.CONNECTOR__TO));
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.CONDITIONAL_CONNECTOR__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.CONDITIONAL_CONNECTOR__EVENT));
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.CONDITIONAL_CONNECTOR__STRING_BASED_CONDITIONAL_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.CONDITIONAL_CONNECTOR__STRING_BASED_CONDITIONAL_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.CONDITIONAL_CONNECTOR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.CONDITIONAL_CONNECTOR__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalConnectorAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getConditionalConnectorAccess().getFromNodeIDTerminalRuleCall_2_0_1(), semanticObject.eGet(WorkflowDslPackage.Literals.CONNECTOR__FROM, false));
		feeder.accept(grammarAccess.getConditionalConnectorAccess().getToNodeIDTerminalRuleCall_3_0_1(), semanticObject.eGet(WorkflowDslPackage.Literals.CONNECTOR__TO, false));
		feeder.accept(grammarAccess.getConditionalConnectorAccess().getEventEventIDTerminalRuleCall_5_0_1(), semanticObject.eGet(WorkflowDslPackage.Literals.CONDITIONAL_CONNECTOR__EVENT, false));
		feeder.accept(grammarAccess.getConditionalConnectorAccess().getStringBasedConditionalExpressionStringBasedConditionalVaraibleIDTerminalRuleCall_6_0_1(), semanticObject.eGet(WorkflowDslPackage.Literals.CONDITIONAL_CONNECTOR__STRING_BASED_CONDITIONAL_EXPRESSION, false));
		feeder.accept(grammarAccess.getConditionalConnectorAccess().getValueSTRINGTerminalRuleCall_7_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns EndNode
	 *     EndNode returns EndNode
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_EndNode(ISerializationContext context, EndNode semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.NODE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.NODE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEndNodeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InputData returns EventBasedInput
	 *     EventBasedInput returns EventBasedInput
	 *
	 * Constraint:
	 *     (event=[Event|ID] variable=[StringBasedConditionalVaraible|ID] eventParameterName=STRING)
	 * </pre>
	 */
	protected void sequence_EventBasedInput(ISerializationContext context, EventBasedInput semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.EVENT_BASED_INPUT__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.EVENT_BASED_INPUT__EVENT));
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.EVENT_BASED_INPUT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.EVENT_BASED_INPUT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.EVENT_BASED_INPUT__EVENT_PARAMETER_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.EVENT_BASED_INPUT__EVENT_PARAMETER_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEventBasedInputAccess().getEventEventIDTerminalRuleCall_1_0_1(), semanticObject.eGet(WorkflowDslPackage.Literals.EVENT_BASED_INPUT__EVENT, false));
		feeder.accept(grammarAccess.getEventBasedInputAccess().getVariableStringBasedConditionalVaraibleIDTerminalRuleCall_2_0_1(), semanticObject.eGet(WorkflowDslPackage.Literals.EVENT_BASED_INPUT__VARIABLE, false));
		feeder.accept(grammarAccess.getEventBasedInputAccess().getEventParameterNameSTRINGTerminalRuleCall_3_0(), semanticObject.getEventParameterName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Event returns Event
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Event(ISerializationContext context, Event semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.EVENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.EVENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEventAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns ExclusiveConverging
	 *     Gateway returns ExclusiveConverging
	 *     ConvergingGateway returns ExclusiveConverging
	 *     ExclusiveConverging returns ExclusiveConverging
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_ExclusiveConverging(ISerializationContext context, ExclusiveConverging semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.NODE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.NODE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExclusiveConvergingAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns ExlcusiveDiverging
	 *     Gateway returns ExlcusiveDiverging
	 *     DivergingGateway returns ExlcusiveDiverging
	 *     ExlcusiveDiverging returns ExlcusiveDiverging
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_ExlcusiveDiverging(ISerializationContext context, ExlcusiveDiverging semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.NODE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.NODE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExlcusiveDivergingAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FireSignal returns FireSignal
	 *
	 * Constraint:
	 *     (fireSignal=[Signal|ID] case=[ConditionalConnector|ID]?)
	 * </pre>
	 */
	protected void sequence_FireSignal(ISerializationContext context, FireSignal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildCard
	 * </pre>
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildCardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MarketName returns MarketName
	 *
	 * Constraint:
	 *     marketName=STRING
	 * </pre>
	 */
	protected void sequence_MarketName(ISerializationContext context, MarketName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.MARKET_NAME__MARKET_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.MARKET_NAME__MARKET_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMarketNameAccess().getMarketNameSTRINGTerminalRuleCall_1_0(), semanticObject.getMarketName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (imports+=Import+ workflowDefinitions+=WorkflowDefinition+)
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OutputData returns OutputData
	 *
	 * Constraint:
	 *     value=[StringBasedConditionalVaraible|ID]
	 * </pre>
	 */
	protected void sequence_OutputData(ISerializationContext context, OutputData semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.OUTPUT_DATA__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.OUTPUT_DATA__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutputDataAccess().getValueStringBasedConditionalVaraibleIDTerminalRuleCall_1_0_1(), semanticObject.eGet(WorkflowDslPackage.Literals.OUTPUT_DATA__VALUE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Package returns Package
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Package(ISerializationContext context, workflowdsl.workflowDsl.Package semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.PACKAGE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.PACKAGE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPackageAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns ParallelConverging
	 *     Gateway returns ParallelConverging
	 *     ConvergingGateway returns ParallelConverging
	 *     ParallelConverging returns ParallelConverging
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_ParallelConverging(ISerializationContext context, ParallelConverging semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.NODE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.NODE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParallelConvergingAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns ParallelDiverging
	 *     Gateway returns ParallelDiverging
	 *     DivergingGateway returns ParallelDiverging
	 *     ParallelDiverging returns ParallelDiverging
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_ParallelDiverging(ISerializationContext context, ParallelDiverging semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.NODE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.NODE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParallelDivergingAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProcessVariable returns ProcessVariable
	 *
	 * Constraint:
	 *     (variable=[StringBasedConditionalVaraible|ID] value=[ConditionalConnector|ID])
	 * </pre>
	 */
	protected void sequence_ProcessVariable(ISerializationContext context, ProcessVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.PROCESS_VARIABLE__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.PROCESS_VARIABLE__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.PROCESS_VARIABLE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.PROCESS_VARIABLE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProcessVariableAccess().getVariableStringBasedConditionalVaraibleIDTerminalRuleCall_1_0_1(), semanticObject.eGet(WorkflowDslPackage.Literals.PROCESS_VARIABLE__VARIABLE, false));
		feeder.accept(grammarAccess.getProcessVariableAccess().getValueConditionalConnectorIDTerminalRuleCall_2_0_1(), semanticObject.eGet(WorkflowDslPackage.Literals.PROCESS_VARIABLE__VALUE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns Signal
	 *     Signal returns Signal
	 *
	 * Constraint:
	 *     (name=ID event=[Event|ID] output=OutputData?)
	 * </pre>
	 */
	protected void sequence_Signal(ISerializationContext context, Signal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns StartNode
	 *     StartNode returns StartNode
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_StartNode(ISerializationContext context, StartNode semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.NODE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.NODE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStartNodeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Variable returns StringBasedConditionalVaraible
	 *     StringBasedConditionalVaraible returns StringBasedConditionalVaraible
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_StringBasedConditionalVaraible(ISerializationContext context, StringBasedConditionalVaraible semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.STRING_BASED_CONDITIONAL_VARAIBLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.STRING_BASED_CONDITIONAL_VARAIBLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringBasedConditionalVaraibleAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns SyncronousServiceTask
	 *     ServiceTask returns SyncronousServiceTask
	 *     SyncronousServiceTask returns SyncronousServiceTask
	 *
	 * Constraint:
	 *     (name=ID inputs+=InputData* output=OutputData?)
	 * </pre>
	 */
	protected void sequence_SyncronousServiceTask(ISerializationContext context, SyncronousServiceTask semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InputData returns TaskNameInput
	 *     TaskNameInput returns TaskNameInput
	 *
	 * Constraint:
	 *     {TaskNameInput}
	 * </pre>
	 */
	protected void sequence_TaskNameInput(ISerializationContext context, TaskNameInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Test returns Test
	 *
	 * Constraint:
	 *     (name=ID processVariables+=ProcessVariable* fireSignal+=FireSignal* assertFlow+=AssertFlow* assertWait+=AssertWait*)
	 * </pre>
	 */
	protected void sequence_Test(ISerializationContext context, Test semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InputData returns VariableBasedInput
	 *     VariableBasedInput returns VariableBasedInput
	 *
	 * Constraint:
	 *     (variable=[StringBasedConditionalVaraible|ID] eventParameterName=STRING)
	 * </pre>
	 */
	protected void sequence_VariableBasedInput(ISerializationContext context, VariableBasedInput semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.VARIABLE_BASED_INPUT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.VARIABLE_BASED_INPUT__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, WorkflowDslPackage.Literals.VARIABLE_BASED_INPUT__EVENT_PARAMETER_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WorkflowDslPackage.Literals.VARIABLE_BASED_INPUT__EVENT_PARAMETER_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableBasedInputAccess().getVariableStringBasedConditionalVaraibleIDTerminalRuleCall_1_0_1(), semanticObject.eGet(WorkflowDslPackage.Literals.VARIABLE_BASED_INPUT__VARIABLE, false));
		feeder.accept(grammarAccess.getVariableBasedInputAccess().getEventParameterNameSTRINGTerminalRuleCall_2_0(), semanticObject.getEventParameterName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     WorkflowDefinition returns WorkflowDefinition
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         className=ClassName 
	 *         packages=Package 
	 *         events+=Event* 
	 *         variables+=Variable* 
	 *         nodes+=Node+ 
	 *         connectors+=Connector+ 
	 *         tests+=Test+
	 *     )
	 * </pre>
	 */
	protected void sequence_WorkflowDefinition(ISerializationContext context, WorkflowDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}

/*
 * generated by Xtext 2.35.0
 */
package jpaqldsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import jpaqldsl.jPAQLDsl.AggregateExpression;
import jpaqldsl.jPAQLDsl.AllOrAnyExpression;
import jpaqldsl.jPAQLDsl.ArithmeticExpression;
import jpaqldsl.jPAQLDsl.ArithmeticPrimary;
import jpaqldsl.jPAQLDsl.ArithmeticTerm;
import jpaqldsl.jPAQLDsl.BetweenExpression;
import jpaqldsl.jPAQLDsl.BooleanExpression;
import jpaqldsl.jPAQLDsl.BooleanPrimary;
import jpaqldsl.jPAQLDsl.CollectionMemberDeclaration;
import jpaqldsl.jPAQLDsl.CollectionMemberExpression;
import jpaqldsl.jPAQLDsl.ComparisonExpression;
import jpaqldsl.jPAQLDsl.ConditionalExpression;
import jpaqldsl.jPAQLDsl.ConditionalTerm;
import jpaqldsl.jPAQLDsl.ConstructorExpression;
import jpaqldsl.jPAQLDsl.ConstructorName;
import jpaqldsl.jPAQLDsl.DateTimeExpression;
import jpaqldsl.jPAQLDsl.DateTimePrimary;
import jpaqldsl.jPAQLDsl.EmptyCollectionComparisonExpression;
import jpaqldsl.jPAQLDsl.EntityExpression;
import jpaqldsl.jPAQLDsl.EnumExpression;
import jpaqldsl.jPAQLDsl.EnumLiteral;
import jpaqldsl.jPAQLDsl.EnumPrimary;
import jpaqldsl.jPAQLDsl.EscapeCharacter;
import jpaqldsl.jPAQLDsl.ExistsExpression;
import jpaqldsl.jPAQLDsl.Expression;
import jpaqldsl.jPAQLDsl.FetchJoin;
import jpaqldsl.jPAQLDsl.FromClause;
import jpaqldsl.jPAQLDsl.FunctionsReturningNumerics;
import jpaqldsl.jPAQLDsl.FunctionsReturningStrings;
import jpaqldsl.jPAQLDsl.IdentificationVariable;
import jpaqldsl.jPAQLDsl.IdentificationVariableDeclaration;
import jpaqldsl.jPAQLDsl.Import;
import jpaqldsl.jPAQLDsl.InExpression;
import jpaqldsl.jPAQLDsl.InItem;
import jpaqldsl.jPAQLDsl.InputParameter;
import jpaqldsl.jPAQLDsl.JPAPathExpression;
import jpaqldsl.jPAQLDsl.JPAQLDslPackage;
import jpaqldsl.jPAQLDsl.Join;
import jpaqldsl.jPAQLDsl.JpaAttribute;
import jpaqldsl.jPAQLDsl.LikeExpression;
import jpaqldsl.jPAQLDsl.Literal;
import jpaqldsl.jPAQLDsl.Model;
import jpaqldsl.jPAQLDsl.NamedQuery;
import jpaqldsl.jPAQLDsl.NullComparisonExpression;
import jpaqldsl.jPAQLDsl.NumericLiteral;
import jpaqldsl.jPAQLDsl.PatternValue;
import jpaqldsl.jPAQLDsl.QLStatement;
import jpaqldsl.jPAQLDsl.RangeVariableDeclaration;
import jpaqldsl.jPAQLDsl.SelectClause;
import jpaqldsl.jPAQLDsl.SelectExpression;
import jpaqldsl.jPAQLDsl.SelectStatement;
import jpaqldsl.jPAQLDsl.SimpleArithmeticExpression;
import jpaqldsl.jPAQLDsl.SimpleConditionalExpression;
import jpaqldsl.jPAQLDsl.SimpleEntityExpression;
import jpaqldsl.jPAQLDsl.SimpleSelectClause;
import jpaqldsl.jPAQLDsl.SimpleSelectExpression;
import jpaqldsl.jPAQLDsl.StringExpression;
import jpaqldsl.jPAQLDsl.StringLiteral;
import jpaqldsl.jPAQLDsl.StringPrimary;
import jpaqldsl.jPAQLDsl.SubQuery;
import jpaqldsl.jPAQLDsl.SubqueryFromClause;
import jpaqldsl.jPAQLDsl.SubselectIdentificationVariableDeclaration;
import jpaqldsl.jPAQLDsl.TrimCharacter;
import jpaqldsl.jPAQLDsl.WhereClause;
import jpaqldsl.services.JPAQLDslGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.common.types.JvmFormalParameter;
import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;
import org.eclipse.xtext.common.types.JvmInnerTypeReference;
import org.eclipse.xtext.common.types.JvmLowerBound;
import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;
import org.eclipse.xtext.common.types.JvmTypeParameter;
import org.eclipse.xtext.common.types.JvmUpperBound;
import org.eclipse.xtext.common.types.JvmWildcardTypeReference;
import org.eclipse.xtext.common.types.TypesPackage;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.eclipse.xtext.xbase.XAssignment;
import org.eclipse.xtext.xbase.XBasicForLoopExpression;
import org.eclipse.xtext.xbase.XBinaryOperation;
import org.eclipse.xtext.xbase.XBlockExpression;
import org.eclipse.xtext.xbase.XBooleanLiteral;
import org.eclipse.xtext.xbase.XCasePart;
import org.eclipse.xtext.xbase.XCastedExpression;
import org.eclipse.xtext.xbase.XCatchClause;
import org.eclipse.xtext.xbase.XClosure;
import org.eclipse.xtext.xbase.XConstructorCall;
import org.eclipse.xtext.xbase.XDoWhileExpression;
import org.eclipse.xtext.xbase.XFeatureCall;
import org.eclipse.xtext.xbase.XForLoopExpression;
import org.eclipse.xtext.xbase.XIfExpression;
import org.eclipse.xtext.xbase.XInstanceOfExpression;
import org.eclipse.xtext.xbase.XListLiteral;
import org.eclipse.xtext.xbase.XMemberFeatureCall;
import org.eclipse.xtext.xbase.XNullLiteral;
import org.eclipse.xtext.xbase.XNumberLiteral;
import org.eclipse.xtext.xbase.XPostfixOperation;
import org.eclipse.xtext.xbase.XReturnExpression;
import org.eclipse.xtext.xbase.XSetLiteral;
import org.eclipse.xtext.xbase.XStringLiteral;
import org.eclipse.xtext.xbase.XSwitchExpression;
import org.eclipse.xtext.xbase.XSynchronizedExpression;
import org.eclipse.xtext.xbase.XThrowExpression;
import org.eclipse.xtext.xbase.XTryCatchFinallyExpression;
import org.eclipse.xtext.xbase.XTypeLiteral;
import org.eclipse.xtext.xbase.XUnaryOperation;
import org.eclipse.xtext.xbase.XVariableDeclaration;
import org.eclipse.xtext.xbase.XWhileExpression;
import org.eclipse.xtext.xbase.XbasePackage;
import org.eclipse.xtext.xbase.serializer.XbaseSemanticSequencer;
import org.eclipse.xtext.xtype.XFunctionTypeRef;
import org.eclipse.xtext.xtype.XImportDeclaration;
import org.eclipse.xtext.xtype.XImportSection;
import org.eclipse.xtext.xtype.XtypePackage;

@SuppressWarnings("all")
public class JPAQLDslSemanticSequencer extends XbaseSemanticSequencer {

	@Inject
	private JPAQLDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == JPAQLDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case JPAQLDslPackage.AGGREGATE_EXPRESSION:
				sequence_AggregateExpression(context, (AggregateExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.ALL_OR_ANY_EXPRESSION:
				sequence_AllOrAnyExpression(context, (AllOrAnyExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.ARITHMETIC_EXPRESSION:
				sequence_ArithmeticExpression(context, (ArithmeticExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.ARITHMETIC_PRIMARY:
				sequence_ArithmeticPrimary(context, (ArithmeticPrimary) semanticObject); 
				return; 
			case JPAQLDslPackage.ARITHMETIC_TERM:
				sequence_ArithmeticTerm(context, (ArithmeticTerm) semanticObject); 
				return; 
			case JPAQLDslPackage.BETWEEN_EXPRESSION:
				sequence_BetweenExpression(context, (BetweenExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.BOOLEAN_EXPRESSION:
				sequence_BooleanExpression(context, (BooleanExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.BOOLEAN_PRIMARY:
				sequence_BooleanPrimary(context, (BooleanPrimary) semanticObject); 
				return; 
			case JPAQLDslPackage.COLLECTION_MEMBER_DECLARATION:
				sequence_CollectionMemberDeclaration(context, (CollectionMemberDeclaration) semanticObject); 
				return; 
			case JPAQLDslPackage.COLLECTION_MEMBER_EXPRESSION:
				sequence_CollectionMemberExpression(context, (CollectionMemberExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.COMPARISON_EXPRESSION:
				sequence_ComparisonExpression(context, (ComparisonExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.CONDITIONAL_EXPRESSION:
				sequence_ConditionalExpression(context, (ConditionalExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.CONDITIONAL_TERM:
				sequence_ConditionalTerm(context, (ConditionalTerm) semanticObject); 
				return; 
			case JPAQLDslPackage.CONSTRUCTOR_EXPRESSION:
				sequence_ConstructorExpression(context, (ConstructorExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.CONSTRUCTOR_NAME:
				sequence_ConstructorName(context, (ConstructorName) semanticObject); 
				return; 
			case JPAQLDslPackage.DATE_TIME_EXPRESSION:
				sequence_DateTimeExpression(context, (DateTimeExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.DATE_TIME_PRIMARY:
				sequence_DateTimePrimary(context, (DateTimePrimary) semanticObject); 
				return; 
			case JPAQLDslPackage.EMPTY_COLLECTION_COMPARISON_EXPRESSION:
				sequence_EmptyCollectionComparisonExpression(context, (EmptyCollectionComparisonExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.ENTITY_EXPRESSION:
				sequence_EntityExpression(context, (EntityExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.ENUM_EXPRESSION:
				sequence_EnumExpression(context, (EnumExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.ENUM_LITERAL:
				sequence_EnumLiteral(context, (EnumLiteral) semanticObject); 
				return; 
			case JPAQLDslPackage.ENUM_PRIMARY:
				sequence_EnumPrimary(context, (EnumPrimary) semanticObject); 
				return; 
			case JPAQLDslPackage.ESCAPE_CHARACTER:
				sequence_EscapeCharacter(context, (EscapeCharacter) semanticObject); 
				return; 
			case JPAQLDslPackage.EXISTS_EXPRESSION:
				sequence_ExistsExpression(context, (ExistsExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.EXPRESSION:
				if (action == grammarAccess.getSimpleArithmeticExpressionAccess().getSimpleArithmeticExpressionLeftAction_1_1_0()
						|| rule == grammarAccess.getArithmeticTermRule()) {
					sequence_ArithmeticFactor_ArithmeticTerm(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleArithmeticExpressionRule()) {
					sequence_ArithmeticFactor_ArithmeticTerm_SimpleArithmeticExpression(context, (Expression) semanticObject); 
					return; 
				}
				else if (action == grammarAccess.getArithmeticTermAccess().getArithmeticTermLeftAction_1_1_0()
						|| rule == grammarAccess.getArithmeticFactorRule()) {
					sequence_ArithmeticFactor(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getConditionalExpressionRule()
						|| action == grammarAccess.getConditionalExpressionAccess().getConditionalExpressionLeftAction_1_0()
						|| rule == grammarAccess.getConditionalTermRule()
						|| action == grammarAccess.getConditionalTermAccess().getConditionalTermLeftAction_1_0()
						|| rule == grammarAccess.getConditionalFactorRule()) {
					sequence_ConditionalFactor(context, (Expression) semanticObject); 
					return; 
				}
				else break;
			case JPAQLDslPackage.FETCH_JOIN:
				sequence_FetchJoin(context, (FetchJoin) semanticObject); 
				return; 
			case JPAQLDslPackage.FROM_CLAUSE:
				sequence_FromClause(context, (FromClause) semanticObject); 
				return; 
			case JPAQLDslPackage.FUNCTIONS_RETURNING_NUMERICS:
				sequence_FunctionsReturningNumerics(context, (FunctionsReturningNumerics) semanticObject); 
				return; 
			case JPAQLDslPackage.FUNCTIONS_RETURNING_STRINGS:
				sequence_FunctionsReturningStrings(context, (FunctionsReturningStrings) semanticObject); 
				return; 
			case JPAQLDslPackage.IDENTIFICATION_VARIABLE:
				sequence_IdentificationVariable(context, (IdentificationVariable) semanticObject); 
				return; 
			case JPAQLDslPackage.IDENTIFICATION_VARIABLE_DECLARATION:
				sequence_IdentificationVariableDeclaration(context, (IdentificationVariableDeclaration) semanticObject); 
				return; 
			case JPAQLDslPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case JPAQLDslPackage.IN_EXPRESSION:
				sequence_InExpression(context, (InExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.IN_ITEM:
				sequence_InItem(context, (InItem) semanticObject); 
				return; 
			case JPAQLDslPackage.INPUT_PARAMETER:
				sequence_InputParameter(context, (InputParameter) semanticObject); 
				return; 
			case JPAQLDslPackage.JPA_PATH_EXPRESSION:
				sequence_JPAPathExpression(context, (JPAPathExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.JOIN:
				sequence_Join(context, (Join) semanticObject); 
				return; 
			case JPAQLDslPackage.JPA_ATTRIBUTE:
				sequence_JpaAttribute(context, (JpaAttribute) semanticObject); 
				return; 
			case JPAQLDslPackage.LIKE_EXPRESSION:
				sequence_LikeExpression(context, (LikeExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.LITERAL:
				sequence_Literal(context, (Literal) semanticObject); 
				return; 
			case JPAQLDslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case JPAQLDslPackage.NAMED_QUERY:
				sequence_NamedQuery(context, (NamedQuery) semanticObject); 
				return; 
			case JPAQLDslPackage.NULL_COMPARISON_EXPRESSION:
				sequence_NullComparisonExpression(context, (NullComparisonExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.NUMERIC_LITERAL:
				sequence_NumericLiteral(context, (NumericLiteral) semanticObject); 
				return; 
			case JPAQLDslPackage.PATTERN_VALUE:
				sequence_PatternValue(context, (PatternValue) semanticObject); 
				return; 
			case JPAQLDslPackage.QL_STATEMENT:
				sequence_QLStatement(context, (QLStatement) semanticObject); 
				return; 
			case JPAQLDslPackage.RANGE_VARIABLE_DECLARATION:
				sequence_RangeVariableDeclaration(context, (RangeVariableDeclaration) semanticObject); 
				return; 
			case JPAQLDslPackage.SELECT_CLAUSE:
				sequence_SelectClause(context, (SelectClause) semanticObject); 
				return; 
			case JPAQLDslPackage.SELECT_EXPRESSION:
				sequence_SelectExpression(context, (SelectExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.SELECT_STATEMENT:
				sequence_SelectStatement(context, (SelectStatement) semanticObject); 
				return; 
			case JPAQLDslPackage.SIMPLE_ARITHMETIC_EXPRESSION:
				sequence_SimpleArithmeticExpression(context, (SimpleArithmeticExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.SIMPLE_CONDITIONAL_EXPRESSION:
				sequence_SimpleConditionalExpression(context, (SimpleConditionalExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.SIMPLE_ENTITY_EXPRESSION:
				sequence_SimpleEntityExpression(context, (SimpleEntityExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.SIMPLE_SELECT_CLAUSE:
				sequence_SimpleSelectClause(context, (SimpleSelectClause) semanticObject); 
				return; 
			case JPAQLDslPackage.SIMPLE_SELECT_EXPRESSION:
				sequence_SimpleSelectExpression(context, (SimpleSelectExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.STRING_EXPRESSION:
				sequence_StringExpression(context, (StringExpression) semanticObject); 
				return; 
			case JPAQLDslPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case JPAQLDslPackage.STRING_PRIMARY:
				sequence_StringPrimary(context, (StringPrimary) semanticObject); 
				return; 
			case JPAQLDslPackage.SUB_QUERY:
				sequence_SubQuery(context, (SubQuery) semanticObject); 
				return; 
			case JPAQLDslPackage.SUBQUERY_FROM_CLAUSE:
				sequence_SubqueryFromClause(context, (SubqueryFromClause) semanticObject); 
				return; 
			case JPAQLDslPackage.SUBSELECT_IDENTIFICATION_VARIABLE_DECLARATION:
				sequence_SubselectIdentificationVariableDeclaration(context, (SubselectIdentificationVariableDeclaration) semanticObject); 
				return; 
			case JPAQLDslPackage.TRIM_CHARACTER:
				sequence_TrimCharacter(context, (TrimCharacter) semanticObject); 
				return; 
			case JPAQLDslPackage.WHERE_CLAUSE:
				sequence_WhereClause(context, (WhereClause) semanticObject); 
				return; 
			}
		else if (epackage == TypesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TypesPackage.JVM_FORMAL_PARAMETER:
				if (rule == grammarAccess.getFullJvmFormalParameterRule()) {
					sequence_FullJvmFormalParameter(context, (JvmFormalParameter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmFormalParameterRule()) {
					sequence_JvmFormalParameter(context, (JvmFormalParameter) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_GENERIC_ARRAY_TYPE_REFERENCE:
				sequence_JvmTypeReference(context, (JvmGenericArrayTypeReference) semanticObject); 
				return; 
			case TypesPackage.JVM_INNER_TYPE_REFERENCE:
				sequence_JvmParameterizedTypeReference(context, (JvmInnerTypeReference) semanticObject); 
				return; 
			case TypesPackage.JVM_LOWER_BOUND:
				if (rule == grammarAccess.getJvmLowerBoundAndedRule()) {
					sequence_JvmLowerBoundAnded(context, (JvmLowerBound) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmLowerBoundRule()) {
					sequence_JvmLowerBound(context, (JvmLowerBound) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_PARAMETERIZED_TYPE_REFERENCE:
				if (action == grammarAccess.getJvmParameterizedTypeReferenceAccess().getJvmInnerTypeReferenceOuterAction_1_4_0_0_0()) {
					sequence_JvmParameterizedTypeReference_JvmInnerTypeReference_1_4_0_0_0(context, (JvmParameterizedTypeReference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmTypeReferenceRule()
						|| action == grammarAccess.getJvmTypeReferenceAccess().getJvmGenericArrayTypeReferenceComponentTypeAction_0_1_0_0()
						|| rule == grammarAccess.getJvmParameterizedTypeReferenceRule()
						|| rule == grammarAccess.getJvmArgumentTypeReferenceRule()) {
					sequence_JvmParameterizedTypeReference(context, (JvmParameterizedTypeReference) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_TYPE_PARAMETER:
				sequence_JvmTypeParameter(context, (JvmTypeParameter) semanticObject); 
				return; 
			case TypesPackage.JVM_UPPER_BOUND:
				if (rule == grammarAccess.getJvmUpperBoundAndedRule()) {
					sequence_JvmUpperBoundAnded(context, (JvmUpperBound) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmUpperBoundRule()) {
					sequence_JvmUpperBound(context, (JvmUpperBound) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_WILDCARD_TYPE_REFERENCE:
				sequence_JvmWildcardTypeReference(context, (JvmWildcardTypeReference) semanticObject); 
				return; 
			}
		else if (epackage == XbasePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XbasePackage.XASSIGNMENT:
				sequence_XAssignment_XMemberFeatureCall(context, (XAssignment) semanticObject); 
				return; 
			case XbasePackage.XBASIC_FOR_LOOP_EXPRESSION:
				sequence_XBasicForLoopExpression(context, (XBasicForLoopExpression) semanticObject); 
				return; 
			case XbasePackage.XBINARY_OPERATION:
				sequence_XAdditiveExpression_XAndExpression_XAssignment_XEqualityExpression_XMultiplicativeExpression_XOrExpression_XOtherOperatorExpression_XRelationalExpression(context, (XBinaryOperation) semanticObject); 
				return; 
			case XbasePackage.XBLOCK_EXPRESSION:
				if (rule == grammarAccess.getXExpressionRule()
						|| rule == grammarAccess.getXAssignmentRule()
						|| action == grammarAccess.getXAssignmentAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOrExpressionRule()
						|| action == grammarAccess.getXOrExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAndExpressionRule()
						|| action == grammarAccess.getXAndExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXEqualityExpressionRule()
						|| action == grammarAccess.getXEqualityExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXRelationalExpressionRule()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXInstanceOfExpressionExpressionAction_1_0_0_0_0()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOtherOperatorExpressionRule()
						|| action == grammarAccess.getXOtherOperatorExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAdditiveExpressionRule()
						|| action == grammarAccess.getXAdditiveExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXMultiplicativeExpressionRule()
						|| action == grammarAccess.getXMultiplicativeExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXUnaryOperationRule()
						|| rule == grammarAccess.getXCastedExpressionRule()
						|| action == grammarAccess.getXCastedExpressionAccess().getXCastedExpressionTargetAction_1_0_0_0()
						|| rule == grammarAccess.getXPostfixOperationRule()
						|| action == grammarAccess.getXPostfixOperationAccess().getXPostfixOperationOperandAction_1_0_0()
						|| rule == grammarAccess.getXMemberFeatureCallRule()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXAssignmentAssignableAction_1_0_0_0_0()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXMemberFeatureCallMemberCallTargetAction_1_1_0_0_0()
						|| rule == grammarAccess.getXPrimaryExpressionRule()
						|| rule == grammarAccess.getXParenthesizedExpressionRule()
						|| rule == grammarAccess.getXBlockExpressionRule()
						|| rule == grammarAccess.getXExpressionOrVarDeclarationRule()) {
					sequence_XBlockExpression(context, (XBlockExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getXExpressionInClosureRule()) {
					sequence_XExpressionInClosure(context, (XBlockExpression) semanticObject); 
					return; 
				}
				else break;
			case XbasePackage.XBOOLEAN_LITERAL:
				sequence_XBooleanLiteral(context, (XBooleanLiteral) semanticObject); 
				return; 
			case XbasePackage.XCASE_PART:
				sequence_XCasePart(context, (XCasePart) semanticObject); 
				return; 
			case XbasePackage.XCASTED_EXPRESSION:
				sequence_XCastedExpression(context, (XCastedExpression) semanticObject); 
				return; 
			case XbasePackage.XCATCH_CLAUSE:
				sequence_XCatchClause(context, (XCatchClause) semanticObject); 
				return; 
			case XbasePackage.XCLOSURE:
				if (rule == grammarAccess.getXExpressionRule()
						|| rule == grammarAccess.getXAssignmentRule()
						|| action == grammarAccess.getXAssignmentAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOrExpressionRule()
						|| action == grammarAccess.getXOrExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAndExpressionRule()
						|| action == grammarAccess.getXAndExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXEqualityExpressionRule()
						|| action == grammarAccess.getXEqualityExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXRelationalExpressionRule()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXInstanceOfExpressionExpressionAction_1_0_0_0_0()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOtherOperatorExpressionRule()
						|| action == grammarAccess.getXOtherOperatorExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAdditiveExpressionRule()
						|| action == grammarAccess.getXAdditiveExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXMultiplicativeExpressionRule()
						|| action == grammarAccess.getXMultiplicativeExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXUnaryOperationRule()
						|| rule == grammarAccess.getXCastedExpressionRule()
						|| action == grammarAccess.getXCastedExpressionAccess().getXCastedExpressionTargetAction_1_0_0_0()
						|| rule == grammarAccess.getXPostfixOperationRule()
						|| action == grammarAccess.getXPostfixOperationAccess().getXPostfixOperationOperandAction_1_0_0()
						|| rule == grammarAccess.getXMemberFeatureCallRule()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXAssignmentAssignableAction_1_0_0_0_0()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXMemberFeatureCallMemberCallTargetAction_1_1_0_0_0()
						|| rule == grammarAccess.getXPrimaryExpressionRule()
						|| rule == grammarAccess.getXLiteralRule()
						|| rule == grammarAccess.getXClosureRule()
						|| rule == grammarAccess.getXParenthesizedExpressionRule()
						|| rule == grammarAccess.getXExpressionOrVarDeclarationRule()) {
					sequence_XClosure(context, (XClosure) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getXShortClosureRule()) {
					sequence_XShortClosure(context, (XClosure) semanticObject); 
					return; 
				}
				else break;
			case XbasePackage.XCONSTRUCTOR_CALL:
				sequence_XConstructorCall(context, (XConstructorCall) semanticObject); 
				return; 
			case XbasePackage.XDO_WHILE_EXPRESSION:
				sequence_XDoWhileExpression(context, (XDoWhileExpression) semanticObject); 
				return; 
			case XbasePackage.XFEATURE_CALL:
				sequence_XFeatureCall(context, (XFeatureCall) semanticObject); 
				return; 
			case XbasePackage.XFOR_LOOP_EXPRESSION:
				sequence_XForLoopExpression(context, (XForLoopExpression) semanticObject); 
				return; 
			case XbasePackage.XIF_EXPRESSION:
				sequence_XIfExpression(context, (XIfExpression) semanticObject); 
				return; 
			case XbasePackage.XINSTANCE_OF_EXPRESSION:
				sequence_XRelationalExpression(context, (XInstanceOfExpression) semanticObject); 
				return; 
			case XbasePackage.XLIST_LITERAL:
				sequence_XListLiteral(context, (XListLiteral) semanticObject); 
				return; 
			case XbasePackage.XMEMBER_FEATURE_CALL:
				sequence_XMemberFeatureCall(context, (XMemberFeatureCall) semanticObject); 
				return; 
			case XbasePackage.XNULL_LITERAL:
				sequence_XNullLiteral(context, (XNullLiteral) semanticObject); 
				return; 
			case XbasePackage.XNUMBER_LITERAL:
				sequence_XNumberLiteral(context, (XNumberLiteral) semanticObject); 
				return; 
			case XbasePackage.XPOSTFIX_OPERATION:
				sequence_XPostfixOperation(context, (XPostfixOperation) semanticObject); 
				return; 
			case XbasePackage.XRETURN_EXPRESSION:
				sequence_XReturnExpression(context, (XReturnExpression) semanticObject); 
				return; 
			case XbasePackage.XSET_LITERAL:
				sequence_XSetLiteral(context, (XSetLiteral) semanticObject); 
				return; 
			case XbasePackage.XSTRING_LITERAL:
				sequence_XStringLiteral(context, (XStringLiteral) semanticObject); 
				return; 
			case XbasePackage.XSWITCH_EXPRESSION:
				sequence_XSwitchExpression(context, (XSwitchExpression) semanticObject); 
				return; 
			case XbasePackage.XSYNCHRONIZED_EXPRESSION:
				sequence_XSynchronizedExpression(context, (XSynchronizedExpression) semanticObject); 
				return; 
			case XbasePackage.XTHROW_EXPRESSION:
				sequence_XThrowExpression(context, (XThrowExpression) semanticObject); 
				return; 
			case XbasePackage.XTRY_CATCH_FINALLY_EXPRESSION:
				sequence_XTryCatchFinallyExpression(context, (XTryCatchFinallyExpression) semanticObject); 
				return; 
			case XbasePackage.XTYPE_LITERAL:
				sequence_XTypeLiteral(context, (XTypeLiteral) semanticObject); 
				return; 
			case XbasePackage.XUNARY_OPERATION:
				sequence_XUnaryOperation(context, (XUnaryOperation) semanticObject); 
				return; 
			case XbasePackage.XVARIABLE_DECLARATION:
				sequence_XVariableDeclaration(context, (XVariableDeclaration) semanticObject); 
				return; 
			case XbasePackage.XWHILE_EXPRESSION:
				sequence_XWhileExpression(context, (XWhileExpression) semanticObject); 
				return; 
			}
		else if (epackage == XtypePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XtypePackage.XFUNCTION_TYPE_REF:
				sequence_XFunctionTypeRef(context, (XFunctionTypeRef) semanticObject); 
				return; 
			case XtypePackage.XIMPORT_DECLARATION:
				sequence_XImportDeclaration(context, (XImportDeclaration) semanticObject); 
				return; 
			case XtypePackage.XIMPORT_SECTION:
				sequence_XImportSection(context, (XImportSection) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConstructorItem returns AggregateExpression
	 *     AggregateExpression returns AggregateExpression
	 *
	 * Constraint:
	 *     stateFieldPathExpression=JPAPathExpression
	 * </pre>
	 */
	protected void sequence_AggregateExpression(ISerializationContext context, AggregateExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.AGGREGATE_EXPRESSION__STATE_FIELD_PATH_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.AGGREGATE_EXPRESSION__STATE_FIELD_PATH_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAggregateExpressionAccess().getStateFieldPathExpressionJPAPathExpressionParserRuleCall_2_0(), semanticObject.getStateFieldPathExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AllOrAnyExpression returns AllOrAnyExpression
	 *
	 * Constraint:
	 *     subQuery=SubQuery
	 * </pre>
	 */
	protected void sequence_AllOrAnyExpression(ISerializationContext context, AllOrAnyExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.ALL_OR_ANY_EXPRESSION__SUB_QUERY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.ALL_OR_ANY_EXPRESSION__SUB_QUERY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAllOrAnyExpressionAccess().getSubQuerySubQueryParserRuleCall_2_0(), semanticObject.getSubQuery());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ArithmeticExpression returns ArithmeticExpression
	 *
	 * Constraint:
	 *     (simpleArithmeticExpression=SimpleArithmeticExpression | subQuery=SubQuery)
	 * </pre>
	 */
	protected void sequence_ArithmeticExpression(ISerializationContext context, ArithmeticExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleArithmeticExpression.SimpleArithmeticExpression_1_1_0 returns Expression
	 *     ArithmeticTerm returns Expression
	 *
	 * Constraint:
	 *     (arithmeticFactor=ArithmeticFactor | arithmeticPrimary=ArithmeticPrimary)
	 * </pre>
	 */
	protected void sequence_ArithmeticFactor_ArithmeticTerm(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleArithmeticExpression returns Expression
	 *
	 * Constraint:
	 *     (arithmeticTerm=ArithmeticTerm | arithmeticFactor=ArithmeticFactor | arithmeticPrimary=ArithmeticPrimary)
	 * </pre>
	 */
	protected void sequence_ArithmeticFactor_ArithmeticTerm_SimpleArithmeticExpression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ArithmeticTerm.ArithmeticTerm_1_1_0 returns Expression
	 *     ArithmeticFactor returns Expression
	 *
	 * Constraint:
	 *     arithmeticPrimary=ArithmeticPrimary
	 * </pre>
	 */
	protected void sequence_ArithmeticFactor(ISerializationContext context, Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.EXPRESSION__ARITHMETIC_PRIMARY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.EXPRESSION__ARITHMETIC_PRIMARY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArithmeticFactorAccess().getArithmeticPrimaryArithmeticPrimaryParserRuleCall_1_0(), semanticObject.getArithmeticPrimary());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ArithmeticPrimary returns ArithmeticPrimary
	 *
	 * Constraint:
	 *     (
	 *         pathExpression=JPAPathExpression | 
	 *         numericLiteral=NumericLiteral | 
	 *         simpleArithmeticExpression=SimpleArithmeticExpression | 
	 *         inputParameter=InputParameter | 
	 *         functionsReturningNumerics=FunctionsReturningNumerics | 
	 *         aggregateExpression=AggregateExpression
	 *     )
	 * </pre>
	 */
	protected void sequence_ArithmeticPrimary(ISerializationContext context, ArithmeticPrimary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleArithmeticExpression returns ArithmeticTerm
	 *     SimpleArithmeticExpression.SimpleArithmeticExpression_1_1_0 returns ArithmeticTerm
	 *     ArithmeticTerm returns ArithmeticTerm
	 *     ArithmeticTerm.ArithmeticTerm_1_1_0 returns ArithmeticTerm
	 *
	 * Constraint:
	 *     (left=ArithmeticTerm_ArithmeticTerm_1_1_0 right=ArithmeticFactor)
	 * </pre>
	 */
	protected void sequence_ArithmeticTerm(ISerializationContext context, ArithmeticTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArithmeticTermAccess().getArithmeticTermLeftAction_1_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getArithmeticTermAccess().getRightArithmeticFactorParserRuleCall_1_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BetweenExpression returns BetweenExpression
	 *
	 * Constraint:
	 *     (
	 *         (primaryArithmeticExpression=ArithmeticExpression lowerArithmeticExpression=ArithmeticExpression upperArithmeticExpression=ArithmeticExpression) | 
	 *         (primaryStringExpression=StringExpression lowerStringExpression=StringExpression upperStringExpression=StringExpression) | 
	 *         (primaryDateTimeExpression=DateTimeExpression lowerDateTimeExpression=DateTimeExpression upperDateTimeExpression=DateTimeExpression)
	 *     )
	 * </pre>
	 */
	protected void sequence_BetweenExpression(ISerializationContext context, BetweenExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BooleanExpression returns BooleanExpression
	 *
	 * Constraint:
	 *     (booleanPrimary=BooleanPrimary | subQuery=SubQuery)
	 * </pre>
	 */
	protected void sequence_BooleanExpression(ISerializationContext context, BooleanExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BooleanPrimary returns BooleanPrimary
	 *
	 * Constraint:
	 *     (pathExpression=JPAPathExpression | booleanLiteral=BooleanLiteral | inputParameter=InputParameter)
	 * </pre>
	 */
	protected void sequence_BooleanPrimary(ISerializationContext context, BooleanPrimary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CollectionMemberDeclaration returns CollectionMemberDeclaration
	 *
	 * Constraint:
	 *     (collectionValuedPathExpression=JPAPathExpression identificationVariable=IdentificationVariable)
	 * </pre>
	 */
	protected void sequence_CollectionMemberDeclaration(ISerializationContext context, CollectionMemberDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.COLLECTION_MEMBER_DECLARATION__COLLECTION_VALUED_PATH_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.COLLECTION_MEMBER_DECLARATION__COLLECTION_VALUED_PATH_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.COLLECTION_MEMBER_DECLARATION__IDENTIFICATION_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.COLLECTION_MEMBER_DECLARATION__IDENTIFICATION_VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCollectionMemberDeclarationAccess().getCollectionValuedPathExpressionJPAPathExpressionParserRuleCall_1_0(), semanticObject.getCollectionValuedPathExpression());
		feeder.accept(grammarAccess.getCollectionMemberDeclarationAccess().getIdentificationVariableIdentificationVariableParserRuleCall_3_0(), semanticObject.getIdentificationVariable());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CollectionMemberExpression returns CollectionMemberExpression
	 *
	 * Constraint:
	 *     (entityExpression=EntityExpression pathExpression=JPAPathExpression)
	 * </pre>
	 */
	protected void sequence_CollectionMemberExpression(ISerializationContext context, CollectionMemberExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.COLLECTION_MEMBER_EXPRESSION__ENTITY_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.COLLECTION_MEMBER_EXPRESSION__ENTITY_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.COLLECTION_MEMBER_EXPRESSION__PATH_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.COLLECTION_MEMBER_EXPRESSION__PATH_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCollectionMemberExpressionAccess().getEntityExpressionEntityExpressionParserRuleCall_0_0(), semanticObject.getEntityExpression());
		feeder.accept(grammarAccess.getCollectionMemberExpressionAccess().getPathExpressionJPAPathExpressionParserRuleCall_4_0(), semanticObject.getPathExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ComparisonExpression returns ComparisonExpression
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             primaryStringExpression=StringExpression 
	 *             comparisonOperator=ComparisonOperator 
	 *             (secondaryStringExpression=StringExpression | allOrAnyExpression=AllOrAnyExpression)
	 *         ) | 
	 *         (primaryBooleanExpression=BooleanExpression (secondaryBooleanExpression=BooleanExpression | allOrAnyExpression=AllOrAnyExpression)) | 
	 *         (primaryEnumExpression=EnumExpression (secondaryEnumExpression=EnumExpression | allOrAnyExpression=AllOrAnyExpression)) | 
	 *         (
	 *             primaryDatetimeExpression=DateTimeExpression 
	 *             comparisonOperator=ComparisonOperator 
	 *             (secondaryDatetimeExpression=DateTimeExpression | allOrAnyExpression=AllOrAnyExpression)
	 *         ) | 
	 *         (primaryEntityExpression=EntityExpression (secondaryEntityExpression=EntityExpression | allOrAnyExpression=AllOrAnyExpression)) | 
	 *         (
	 *             primaryArithmeticExpression=ArithmeticExpression 
	 *             comparisonOperator=ComparisonOperator 
	 *             (secondaryArithmeticExpression=ArithmeticExpression | allOrAnyExpression=AllOrAnyExpression)
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_ComparisonExpression(ISerializationContext context, ComparisonExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConditionalExpression returns ConditionalExpression
	 *     ConditionalExpression.ConditionalExpression_1_0 returns ConditionalExpression
	 *
	 * Constraint:
	 *     (left=ConditionalExpression_ConditionalExpression_1_0 right=ConditionalTerm)
	 * </pre>
	 */
	protected void sequence_ConditionalExpression(ISerializationContext context, ConditionalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getConditionalExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getRightConditionalTermParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConditionalExpression returns Expression
	 *     ConditionalExpression.ConditionalExpression_1_0 returns Expression
	 *     ConditionalTerm returns Expression
	 *     ConditionalTerm.ConditionalTerm_1_0 returns Expression
	 *     ConditionalFactor returns Expression
	 *
	 * Constraint:
	 *     (conditionalPrimary=SimpleConditionalExpression | conditionalExpression=ConditionalExpression)
	 * </pre>
	 */
	protected void sequence_ConditionalFactor(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConditionalExpression returns ConditionalTerm
	 *     ConditionalExpression.ConditionalExpression_1_0 returns ConditionalTerm
	 *     ConditionalTerm returns ConditionalTerm
	 *     ConditionalTerm.ConditionalTerm_1_0 returns ConditionalTerm
	 *
	 * Constraint:
	 *     (left=ConditionalTerm_ConditionalTerm_1_0 right=ConditionalFactor)
	 * </pre>
	 */
	protected void sequence_ConditionalTerm(ISerializationContext context, ConditionalTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalTermAccess().getConditionalTermLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConditionalTermAccess().getRightConditionalFactorParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConstructorExpression returns ConstructorExpression
	 *
	 * Constraint:
	 *     (constructorName=ConstructorName constructorItems+=ConstructorItem constructorItems+=ConstructorItem*)
	 * </pre>
	 */
	protected void sequence_ConstructorExpression(ISerializationContext context, ConstructorExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConstructorName returns ConstructorName
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_ConstructorName(ISerializationContext context, ConstructorName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.CONSTRUCTOR_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.CONSTRUCTOR_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstructorNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DateTimeExpression returns DateTimeExpression
	 *
	 * Constraint:
	 *     (dateTimePrimary=DateTimePrimary | subQuery=SubQuery)
	 * </pre>
	 */
	protected void sequence_DateTimeExpression(ISerializationContext context, DateTimeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DateTimePrimary returns DateTimePrimary
	 *
	 * Constraint:
	 *     (
	 *         pathExpression=JPAPathExpression | 
	 *         inputParameter=InputParameter | 
	 *         functionsReturningDateTime=FunctionsReturningDateTime | 
	 *         aggregateExpression=AggregateExpression
	 *     )
	 * </pre>
	 */
	protected void sequence_DateTimePrimary(ISerializationContext context, DateTimePrimary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EmptyCollectionComparisonExpression returns EmptyCollectionComparisonExpression
	 *
	 * Constraint:
	 *     pathExpression=JPAPathExpression
	 * </pre>
	 */
	protected void sequence_EmptyCollectionComparisonExpression(ISerializationContext context, EmptyCollectionComparisonExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.EMPTY_COLLECTION_COMPARISON_EXPRESSION__PATH_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.EMPTY_COLLECTION_COMPARISON_EXPRESSION__PATH_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEmptyCollectionComparisonExpressionAccess().getPathExpressionJPAPathExpressionParserRuleCall_0_0(), semanticObject.getPathExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EntityExpression returns EntityExpression
	 *
	 * Constraint:
	 *     (pathExpression=JPAPathExpression | simpleEntityExpression=SimpleEntityExpression)
	 * </pre>
	 */
	protected void sequence_EntityExpression(ISerializationContext context, EntityExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EnumExpression returns EnumExpression
	 *
	 * Constraint:
	 *     (enumPrimary=EnumPrimary | subQuery=SubQuery)
	 * </pre>
	 */
	protected void sequence_EnumExpression(ISerializationContext context, EnumExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EnumLiteral returns EnumLiteral
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_EnumLiteral(ISerializationContext context, EnumLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.ENUM_LITERAL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.ENUM_LITERAL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumLiteralAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EnumPrimary returns EnumPrimary
	 *
	 * Constraint:
	 *     (pathExpression=JPAPathExpression | enumLiteral=EnumLiteral | inputParameter=InputParameter)
	 * </pre>
	 */
	protected void sequence_EnumPrimary(ISerializationContext context, EnumPrimary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EscapeCharacter returns EscapeCharacter
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_EscapeCharacter(ISerializationContext context, EscapeCharacter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.ESCAPE_CHARACTER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.ESCAPE_CHARACTER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEscapeCharacterAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExistsExpression returns ExistsExpression
	 *
	 * Constraint:
	 *     subQuery=SubQuery
	 * </pre>
	 */
	protected void sequence_ExistsExpression(ISerializationContext context, ExistsExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.EXISTS_EXPRESSION__SUB_QUERY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.EXISTS_EXPRESSION__SUB_QUERY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExistsExpressionAccess().getSubQuerySubQueryParserRuleCall_3_0(), semanticObject.getSubQuery());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FetchJoin returns FetchJoin
	 *
	 * Constraint:
	 *     (joinSpec=JoinSpec joinAssociationPathExpression=JPAPathExpression identificationVariable=IdentificationVariable)
	 * </pre>
	 */
	protected void sequence_FetchJoin(ISerializationContext context, FetchJoin semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.FETCH_JOIN__JOIN_SPEC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.FETCH_JOIN__JOIN_SPEC));
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.FETCH_JOIN__JOIN_ASSOCIATION_PATH_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.FETCH_JOIN__JOIN_ASSOCIATION_PATH_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.FETCH_JOIN__IDENTIFICATION_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.FETCH_JOIN__IDENTIFICATION_VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFetchJoinAccess().getJoinSpecJoinSpecParserRuleCall_0_0(), semanticObject.getJoinSpec());
		feeder.accept(grammarAccess.getFetchJoinAccess().getJoinAssociationPathExpressionJPAPathExpressionParserRuleCall_2_0(), semanticObject.getJoinAssociationPathExpression());
		feeder.accept(grammarAccess.getFetchJoinAccess().getIdentificationVariableIdentificationVariableParserRuleCall_4_0(), semanticObject.getIdentificationVariable());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FromClause returns FromClause
	 *
	 * Constraint:
	 *     (
	 *         identificationVariableDeclarations+=IdentificationVariableDeclaration 
	 *         (identificationVariableDeclarations+=IdentificationVariableDeclaration | identificationVariableDeclarations+=CollectionMemberDeclaration)*
	 *     )
	 * </pre>
	 */
	protected void sequence_FromClause(ISerializationContext context, FromClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionsReturningNumerics returns FunctionsReturningNumerics
	 *
	 * Constraint:
	 *     (
	 *         stringPrimary=StringPrimary | 
	 *         (stringPrimary=StringPrimary stringSecondary=StringPrimary simpleArithmeticExpression=SimpleArithmeticExpression?) | 
	 *         simpleArithmeticExpression=SimpleArithmeticExpression | 
	 *         simpleArithmeticExpression=SimpleArithmeticExpression | 
	 *         (primarySimpleArithmeticExpression=SimpleArithmeticExpression secondarySimpleArithmeticExpression=SimpleArithmeticExpression) | 
	 *         pathExpression=JPAPathExpression
	 *     )
	 * </pre>
	 */
	protected void sequence_FunctionsReturningNumerics(ISerializationContext context, FunctionsReturningNumerics semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionsReturningStrings returns FunctionsReturningStrings
	 *
	 * Constraint:
	 *     (
	 *         (primaryStringPrimary=StringPrimary secondaryStringPrimary=StringPrimary) | 
	 *         (
	 *             stringPrimary=StringPrimary 
	 *             primarySimpleArithmeticExpression=SimpleArithmeticExpression 
	 *             secondarySimpleArithmeticExpression=SimpleArithmeticExpression
	 *         ) | 
	 *         (trimSpecification=TrimSpecification? trimCharacter=TrimCharacter? stringPrimary=StringPrimary) | 
	 *         stringPrimary=StringPrimary | 
	 *         stringPrimary=StringPrimary
	 *     )
	 * </pre>
	 */
	protected void sequence_FunctionsReturningStrings(ISerializationContext context, FunctionsReturningStrings semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IdentificationVariableDeclaration returns IdentificationVariableDeclaration
	 *
	 * Constraint:
	 *     (rangeVariableDeclaration=RangeVariableDeclaration (joins+=Join | joins+=FetchJoin)*)
	 * </pre>
	 */
	protected void sequence_IdentificationVariableDeclaration(ISerializationContext context, IdentificationVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IdentificationVariable returns IdentificationVariable
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_IdentificationVariable(ISerializationContext context, IdentificationVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.IDENTIFICATION_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.IDENTIFICATION_VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIdentificationVariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=ImportNameSpace
	 * </pre>
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceImportNameSpaceParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InExpression returns InExpression
	 *
	 * Constraint:
	 *     ((pathExpression=JPAPathExpression inItems+=InItem inItems+=InItem*) | subQuery=SubQuery)
	 * </pre>
	 */
	protected void sequence_InExpression(ISerializationContext context, InExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InItem returns InItem
	 *
	 * Constraint:
	 *     (literal=Literal | inputParameter=InputParameter)
	 * </pre>
	 */
	protected void sequence_InItem(ISerializationContext context, InItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InputParameter returns InputParameter
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_InputParameter(ISerializationContext context, InputParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.INPUT_PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.INPUT_PARAMETER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     JPAPathExpression returns JPAPathExpression
	 *     ConstructorItem returns JPAPathExpression
	 *
	 * Constraint:
	 *     (root=[IdentificationVariable|ID] jpaAttributes+=JpaAttribute*)
	 * </pre>
	 */
	protected void sequence_JPAPathExpression(ISerializationContext context, JPAPathExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Join returns Join
	 *
	 * Constraint:
	 *     (joinSpec=JoinSpec joinAssociationPathExpression=JPAPathExpression identificationVariable=IdentificationVariable)
	 * </pre>
	 */
	protected void sequence_Join(ISerializationContext context, Join semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.JOIN__JOIN_SPEC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.JOIN__JOIN_SPEC));
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.JOIN__JOIN_ASSOCIATION_PATH_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.JOIN__JOIN_ASSOCIATION_PATH_EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.JOIN__IDENTIFICATION_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.JOIN__IDENTIFICATION_VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJoinAccess().getJoinSpecJoinSpecParserRuleCall_0_0(), semanticObject.getJoinSpec());
		feeder.accept(grammarAccess.getJoinAccess().getJoinAssociationPathExpressionJPAPathExpressionParserRuleCall_1_0(), semanticObject.getJoinAssociationPathExpression());
		feeder.accept(grammarAccess.getJoinAccess().getIdentificationVariableIdentificationVariableParserRuleCall_3_0(), semanticObject.getIdentificationVariable());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     JpaAttribute returns JpaAttribute
	 *
	 * Constraint:
	 *     attribute=[Attribute|ID]
	 * </pre>
	 */
	protected void sequence_JpaAttribute(ISerializationContext context, JpaAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.JPA_ATTRIBUTE__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.JPA_ATTRIBUTE__ATTRIBUTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJpaAttributeAccess().getAttributeAttributeIDTerminalRuleCall_0_1(), semanticObject.eGet(JPAQLDslPackage.Literals.JPA_ATTRIBUTE__ATTRIBUTE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LikeExpression returns LikeExpression
	 *
	 * Constraint:
	 *     (stringExpression=StringExpression patternValue=PatternValue escapeCharacter=EscapeCharacter?)
	 * </pre>
	 */
	protected void sequence_LikeExpression(ISerializationContext context, LikeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Literal returns Literal
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Literal(ISerializationContext context, Literal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.LITERAL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.LITERAL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (xmlDescriptor=XMLDescriptor imports+=Import* name=QualifiedName namedQueries+=NamedQuery*)
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NamedQuery returns NamedQuery
	 *
	 * Constraint:
	 *     (name=ID qlStatement=QLStatement)
	 * </pre>
	 */
	protected void sequence_NamedQuery(ISerializationContext context, NamedQuery semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.NAMED_QUERY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.NAMED_QUERY__NAME));
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.NAMED_QUERY__QL_STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.NAMED_QUERY__QL_STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNamedQueryAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNamedQueryAccess().getQlStatementQLStatementParserRuleCall_4_0(), semanticObject.getQlStatement());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NullComparisonExpression returns NullComparisonExpression
	 *
	 * Constraint:
	 *     (pathExpression=JPAPathExpression | inputParameter=InputParameter)
	 * </pre>
	 */
	protected void sequence_NullComparisonExpression(ISerializationContext context, NullComparisonExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NumericLiteral returns NumericLiteral
	 *
	 * Constraint:
	 *     literal=INT
	 * </pre>
	 */
	protected void sequence_NumericLiteral(ISerializationContext context, NumericLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.NUMERIC_LITERAL__LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.NUMERIC_LITERAL__LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumericLiteralAccess().getLiteralINTTerminalRuleCall_0(), semanticObject.getLiteral());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PatternValue returns PatternValue
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_PatternValue(ISerializationContext context, PatternValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.PATTERN_VALUE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.PATTERN_VALUE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternValueAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     QLStatement returns QLStatement
	 *
	 * Constraint:
	 *     selectStatements+=SelectStatement+
	 * </pre>
	 */
	protected void sequence_QLStatement(ISerializationContext context, QLStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RangeVariableDeclaration returns RangeVariableDeclaration
	 *
	 * Constraint:
	 *     (abstractSchemaName=[Entity|ID] identificationVariable=IdentificationVariable)
	 * </pre>
	 */
	protected void sequence_RangeVariableDeclaration(ISerializationContext context, RangeVariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.RANGE_VARIABLE_DECLARATION__ABSTRACT_SCHEMA_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.RANGE_VARIABLE_DECLARATION__ABSTRACT_SCHEMA_NAME));
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.RANGE_VARIABLE_DECLARATION__IDENTIFICATION_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.RANGE_VARIABLE_DECLARATION__IDENTIFICATION_VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRangeVariableDeclarationAccess().getAbstractSchemaNameEntityIDTerminalRuleCall_0_0_1(), semanticObject.eGet(JPAQLDslPackage.Literals.RANGE_VARIABLE_DECLARATION__ABSTRACT_SCHEMA_NAME, false));
		feeder.accept(grammarAccess.getRangeVariableDeclarationAccess().getIdentificationVariableIdentificationVariableParserRuleCall_2_0(), semanticObject.getIdentificationVariable());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SelectClause returns SelectClause
	 *
	 * Constraint:
	 *     (selectExpressions+=SelectExpression selectExpressions+=SelectExpression*)
	 * </pre>
	 */
	protected void sequence_SelectClause(ISerializationContext context, SelectClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SelectExpression returns SelectExpression
	 *
	 * Constraint:
	 *     (jpaPathExpression=JPAPathExpression | aggregateExpression=AggregateExpression | constructorExpression=ConstructorExpression)
	 * </pre>
	 */
	protected void sequence_SelectExpression(ISerializationContext context, SelectExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SelectStatement returns SelectStatement
	 *
	 * Constraint:
	 *     (selectClause=SelectClause fromClause=FromClause whereClause=WhereClause?)
	 * </pre>
	 */
	protected void sequence_SelectStatement(ISerializationContext context, SelectStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleArithmeticExpression returns SimpleArithmeticExpression
	 *     SimpleArithmeticExpression.SimpleArithmeticExpression_1_1_0 returns SimpleArithmeticExpression
	 *
	 * Constraint:
	 *     (left=SimpleArithmeticExpression_SimpleArithmeticExpression_1_1_0 right=ArithmeticTerm)
	 * </pre>
	 */
	protected void sequence_SimpleArithmeticExpression(ISerializationContext context, SimpleArithmeticExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleArithmeticExpressionAccess().getSimpleArithmeticExpressionLeftAction_1_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSimpleArithmeticExpressionAccess().getRightArithmeticTermParserRuleCall_1_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleConditionalExpression returns SimpleConditionalExpression
	 *
	 * Constraint:
	 *     (
	 *         comparisionExpression=ComparisonExpression | 
	 *         betweenExpression=BetweenExpression | 
	 *         likeExpression=LikeExpression | 
	 *         inExpression=InExpression | 
	 *         nullComparisionExpression=NullComparisonExpression | 
	 *         emptyCollectionComparisonExpression=EmptyCollectionComparisonExpression | 
	 *         collectionMemberExpression=CollectionMemberExpression | 
	 *         existsExpression=ExistsExpression
	 *     )
	 * </pre>
	 */
	protected void sequence_SimpleConditionalExpression(ISerializationContext context, SimpleConditionalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleEntityExpression returns SimpleEntityExpression
	 *
	 * Constraint:
	 *     (identificationVariable=IdentificationVariable | inputParameter=InputParameter)
	 * </pre>
	 */
	protected void sequence_SimpleEntityExpression(ISerializationContext context, SimpleEntityExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleSelectClause returns SimpleSelectClause
	 *
	 * Constraint:
	 *     simpleSelectExpression=SimpleSelectExpression
	 * </pre>
	 */
	protected void sequence_SimpleSelectClause(ISerializationContext context, SimpleSelectClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.SIMPLE_SELECT_CLAUSE__SIMPLE_SELECT_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.SIMPLE_SELECT_CLAUSE__SIMPLE_SELECT_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleSelectClauseAccess().getSimpleSelectExpressionSimpleSelectExpressionParserRuleCall_2_0(), semanticObject.getSimpleSelectExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleSelectExpression returns SimpleSelectExpression
	 *
	 * Constraint:
	 *     (pathExpression=JPAPathExpression | aggregateExpression=AggregateExpression | identificationVariable=IdentificationVariable)
	 * </pre>
	 */
	protected void sequence_SimpleSelectExpression(ISerializationContext context, SimpleSelectExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StringExpression returns StringExpression
	 *
	 * Constraint:
	 *     (stringPrimary=StringPrimary | subQuery=SubQuery)
	 * </pre>
	 */
	protected void sequence_StringExpression(ISerializationContext context, StringExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     literal=ID
	 * </pre>
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.STRING_LITERAL__LITERAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.STRING_LITERAL__LITERAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getLiteralIDTerminalRuleCall_1_0(), semanticObject.getLiteral());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StringPrimary returns StringPrimary
	 *
	 * Constraint:
	 *     (
	 *         pathExpression=JPAPathExpression | 
	 *         stringLiteral=StringLiteral | 
	 *         inputParamater=InputParameter | 
	 *         functionsReturningStrings=FunctionsReturningStrings | 
	 *         aggregateExpression=AggregateExpression
	 *     )
	 * </pre>
	 */
	protected void sequence_StringPrimary(ISerializationContext context, StringPrimary semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SubQuery returns SubQuery
	 *
	 * Constraint:
	 *     (simpleSelectClause=SimpleSelectClause subqueryFromClause=SubqueryFromClause whereClause=WhereClause?)
	 * </pre>
	 */
	protected void sequence_SubQuery(ISerializationContext context, SubQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SubqueryFromClause returns SubqueryFromClause
	 *
	 * Constraint:
	 *     (
	 *         subselectIdentificationVariableDeclaration+=SubselectIdentificationVariableDeclaration 
	 *         subselectIdentificationVariableDeclaration+=SubselectIdentificationVariableDeclaration*
	 *     )
	 * </pre>
	 */
	protected void sequence_SubqueryFromClause(ISerializationContext context, SubqueryFromClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SubselectIdentificationVariableDeclaration returns SubselectIdentificationVariableDeclaration
	 *
	 * Constraint:
	 *     (
	 *         identificationVariableDecalaration=IdentificationVariableDeclaration | 
	 *         (associationPathExpression=JPAPathExpression identificationVariable=IdentificationVariable) | 
	 *         collectionMemberDeclaration=CollectionMemberDeclaration
	 *     )
	 * </pre>
	 */
	protected void sequence_SubselectIdentificationVariableDeclaration(ISerializationContext context, SubselectIdentificationVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TrimCharacter returns TrimCharacter
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_TrimCharacter(ISerializationContext context, TrimCharacter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.TRIM_CHARACTER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.TRIM_CHARACTER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTrimCharacterAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     WhereClause returns WhereClause
	 *
	 * Constraint:
	 *     conditionalExpression=ConditionalExpression
	 * </pre>
	 */
	protected void sequence_WhereClause(ISerializationContext context, WhereClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, JPAQLDslPackage.Literals.WHERE_CLAUSE__CONDITIONAL_EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, JPAQLDslPackage.Literals.WHERE_CLAUSE__CONDITIONAL_EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhereClauseAccess().getConditionalExpressionConditionalExpressionParserRuleCall_1_0(), semanticObject.getConditionalExpression());
		feeder.finish();
	}
	
	
}

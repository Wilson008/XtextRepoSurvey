/*
 * generated by Xtext 2.35.0
 */
package www.ubx.ch.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import www.ubx.ch.openAir.AT;
import www.ubx.ch.openAir.Airspace;
import www.ubx.ch.openAir.AsClass;
import www.ubx.ch.openAir.AsName;
import www.ubx.ch.openAir.DA;
import www.ubx.ch.openAir.DB;
import www.ubx.ch.openAir.DC;
import www.ubx.ch.openAir.DP;
import www.ubx.ch.openAir.DaParams1;
import www.ubx.ch.openAir.DaParams2;
import www.ubx.ch.openAir.FL;
import www.ubx.ch.openAir.GND;
import www.ubx.ch.openAir.HighLimit;
import www.ubx.ch.openAir.LatDec;
import www.ubx.ch.openAir.LatDegr;
import www.ubx.ch.openAir.Limites;
import www.ubx.ch.openAir.LongDec;
import www.ubx.ch.openAir.LongDegr;
import www.ubx.ch.openAir.LowLimit;
import www.ubx.ch.openAir.MinDec;
import www.ubx.ch.openAir.MinSec;
import www.ubx.ch.openAir.Minus;
import www.ubx.ch.openAir.OpenAir;
import www.ubx.ch.openAir.OpenAirPackage;
import www.ubx.ch.openAir.Plus;
import www.ubx.ch.openAir.Point1;
import www.ubx.ch.openAir.Point2;
import www.ubx.ch.openAir.Point3;
import www.ubx.ch.openAir.Point4;
import www.ubx.ch.openAir.Radius;
import www.ubx.ch.openAir.SB;
import www.ubx.ch.openAir.SFC;
import www.ubx.ch.openAir.SP;
import www.ubx.ch.openAir.SecDec;
import www.ubx.ch.openAir.TheDef;
import www.ubx.ch.openAir.UNL;
import www.ubx.ch.openAir.V;
import www.ubx.ch.openAir.VAL;
import www.ubx.ch.openAir.Vsub;
import www.ubx.ch.services.OpenAirGrammarAccess;

@SuppressWarnings("all")
public class OpenAirSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private OpenAirGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == OpenAirPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case OpenAirPackage.AT:
				sequence_AT(context, (AT) semanticObject); 
				return; 
			case OpenAirPackage.AIRSPACE:
				sequence_Airspace(context, (Airspace) semanticObject); 
				return; 
			case OpenAirPackage.AS_CLASS:
				sequence_AsClass(context, (AsClass) semanticObject); 
				return; 
			case OpenAirPackage.AS_NAME:
				sequence_AsName(context, (AsName) semanticObject); 
				return; 
			case OpenAirPackage.DA:
				sequence_DA(context, (DA) semanticObject); 
				return; 
			case OpenAirPackage.DB:
				sequence_DB(context, (DB) semanticObject); 
				return; 
			case OpenAirPackage.DC:
				sequence_DC(context, (DC) semanticObject); 
				return; 
			case OpenAirPackage.DP:
				sequence_DP(context, (DP) semanticObject); 
				return; 
			case OpenAirPackage.DA_PARAMS1:
				sequence_DaParams1(context, (DaParams1) semanticObject); 
				return; 
			case OpenAirPackage.DA_PARAMS2:
				sequence_DaParams2(context, (DaParams2) semanticObject); 
				return; 
			case OpenAirPackage.FL:
				sequence_FL(context, (FL) semanticObject); 
				return; 
			case OpenAirPackage.GND:
				sequence_GND(context, (GND) semanticObject); 
				return; 
			case OpenAirPackage.HIGH_LIMIT:
				sequence_HighLimit(context, (HighLimit) semanticObject); 
				return; 
			case OpenAirPackage.LAT_DEC:
				sequence_LatDec(context, (LatDec) semanticObject); 
				return; 
			case OpenAirPackage.LAT_DEGR:
				sequence_LatDegr(context, (LatDegr) semanticObject); 
				return; 
			case OpenAirPackage.LIMITES:
				sequence_Limites(context, (Limites) semanticObject); 
				return; 
			case OpenAirPackage.LONG_DEC:
				sequence_LongDec(context, (LongDec) semanticObject); 
				return; 
			case OpenAirPackage.LONG_DEGR:
				sequence_LongDegr(context, (LongDegr) semanticObject); 
				return; 
			case OpenAirPackage.LOW_LIMIT:
				sequence_LowLimit(context, (LowLimit) semanticObject); 
				return; 
			case OpenAirPackage.MIN_DEC:
				sequence_MinDec(context, (MinDec) semanticObject); 
				return; 
			case OpenAirPackage.MIN_SEC:
				sequence_MinSec(context, (MinSec) semanticObject); 
				return; 
			case OpenAirPackage.MINUS:
				sequence_Minus(context, (Minus) semanticObject); 
				return; 
			case OpenAirPackage.OPEN_AIR:
				sequence_OpenAir(context, (OpenAir) semanticObject); 
				return; 
			case OpenAirPackage.PLUS:
				sequence_Plus(context, (Plus) semanticObject); 
				return; 
			case OpenAirPackage.POINT1:
				sequence_Point1(context, (Point1) semanticObject); 
				return; 
			case OpenAirPackage.POINT2:
				sequence_Point2(context, (Point2) semanticObject); 
				return; 
			case OpenAirPackage.POINT3:
				sequence_Point3(context, (Point3) semanticObject); 
				return; 
			case OpenAirPackage.POINT4:
				sequence_Point4(context, (Point4) semanticObject); 
				return; 
			case OpenAirPackage.RADIUS:
				sequence_Radius(context, (Radius) semanticObject); 
				return; 
			case OpenAirPackage.SB:
				sequence_SB(context, (SB) semanticObject); 
				return; 
			case OpenAirPackage.SFC:
				sequence_SFC(context, (SFC) semanticObject); 
				return; 
			case OpenAirPackage.SP:
				sequence_SP(context, (SP) semanticObject); 
				return; 
			case OpenAirPackage.SEC_DEC:
				sequence_SecDec(context, (SecDec) semanticObject); 
				return; 
			case OpenAirPackage.THE_DEF:
				sequence_TheDef(context, (TheDef) semanticObject); 
				return; 
			case OpenAirPackage.UNL:
				sequence_UNL(context, (UNL) semanticObject); 
				return; 
			case OpenAirPackage.V:
				sequence_V(context, (V) semanticObject); 
				return; 
			case OpenAirPackage.VAL:
				sequence_VAL(context, (VAL) semanticObject); 
				return; 
			case OpenAirPackage.VSUB:
				sequence_Vsub(context, (Vsub) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     AT returns AT
	 *
	 * Constraint:
	 *     lp=Point
	 * </pre>
	 */
	protected void sequence_AT(ISerializationContext context, AT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.AT__LP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.AT__LP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getATAccess().getLpPointParserRuleCall_1_0(), semanticObject.getLp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Airspace returns Airspace
	 *
	 * Constraint:
	 *     (thedef=TheDef thegeom+=TheGeom*)
	 * </pre>
	 */
	protected void sequence_Airspace(ISerializationContext context, Airspace semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AsClass returns AsClass
	 *
	 * Constraint:
	 *     name=ClassType?
	 * </pre>
	 */
	protected void sequence_AsClass(ISerializationContext context, AsClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AsName returns AsName
	 *
	 * Constraint:
	 *     name=STRING
	 * </pre>
	 */
	protected void sequence_AsName(ISerializationContext context, AsName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.AS_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.AS_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAsNameAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TheGeom returns DA
	 *     DA returns DA
	 *
	 * Constraint:
	 *     da=DaParams
	 * </pre>
	 */
	protected void sequence_DA(ISerializationContext context, DA semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.DA__DA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.DA__DA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDAAccess().getDaDaParamsParserRuleCall_1_0(), semanticObject.getDa());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TheGeom returns DB
	 *     DB returns DB
	 *
	 * Constraint:
	 *     (dp0=Point dp1=Point)
	 * </pre>
	 */
	protected void sequence_DB(ISerializationContext context, DB semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.DB__DP0) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.DB__DP0));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.DB__DP1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.DB__DP1));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDBAccess().getDp0PointParserRuleCall_1_0(), semanticObject.getDp0());
		feeder.accept(grammarAccess.getDBAccess().getDp1PointParserRuleCall_3_0(), semanticObject.getDp1());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TheGeom returns DC
	 *     DC returns DC
	 *
	 * Constraint:
	 *     radius=Radius
	 * </pre>
	 */
	protected void sequence_DC(ISerializationContext context, DC semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.DC__RADIUS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.DC__RADIUS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDCAccess().getRadiusRadiusParserRuleCall_1_0(), semanticObject.getRadius());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TheGeom returns DP
	 *     DP returns DP
	 *
	 * Constraint:
	 *     dp=Point
	 * </pre>
	 */
	protected void sequence_DP(ISerializationContext context, DP semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.DP__DP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.DP__DP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDPAccess().getDpPointParserRuleCall_1_0(), semanticObject.getDp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DaParams returns DaParams1
	 *     DaParams1 returns DaParams1
	 *
	 * Constraint:
	 *     (radius=REAL angleStart=INT angleEnd=INT)
	 * </pre>
	 */
	protected void sequence_DaParams1(ISerializationContext context, DaParams1 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.DA_PARAMS1__RADIUS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.DA_PARAMS1__RADIUS));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.DA_PARAMS__ANGLE_START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.DA_PARAMS__ANGLE_START));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.DA_PARAMS__ANGLE_END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.DA_PARAMS__ANGLE_END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDaParams1Access().getRadiusREALTerminalRuleCall_0_0(), semanticObject.getRadius());
		feeder.accept(grammarAccess.getDaParams1Access().getAngleStartINTTerminalRuleCall_2_0(), semanticObject.getAngleStart());
		feeder.accept(grammarAccess.getDaParams1Access().getAngleEndINTTerminalRuleCall_4_0(), semanticObject.getAngleEnd());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DaParams returns DaParams2
	 *     DaParams2 returns DaParams2
	 *
	 * Constraint:
	 *     (radius=INT angleStart=INT angleEnd=INT)
	 * </pre>
	 */
	protected void sequence_DaParams2(ISerializationContext context, DaParams2 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.DA_PARAMS2__RADIUS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.DA_PARAMS2__RADIUS));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.DA_PARAMS__ANGLE_START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.DA_PARAMS__ANGLE_START));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.DA_PARAMS__ANGLE_END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.DA_PARAMS__ANGLE_END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDaParams2Access().getRadiusINTTerminalRuleCall_0_0(), semanticObject.getRadius());
		feeder.accept(grammarAccess.getDaParams2Access().getAngleStartINTTerminalRuleCall_2_0(), semanticObject.getAngleStart());
		feeder.accept(grammarAccess.getDaParams2Access().getAngleEndINTTerminalRuleCall_4_0(), semanticObject.getAngleEnd());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Limit returns FL
	 *     FL returns FL
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_FL(ISerializationContext context, FL semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.FL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.FL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFLAccess().getValueINTTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Limit returns GND
	 *     GND returns GND
	 *
	 * Constraint:
	 *     {GND}
	 * </pre>
	 */
	protected void sequence_GND(ISerializationContext context, GND semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     HighLimit returns HighLimit
	 *
	 * Constraint:
	 *     hl=Limit
	 * </pre>
	 */
	protected void sequence_HighLimit(ISerializationContext context, HighLimit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.HIGH_LIMIT__HL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.HIGH_LIMIT__HL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHighLimitAccess().getHlLimitParserRuleCall_1_0(), semanticObject.getHl());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LatDec returns LatDec
	 *
	 * Constraint:
	 *     value=REAL
	 * </pre>
	 */
	protected void sequence_LatDec(ISerializationContext context, LatDec semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.LAT_DEC__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.LAT_DEC__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLatDecAccess().getValueREALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LatDegr returns LatDegr
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_LatDegr(ISerializationContext context, LatDegr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.LAT_DEGR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.LAT_DEGR__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLatDegrAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Limites returns Limites
	 *
	 * Constraint:
	 *     ((lowLimit=LowLimit highLimit=HighLimit) | (heighLimit=HighLimit lowLimit=LowLimit))
	 * </pre>
	 */
	protected void sequence_Limites(ISerializationContext context, Limites semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LongDec returns LongDec
	 *
	 * Constraint:
	 *     value=REAL
	 * </pre>
	 */
	protected void sequence_LongDec(ISerializationContext context, LongDec semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.LONG_DEC__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.LONG_DEC__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLongDecAccess().getValueREALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LongDegr returns LongDegr
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_LongDegr(ISerializationContext context, LongDegr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.LONG_DEGR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.LONG_DEGR__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLongDegrAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LowLimit returns LowLimit
	 *
	 * Constraint:
	 *     ll=Limit
	 * </pre>
	 */
	protected void sequence_LowLimit(ISerializationContext context, LowLimit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.LOW_LIMIT__LL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.LOW_LIMIT__LL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLowLimitAccess().getLlLimitParserRuleCall_1_0(), semanticObject.getLl());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MinDec returns MinDec
	 *
	 * Constraint:
	 *     value=REAL
	 * </pre>
	 */
	protected void sequence_MinDec(ISerializationContext context, MinDec semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.MIN_DEC__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.MIN_DEC__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMinDecAccess().getValueREALTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MinSec returns MinSec
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_MinSec(ISerializationContext context, MinSec semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.MIN_SEC__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.MIN_SEC__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMinSecAccess().getValueINTTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Dir returns Minus
	 *     Minus returns Minus
	 *
	 * Constraint:
	 *     {Minus}
	 * </pre>
	 */
	protected void sequence_Minus(ISerializationContext context, Minus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OpenAir returns OpenAir
	 *
	 * Constraint:
	 *     airspaces+=Airspace+
	 * </pre>
	 */
	protected void sequence_OpenAir(ISerializationContext context, OpenAir semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Dir returns Plus
	 *     Plus returns Plus
	 *
	 * Constraint:
	 *     {Plus}
	 * </pre>
	 */
	protected void sequence_Plus(ISerializationContext context, Plus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Point returns Point1
	 *     Point1 returns Point1
	 *
	 * Constraint:
	 *     (
	 *         longD=LongDegr 
	 *         longM=MinSec 
	 *         longS=MinSec 
	 *         ns=NS 
	 *         latD=LatDegr 
	 *         latM=MinSec 
	 *         latS=MinSec 
	 *         we=WE
	 *     )
	 * </pre>
	 */
	protected void sequence_Point1(ISerializationContext context, Point1 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT1__LONG_D) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT1__LONG_D));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT1__LONG_M) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT1__LONG_M));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT1__LONG_S) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT1__LONG_S));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT__NS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT__NS));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT1__LAT_D) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT1__LAT_D));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT1__LAT_M) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT1__LAT_M));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT1__LAT_S) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT1__LAT_S));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT__WE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT__WE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPoint1Access().getLongDLongDegrParserRuleCall_0_0(), semanticObject.getLongD());
		feeder.accept(grammarAccess.getPoint1Access().getLongMMinSecParserRuleCall_1_0(), semanticObject.getLongM());
		feeder.accept(grammarAccess.getPoint1Access().getLongSMinSecParserRuleCall_2_0(), semanticObject.getLongS());
		feeder.accept(grammarAccess.getPoint1Access().getNsNSEnumRuleCall_3_0(), semanticObject.getNs());
		feeder.accept(grammarAccess.getPoint1Access().getLatDLatDegrParserRuleCall_4_0(), semanticObject.getLatD());
		feeder.accept(grammarAccess.getPoint1Access().getLatMMinSecParserRuleCall_5_0(), semanticObject.getLatM());
		feeder.accept(grammarAccess.getPoint1Access().getLatSMinSecParserRuleCall_6_0(), semanticObject.getLatS());
		feeder.accept(grammarAccess.getPoint1Access().getWeWEEnumRuleCall_7_0(), semanticObject.getWe());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Point returns Point2
	 *     Point2 returns Point2
	 *
	 * Constraint:
	 *     (
	 *         longD=LongDegr 
	 *         longMf=MinDec 
	 *         ns=NS 
	 *         latD=LatDegr 
	 *         latMf=MinDec 
	 *         we=WE
	 *     )
	 * </pre>
	 */
	protected void sequence_Point2(ISerializationContext context, Point2 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT2__LONG_D) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT2__LONG_D));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT2__LONG_MF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT2__LONG_MF));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT__NS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT__NS));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT2__LAT_D) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT2__LAT_D));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT2__LAT_MF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT2__LAT_MF));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT__WE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT__WE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPoint2Access().getLongDLongDegrParserRuleCall_0_0(), semanticObject.getLongD());
		feeder.accept(grammarAccess.getPoint2Access().getLongMfMinDecParserRuleCall_1_0(), semanticObject.getLongMf());
		feeder.accept(grammarAccess.getPoint2Access().getNsNSEnumRuleCall_2_0(), semanticObject.getNs());
		feeder.accept(grammarAccess.getPoint2Access().getLatDLatDegrParserRuleCall_3_0(), semanticObject.getLatD());
		feeder.accept(grammarAccess.getPoint2Access().getLatMfMinDecParserRuleCall_4_0(), semanticObject.getLatMf());
		feeder.accept(grammarAccess.getPoint2Access().getWeWEEnumRuleCall_5_0(), semanticObject.getWe());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Point returns Point3
	 *     Point3 returns Point3
	 *
	 * Constraint:
	 *     (
	 *         longD=LongDegr 
	 *         longM=MinSec 
	 *         longS=SecDec 
	 *         ns=NS 
	 *         latD=LatDegr 
	 *         latM=MinSec 
	 *         latS=SecDec 
	 *         we=WE
	 *     )
	 * </pre>
	 */
	protected void sequence_Point3(ISerializationContext context, Point3 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT3__LONG_D) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT3__LONG_D));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT3__LONG_M) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT3__LONG_M));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT3__LONG_S) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT3__LONG_S));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT__NS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT__NS));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT3__LAT_D) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT3__LAT_D));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT3__LAT_M) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT3__LAT_M));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT3__LAT_S) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT3__LAT_S));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT__WE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT__WE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPoint3Access().getLongDLongDegrParserRuleCall_0_0(), semanticObject.getLongD());
		feeder.accept(grammarAccess.getPoint3Access().getLongMMinSecParserRuleCall_1_0(), semanticObject.getLongM());
		feeder.accept(grammarAccess.getPoint3Access().getLongSSecDecParserRuleCall_2_0(), semanticObject.getLongS());
		feeder.accept(grammarAccess.getPoint3Access().getNsNSEnumRuleCall_3_0(), semanticObject.getNs());
		feeder.accept(grammarAccess.getPoint3Access().getLatDLatDegrParserRuleCall_4_0(), semanticObject.getLatD());
		feeder.accept(grammarAccess.getPoint3Access().getLatMMinSecParserRuleCall_5_0(), semanticObject.getLatM());
		feeder.accept(grammarAccess.getPoint3Access().getLatSSecDecParserRuleCall_6_0(), semanticObject.getLatS());
		feeder.accept(grammarAccess.getPoint3Access().getWeWEEnumRuleCall_7_0(), semanticObject.getWe());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Point returns Point4
	 *     Point4 returns Point4
	 *
	 * Constraint:
	 *     (longD=LongDec ns=NS latD=LatDec we=WE)
	 * </pre>
	 */
	protected void sequence_Point4(ISerializationContext context, Point4 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT4__LONG_D) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT4__LONG_D));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT__NS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT__NS));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT4__LAT_D) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT4__LAT_D));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.POINT__WE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.POINT__WE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPoint4Access().getLongDLongDecParserRuleCall_0_0(), semanticObject.getLongD());
		feeder.accept(grammarAccess.getPoint4Access().getNsNSEnumRuleCall_1_0(), semanticObject.getNs());
		feeder.accept(grammarAccess.getPoint4Access().getLatDLatDecParserRuleCall_2_0(), semanticObject.getLatD());
		feeder.accept(grammarAccess.getPoint4Access().getWeWEEnumRuleCall_3_0(), semanticObject.getWe());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Radius returns Radius
	 *
	 * Constraint:
	 *     (intValue=INT | reakValuer=REAL)
	 * </pre>
	 */
	protected void sequence_Radius(ISerializationContext context, Radius semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SB returns SB
	 *
	 * Constraint:
	 *     (sbVal1=INT sbVal2=INT sbVal3=INT)
	 * </pre>
	 */
	protected void sequence_SB(ISerializationContext context, SB semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.SB__SB_VAL1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.SB__SB_VAL1));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.SB__SB_VAL2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.SB__SB_VAL2));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.SB__SB_VAL3) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.SB__SB_VAL3));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSBAccess().getSbVal1INTTerminalRuleCall_1_0(), semanticObject.getSbVal1());
		feeder.accept(grammarAccess.getSBAccess().getSbVal2INTTerminalRuleCall_3_0(), semanticObject.getSbVal2());
		feeder.accept(grammarAccess.getSBAccess().getSbVal3INTTerminalRuleCall_5_0(), semanticObject.getSbVal3());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Limit returns SFC
	 *     SFC returns SFC
	 *
	 * Constraint:
	 *     {SFC}
	 * </pre>
	 */
	protected void sequence_SFC(ISerializationContext context, SFC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SP returns SP
	 *
	 * Constraint:
	 *     (sp0=INT sp1=INT sp2=INT sp3=INT sp4=INT)
	 * </pre>
	 */
	protected void sequence_SP(ISerializationContext context, SP semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.SP__SP0) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.SP__SP0));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.SP__SP1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.SP__SP1));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.SP__SP2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.SP__SP2));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.SP__SP3) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.SP__SP3));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.SP__SP4) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.SP__SP4));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSPAccess().getSp0INTTerminalRuleCall_1_0(), semanticObject.getSp0());
		feeder.accept(grammarAccess.getSPAccess().getSp1INTTerminalRuleCall_3_0(), semanticObject.getSp1());
		feeder.accept(grammarAccess.getSPAccess().getSp2INTTerminalRuleCall_5_0(), semanticObject.getSp2());
		feeder.accept(grammarAccess.getSPAccess().getSp3INTTerminalRuleCall_7_0(), semanticObject.getSp3());
		feeder.accept(grammarAccess.getSPAccess().getSp4INTTerminalRuleCall_9_0(), semanticObject.getSp4());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SecDec returns SecDec
	 *
	 * Constraint:
	 *     value=REAL
	 * </pre>
	 */
	protected void sequence_SecDec(ISerializationContext context, SecDec semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.SEC_DEC__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.SEC_DEC__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSecDecAccess().getValueREALTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TheDef returns TheDef
	 *
	 * Constraint:
	 *     (
	 *         asclass=AsClass 
	 *         sp+=SP* 
	 *         sb+=SB* 
	 *         name=AsName 
	 *         at+=AT* 
	 *         limit=Limites 
	 *         at+=AT*
	 *     )
	 * </pre>
	 */
	protected void sequence_TheDef(ISerializationContext context, TheDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Limit returns UNL
	 *     UNL returns UNL
	 *
	 * Constraint:
	 *     {UNL}
	 * </pre>
	 */
	protected void sequence_UNL(ISerializationContext context, UNL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Limit returns VAL
	 *     VAL returns VAL
	 *
	 * Constraint:
	 *     (value=INT unit=Units)
	 * </pre>
	 */
	protected void sequence_VAL(ISerializationContext context, VAL semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.VAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.VAL__VALUE));
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.VAL__UNIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.VAL__UNIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVALAccess().getValueINTTerminalRuleCall_0_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getVALAccess().getUnitUnitsEnumRuleCall_1_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TheGeom returns V
	 *     V returns V
	 *
	 * Constraint:
	 *     vsub=Vsub
	 * </pre>
	 */
	protected void sequence_V(ISerializationContext context, V semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OpenAirPackage.Literals.V__VSUB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OpenAirPackage.Literals.V__VSUB));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVAccess().getVsubVsubParserRuleCall_1_0(), semanticObject.getVsub());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Vsub returns Vsub
	 *
	 * Constraint:
	 *     (x=Point | d=Dir)
	 * </pre>
	 */
	protected void sequence_Vsub(ISerializationContext context, Vsub semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}

/*
 * generated by Xtext 2.35.0
 */
package uniandes.academia.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import uniandes.academia.generator.Application;
import uniandes.academia.generator.Attribute;
import uniandes.academia.generator.Child;
import uniandes.academia.generator.Children;
import uniandes.academia.generator.ComponentContainer;
import uniandes.academia.generator.Components;
import uniandes.academia.generator.Configuration;
import uniandes.academia.generator.ContainerModule;
import uniandes.academia.generator.Crud;
import uniandes.academia.generator.GeneratorPackage;
import uniandes.academia.generator.Import;
import uniandes.academia.generator.Model;
import uniandes.academia.generator.Models;
import uniandes.academia.generator.Modules;
import uniandes.academia.generator.PackageDeclaration;
import uniandes.academia.generator.Root;
import uniandes.academia.generator.SearchComboBox;
import uniandes.academia.generator.Service;
import uniandes.academia.generator.Services;
import uniandes.academia.generator.VisualModule;
import uniandes.academia.services.GeneratorGrammarAccess;

@SuppressWarnings("all")
public class GeneratorSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GeneratorGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GeneratorPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GeneratorPackage.APPLICATION:
				sequence_Application(context, (Application) semanticObject); 
				return; 
			case GeneratorPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case GeneratorPackage.CHILD:
				sequence_Child(context, (Child) semanticObject); 
				return; 
			case GeneratorPackage.CHILDREN:
				sequence_Children(context, (Children) semanticObject); 
				return; 
			case GeneratorPackage.COMPONENT_CONTAINER:
				sequence_ComponentContainer(context, (ComponentContainer) semanticObject); 
				return; 
			case GeneratorPackage.COMPONENTS:
				sequence_Components(context, (Components) semanticObject); 
				return; 
			case GeneratorPackage.CONFIGURATION:
				sequence_Configuration(context, (Configuration) semanticObject); 
				return; 
			case GeneratorPackage.CONTAINER_MODULE:
				sequence_ContainerModule(context, (ContainerModule) semanticObject); 
				return; 
			case GeneratorPackage.CRUD:
				sequence_Crud(context, (Crud) semanticObject); 
				return; 
			case GeneratorPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case GeneratorPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case GeneratorPackage.MODELS:
				sequence_Models(context, (Models) semanticObject); 
				return; 
			case GeneratorPackage.MODULES:
				sequence_Modules(context, (Modules) semanticObject); 
				return; 
			case GeneratorPackage.PACKAGE_DECLARATION:
				sequence_PackageDeclaration(context, (PackageDeclaration) semanticObject); 
				return; 
			case GeneratorPackage.ROOT:
				sequence_Root(context, (Root) semanticObject); 
				return; 
			case GeneratorPackage.SEARCH_COMBO_BOX:
				sequence_SearchComboBox(context, (SearchComboBox) semanticObject); 
				return; 
			case GeneratorPackage.SERVICE:
				sequence_Service(context, (Service) semanticObject); 
				return; 
			case GeneratorPackage.SERVICES:
				sequence_Services(context, (Services) semanticObject); 
				return; 
			case GeneratorPackage.VISUAL_MODULE:
				sequence_VisualModule(context, (VisualModule) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractElement returns Application
	 *     Application returns Application
	 *
	 * Constraint:
	 *     (name=Name elements+=AbstractElement*)
	 * </pre>
	 */
	protected void sequence_Application(ISerializationContext context, Application semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (name=Name type=EnumType component=[ComponentBasic|ID]? isRequired=BOOLEAN? mockType=EString?)
	 * </pre>
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Child returns Child
	 *
	 * Constraint:
	 *     (name=Name component=[Crud|ID] attributeName=EString type=EnumRealtionshipType)
	 * </pre>
	 */
	protected void sequence_Child(ISerializationContext context, Child semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GeneratorPackage.Literals.CHILD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GeneratorPackage.Literals.CHILD__NAME));
			if (transientValues.isValueTransient(semanticObject, GeneratorPackage.Literals.CHILD__COMPONENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GeneratorPackage.Literals.CHILD__COMPONENT));
			if (transientValues.isValueTransient(semanticObject, GeneratorPackage.Literals.CHILD__ATTRIBUTE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GeneratorPackage.Literals.CHILD__ATTRIBUTE_NAME));
			if (transientValues.isValueTransient(semanticObject, GeneratorPackage.Literals.CHILD__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GeneratorPackage.Literals.CHILD__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChildAccess().getNameNameParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getChildAccess().getComponentCrudIDTerminalRuleCall_4_0_1(), semanticObject.eGet(GeneratorPackage.Literals.CHILD__COMPONENT, false));
		feeder.accept(grammarAccess.getChildAccess().getAttributeNameEStringParserRuleCall_8_0(), semanticObject.getAttributeName());
		feeder.accept(grammarAccess.getChildAccess().getTypeEnumRealtionshipTypeEnumRuleCall_12_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractElement returns Children
	 *     Children returns Children
	 *
	 * Constraint:
	 *     children+=Child+
	 * </pre>
	 */
	protected void sequence_Children(ISerializationContext context, Children semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns ComponentContainer
	 *     ComponentContainer returns ComponentContainer
	 *
	 * Constraint:
	 *     name=Name
	 * </pre>
	 */
	protected void sequence_ComponentContainer(ISerializationContext context, ComponentContainer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GeneratorPackage.Literals.COMPONENT_CONTAINER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GeneratorPackage.Literals.COMPONENT_CONTAINER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComponentContainerAccess().getNameNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractElement returns Components
	 *     Components returns Components
	 *
	 * Constraint:
	 *     components+=Component+
	 * </pre>
	 */
	protected void sequence_Components(ISerializationContext context, Components semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Configuration returns Configuration
	 *
	 * Constraint:
	 *     (version=EString onlyComponents=BOOLEAN? language=EnumLanguage?)
	 * </pre>
	 */
	protected void sequence_Configuration(ISerializationContext context, Configuration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Module returns ContainerModule
	 *     ContainerModule returns ContainerModule
	 *
	 * Constraint:
	 *     (name=Name parent=[Module|ID] imports+=[Module|ID]* exports+=[Component|ID]* components+=[Component|ID]*)
	 * </pre>
	 */
	protected void sequence_ContainerModule(ISerializationContext context, ContainerModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Component returns Crud
	 *     ComponentBasic returns Crud
	 *     Crud returns Crud
	 *
	 * Constraint:
	 *     (
	 *         name=Name 
	 *         modelData=[Model|ID] 
	 *         showAsGallery=BOOLEAN? 
	 *         enableMock=BOOLEAN? 
	 *         create=[Service|QualifiedName] 
	 *         update=[Service|QualifiedName] 
	 *         list=[Service|QualifiedName] 
	 *         listNum=[Service|QualifiedName] 
	 *         deleteItem=[Service|QualifiedName] 
	 *         get=[Service|QualifiedName]
	 *     )
	 * </pre>
	 */
	protected void sequence_Crud(ISerializationContext context, Crud semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractElement returns Import
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 * </pre>
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GeneratorPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GeneratorPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (name=Name attributes+=Attribute* children+=Child* idAtribute=EString nameAttribute=EString)
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractElement returns Models
	 *     Models returns Models
	 *
	 * Constraint:
	 *     models+=Model+
	 * </pre>
	 */
	protected void sequence_Models(ISerializationContext context, Models semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractElement returns Modules
	 *     Modules returns Modules
	 *
	 * Constraint:
	 *     modules+=Module+
	 * </pre>
	 */
	protected void sequence_Modules(ISerializationContext context, Modules semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractElement returns PackageDeclaration
	 *     PackageDeclaration returns PackageDeclaration
	 *
	 * Constraint:
	 *     (name=QualifiedName elements+=AbstractElement*)
	 * </pre>
	 */
	protected void sequence_PackageDeclaration(ISerializationContext context, PackageDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Root returns Root
	 *
	 * Constraint:
	 *     elements+=AbstractElement+
	 * </pre>
	 */
	protected void sequence_Root(ISerializationContext context, Root semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SearchComboBox returns SearchComboBox
	 *
	 * Constraint:
	 *     (name=Name modelData=[Model|ID] service=[Service|QualifiedName])
	 * </pre>
	 */
	protected void sequence_SearchComboBox(ISerializationContext context, SearchComboBox semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GeneratorPackage.Literals.SEARCH_COMBO_BOX__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GeneratorPackage.Literals.SEARCH_COMBO_BOX__NAME));
			if (transientValues.isValueTransient(semanticObject, GeneratorPackage.Literals.SEARCH_COMBO_BOX__MODEL_DATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GeneratorPackage.Literals.SEARCH_COMBO_BOX__MODEL_DATA));
			if (transientValues.isValueTransient(semanticObject, GeneratorPackage.Literals.SEARCH_COMBO_BOX__SERVICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GeneratorPackage.Literals.SEARCH_COMBO_BOX__SERVICE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSearchComboBoxAccess().getNameNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSearchComboBoxAccess().getModelDataModelIDTerminalRuleCall_5_0_1(), semanticObject.eGet(GeneratorPackage.Literals.SEARCH_COMBO_BOX__MODEL_DATA, false));
		feeder.accept(grammarAccess.getSearchComboBoxAccess().getServiceServiceQualifiedNameParserRuleCall_9_0_1(), semanticObject.eGet(GeneratorPackage.Literals.SEARCH_COMBO_BOX__SERVICE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Service returns Service
	 *
	 * Constraint:
	 *     (name=Name url=EString type=EnumMethodType collectionName=EString?)
	 * </pre>
	 */
	protected void sequence_Service(ISerializationContext context, Service semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractElement returns Services
	 *     Services returns Services
	 *
	 * Constraint:
	 *     (name=Name baseUrl=EString services+=Service*)
	 * </pre>
	 */
	protected void sequence_Services(ISerializationContext context, Services semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Module returns VisualModule
	 *     VisualModule returns VisualModule
	 *
	 * Constraint:
	 *     (
	 *         name=Name 
	 *         parent=[Module|ID]? 
	 *         imports+=[Module|ID]* 
	 *         exports+=[Module|ID]* 
	 *         routes+=EString* 
	 *         show+=EString* 
	 *         defaultRoute=EString 
	 *         type=EnumLayout? 
	 *         components+=[Component|ID]*
	 *     )
	 * </pre>
	 */
	protected void sequence_VisualModule(ISerializationContext context, VisualModule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}

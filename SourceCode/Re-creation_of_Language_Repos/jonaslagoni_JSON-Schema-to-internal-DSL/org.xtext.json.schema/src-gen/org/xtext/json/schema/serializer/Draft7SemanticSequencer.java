/*
 * generated by Xtext 2.35.0
 */
package org.xtext.json.schema.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.json.schema.draft7.AdditionalItems;
import org.xtext.json.schema.draft7.AdditionalProperties;
import org.xtext.json.schema.draft7.AnyString;
import org.xtext.json.schema.draft7.Contains;
import org.xtext.json.schema.draft7.Default;
import org.xtext.json.schema.draft7.Dependencies;
import org.xtext.json.schema.draft7.Draft7Package;
import org.xtext.json.schema.draft7.Example;
import org.xtext.json.schema.draft7.Items;
import org.xtext.json.schema.draft7.NamedSchema;
import org.xtext.json.schema.draft7.PropertyDependency;
import org.xtext.json.schema.draft7.Reference;
import org.xtext.json.schema.draft7.Schema;
import org.xtext.json.schema.draft7.Types;
import org.xtext.json.schema.services.Draft7GrammarAccess;

@SuppressWarnings("all")
public class Draft7SemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private Draft7GrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == Draft7Package.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Draft7Package.ADDITIONAL_ITEMS:
				sequence_AdditionalItems(context, (AdditionalItems) semanticObject); 
				return; 
			case Draft7Package.ADDITIONAL_PROPERTIES:
				sequence_AdditionalProperties(context, (AdditionalProperties) semanticObject); 
				return; 
			case Draft7Package.ANY_STRING:
				sequence_AnyString(context, (AnyString) semanticObject); 
				return; 
			case Draft7Package.CONTAINS:
				sequence_Contains(context, (Contains) semanticObject); 
				return; 
			case Draft7Package.DEFAULT:
				sequence_Default(context, (Default) semanticObject); 
				return; 
			case Draft7Package.DEPENDENCIES:
				sequence_Dependencies(context, (Dependencies) semanticObject); 
				return; 
			case Draft7Package.EXAMPLE:
				sequence_Example(context, (Example) semanticObject); 
				return; 
			case Draft7Package.ITEMS:
				sequence_Items(context, (Items) semanticObject); 
				return; 
			case Draft7Package.NAMED_SCHEMA:
				sequence_NamedSchema(context, (NamedSchema) semanticObject); 
				return; 
			case Draft7Package.NUMBER:
				sequence_Number(context, (org.xtext.json.schema.draft7.Number) semanticObject); 
				return; 
			case Draft7Package.PROPERTY_DEPENDENCY:
				sequence_PropertyDependency(context, (PropertyDependency) semanticObject); 
				return; 
			case Draft7Package.REFERENCE:
				sequence_Reference(context, (Reference) semanticObject); 
				return; 
			case Draft7Package.SCHEMA:
				sequence_Schema(context, (Schema) semanticObject); 
				return; 
			case Draft7Package.TYPES:
				sequence_Types(context, (Types) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdditionalItems returns AdditionalItems
	 *
	 * Constraint:
	 *     (allowedBoolean=Boolean | schema=AbstractSchema)
	 * </pre>
	 */
	protected void sequence_AdditionalItems(ISerializationContext context, AdditionalItems semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdditionalProperties returns AdditionalProperties
	 *
	 * Constraint:
	 *     (allowedBoolean=Boolean | schema=AbstractSchema)
	 * </pre>
	 */
	protected void sequence_AdditionalProperties(ISerializationContext context, AdditionalProperties semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnyString returns AnyString
	 *
	 * Constraint:
	 *     (name=STRING | keyword=JsonSchemaKeyword)
	 * </pre>
	 */
	protected void sequence_AnyString(ISerializationContext context, AnyString semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Contains returns Contains
	 *
	 * Constraint:
	 *     ((containSchemas+=Schema containSchemas+=Schema*) | containSchemas+=Schema)
	 * </pre>
	 */
	protected void sequence_Contains(ISerializationContext context, Contains semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Default returns Default
	 *
	 * Constraint:
	 *     (
	 *         defaultSchema=AbstractSchema | 
	 *         defaultString=AnyString | 
	 *         defaultBoolean=Boolean | 
	 *         defaultNumber=Number | 
	 *         (defaultArrayItems+=AbstractSchema defaultArrayItems+=AbstractSchema*)
	 *     )?
	 * </pre>
	 */
	protected void sequence_Default(ISerializationContext context, Default semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Dependencies returns Dependencies
	 *
	 * Constraint:
	 *     (PropertyDependency=PropertyDependency | (schemaDependencies+=NamedSchema schemaDependencies+=NamedSchema*))
	 * </pre>
	 */
	protected void sequence_Dependencies(ISerializationContext context, Dependencies semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Example returns Example
	 *
	 * Constraint:
	 *     (exampleSchema=Schema | exampleString=AnyString | exampleBoolean=Boolean | exampleNumber=Number | (exampleArrayItems+=Schema exampleArrayItems+=Schema*))
	 * </pre>
	 */
	protected void sequence_Example(ISerializationContext context, Example semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Items returns Items
	 *
	 * Constraint:
	 *     ((items+=AbstractSchema items+=AbstractSchema*) | items+=AbstractSchema | selfReference=Boolean)
	 * </pre>
	 */
	protected void sequence_Items(ISerializationContext context, Items semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NamedSchema returns NamedSchema
	 *
	 * Constraint:
	 *     (name=AnyString schema=AbstractSchema)
	 * </pre>
	 */
	protected void sequence_NamedSchema(ISerializationContext context, NamedSchema semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Draft7Package.Literals.NAMED_SCHEMA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Draft7Package.Literals.NAMED_SCHEMA__NAME));
			if (transientValues.isValueTransient(semanticObject, Draft7Package.Literals.NAMED_SCHEMA__SCHEMA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Draft7Package.Literals.NAMED_SCHEMA__SCHEMA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNamedSchemaAccess().getNameAnyStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNamedSchemaAccess().getSchemaAbstractSchemaParserRuleCall_3_0(), semanticObject.getSchema());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Number returns Number
	 *
	 * Constraint:
	 *     (number=INT decimal=INT?)
	 * </pre>
	 */
	protected void sequence_Number(ISerializationContext context, org.xtext.json.schema.draft7.Number semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PropertyDependency returns PropertyDependency
	 *
	 * Constraint:
	 *     (name=AnyString dependencies+=AnyString dependencies+=AnyString*)
	 * </pre>
	 */
	protected void sequence_PropertyDependency(ISerializationContext context, PropertyDependency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractSchema returns Reference
	 *     Reference returns Reference
	 *
	 * Constraint:
	 *     uri=AnyString
	 * </pre>
	 */
	protected void sequence_Reference(ISerializationContext context, Reference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Draft7Package.Literals.REFERENCE__URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Draft7Package.Literals.REFERENCE__URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReferenceAccess().getUriAnyStringParserRuleCall_4_0(), semanticObject.getUri());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Schema returns Schema
	 *     AbstractSchema returns Schema
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             type=Types | 
	 *             dependencies=Dependencies | 
	 *             additionalProperties=AdditionalProperties | 
	 *             additionalItems=AdditionalItems | 
	 *             default=Default | 
	 *             example=Example | 
	 *             items=Items | 
	 *             contains=Contains | 
	 *             title=STRING | 
	 *             description=STRING | 
	 *             id=AnyString | 
	 *             ifSchema=Schema | 
	 *             thenSchema=Schema | 
	 *             elseSchema=Schema | 
	 *             const=AnyString | 
	 *             constBoolean=Boolean | 
	 *             not=AbstractSchema | 
	 *             unique=Boolean | 
	 *             propertyNames=AbstractSchema | 
	 *             minProperties=INT | 
	 *             maxProperties=INT | 
	 *             maxItems=INT | 
	 *             minItems=INT | 
	 *             maxLength=INT | 
	 *             minLength=INT | 
	 *             pattern=AnyString | 
	 *             format=FormatTypes | 
	 *             mediaType=AnyString | 
	 *             encoding=AnyString | 
	 *             multipleOf=INT | 
	 *             minimum=Number | 
	 *             exclusiveMinimum=Number | 
	 *             maximum=Number | 
	 *             exclusiveMaximum=Number
	 *         )? 
	 *         (patternProperties+=NamedSchema patternProperties+=NamedSchema*)? 
	 *         (definitions+=NamedSchema definitions+=NamedSchema*)? 
	 *         (requiredProperties+=AnyString requiredProperties+=AnyString*)? 
	 *         (properties+=NamedSchema properties+=NamedSchema*)? 
	 *         (enumValues+=AnyString enumValues+=AnyString*)? 
	 *         (enumValues+=AnyString enumValues+=AnyString*)? 
	 *         (anyOfs+=AbstractSchema anyOfs+=AbstractSchema*)? 
	 *         (oneOfs+=AbstractSchema oneOfs+=AbstractSchema*)? 
	 *         (allOfs+=AbstractSchema allOfs+=AbstractSchema*)?
	 *     )+
	 * </pre>
	 */
	protected void sequence_Schema(ISerializationContext context, Schema semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Types returns Types
	 *
	 * Constraint:
	 *     ((jsonTypes+=JsonTypes jsonTypes+=JsonTypes*) | jsonTypes+=JsonTypes)
	 * </pre>
	 */
	protected void sequence_Types(ISerializationContext context, Types semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}

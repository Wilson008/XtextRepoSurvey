/*
 * generated by Xtext 2.35.0
 */
package org.eclipse.scout.saml.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.scout.saml.saml.BigDecimalElement;
import org.eclipse.scout.saml.saml.ButtonElement;
import org.eclipse.scout.saml.saml.CheckboxElement;
import org.eclipse.scout.saml.saml.CodeElement;
import org.eclipse.scout.saml.saml.ColumnElement;
import org.eclipse.scout.saml.saml.CustomFieldElement;
import org.eclipse.scout.saml.saml.DateElement;
import org.eclipse.scout.saml.saml.FileChooserElement;
import org.eclipse.scout.saml.saml.FormElement;
import org.eclipse.scout.saml.saml.GroupBoxElement;
import org.eclipse.scout.saml.saml.ImportElement;
import org.eclipse.scout.saml.saml.KeyElement;
import org.eclipse.scout.saml.saml.LanguageAttribute;
import org.eclipse.scout.saml.saml.ListBoxElement;
import org.eclipse.scout.saml.saml.LogicElement;
import org.eclipse.scout.saml.saml.LongElement;
import org.eclipse.scout.saml.saml.LookupElement;
import org.eclipse.scout.saml.saml.MenuElement;
import org.eclipse.scout.saml.saml.Model;
import org.eclipse.scout.saml.saml.ModuleElement;
import org.eclipse.scout.saml.saml.RadioButtonElement;
import org.eclipse.scout.saml.saml.RadioGroupElement;
import org.eclipse.scout.saml.saml.SamlPackage;
import org.eclipse.scout.saml.saml.SequenceBoxElement;
import org.eclipse.scout.saml.saml.SmartfieldElement;
import org.eclipse.scout.saml.saml.StringElement;
import org.eclipse.scout.saml.saml.TabBoxElement;
import org.eclipse.scout.saml.saml.TabElement;
import org.eclipse.scout.saml.saml.TableElement;
import org.eclipse.scout.saml.saml.TemplateElement;
import org.eclipse.scout.saml.saml.TranslationElement;
import org.eclipse.scout.saml.services.SamlGrammarAccess;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.common.types.JvmFormalParameter;
import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;
import org.eclipse.xtext.common.types.JvmInnerTypeReference;
import org.eclipse.xtext.common.types.JvmLowerBound;
import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;
import org.eclipse.xtext.common.types.JvmTypeParameter;
import org.eclipse.xtext.common.types.JvmUpperBound;
import org.eclipse.xtext.common.types.JvmWildcardTypeReference;
import org.eclipse.xtext.common.types.TypesPackage;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.eclipse.xtext.xbase.XAssignment;
import org.eclipse.xtext.xbase.XBasicForLoopExpression;
import org.eclipse.xtext.xbase.XBinaryOperation;
import org.eclipse.xtext.xbase.XBlockExpression;
import org.eclipse.xtext.xbase.XBooleanLiteral;
import org.eclipse.xtext.xbase.XCasePart;
import org.eclipse.xtext.xbase.XCastedExpression;
import org.eclipse.xtext.xbase.XCatchClause;
import org.eclipse.xtext.xbase.XClosure;
import org.eclipse.xtext.xbase.XConstructorCall;
import org.eclipse.xtext.xbase.XDoWhileExpression;
import org.eclipse.xtext.xbase.XFeatureCall;
import org.eclipse.xtext.xbase.XForLoopExpression;
import org.eclipse.xtext.xbase.XIfExpression;
import org.eclipse.xtext.xbase.XInstanceOfExpression;
import org.eclipse.xtext.xbase.XListLiteral;
import org.eclipse.xtext.xbase.XMemberFeatureCall;
import org.eclipse.xtext.xbase.XNullLiteral;
import org.eclipse.xtext.xbase.XNumberLiteral;
import org.eclipse.xtext.xbase.XPostfixOperation;
import org.eclipse.xtext.xbase.XReturnExpression;
import org.eclipse.xtext.xbase.XSetLiteral;
import org.eclipse.xtext.xbase.XStringLiteral;
import org.eclipse.xtext.xbase.XSwitchExpression;
import org.eclipse.xtext.xbase.XSynchronizedExpression;
import org.eclipse.xtext.xbase.XThrowExpression;
import org.eclipse.xtext.xbase.XTryCatchFinallyExpression;
import org.eclipse.xtext.xbase.XTypeLiteral;
import org.eclipse.xtext.xbase.XUnaryOperation;
import org.eclipse.xtext.xbase.XVariableDeclaration;
import org.eclipse.xtext.xbase.XWhileExpression;
import org.eclipse.xtext.xbase.XbasePackage;
import org.eclipse.xtext.xbase.serializer.XbaseSemanticSequencer;
import org.eclipse.xtext.xtype.XFunctionTypeRef;
import org.eclipse.xtext.xtype.XImportDeclaration;
import org.eclipse.xtext.xtype.XImportSection;
import org.eclipse.xtext.xtype.XtypePackage;

@SuppressWarnings("all")
public class SamlSemanticSequencer extends XbaseSemanticSequencer {

	@Inject
	private SamlGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SamlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SamlPackage.BIG_DECIMAL_ELEMENT:
				sequence_BigDecimalElement(context, (BigDecimalElement) semanticObject); 
				return; 
			case SamlPackage.BUTTON_ELEMENT:
				sequence_ButtonElement(context, (ButtonElement) semanticObject); 
				return; 
			case SamlPackage.CHECKBOX_ELEMENT:
				sequence_CheckboxElement(context, (CheckboxElement) semanticObject); 
				return; 
			case SamlPackage.CODE_ELEMENT:
				sequence_CodeElement(context, (CodeElement) semanticObject); 
				return; 
			case SamlPackage.COLUMN_ELEMENT:
				sequence_ColumnElement(context, (ColumnElement) semanticObject); 
				return; 
			case SamlPackage.CUSTOM_FIELD_ELEMENT:
				sequence_CustomFieldElement(context, (CustomFieldElement) semanticObject); 
				return; 
			case SamlPackage.DATE_ELEMENT:
				sequence_DateElement(context, (DateElement) semanticObject); 
				return; 
			case SamlPackage.FILE_CHOOSER_ELEMENT:
				sequence_FileChooserElement(context, (FileChooserElement) semanticObject); 
				return; 
			case SamlPackage.FORM_ELEMENT:
				sequence_FormElement(context, (FormElement) semanticObject); 
				return; 
			case SamlPackage.GROUP_BOX_ELEMENT:
				sequence_GroupBoxElement(context, (GroupBoxElement) semanticObject); 
				return; 
			case SamlPackage.IMPORT_ELEMENT:
				sequence_ImportElement(context, (ImportElement) semanticObject); 
				return; 
			case SamlPackage.KEY_ELEMENT:
				sequence_KeyElement(context, (KeyElement) semanticObject); 
				return; 
			case SamlPackage.LANGUAGE_ATTRIBUTE:
				sequence_LanguageAttribute(context, (LanguageAttribute) semanticObject); 
				return; 
			case SamlPackage.LIST_BOX_ELEMENT:
				sequence_ListBoxElement(context, (ListBoxElement) semanticObject); 
				return; 
			case SamlPackage.LOGIC_ELEMENT:
				sequence_LogicElement(context, (LogicElement) semanticObject); 
				return; 
			case SamlPackage.LONG_ELEMENT:
				sequence_LongElement(context, (LongElement) semanticObject); 
				return; 
			case SamlPackage.LOOKUP_ELEMENT:
				sequence_LookupElement(context, (LookupElement) semanticObject); 
				return; 
			case SamlPackage.MENU_ELEMENT:
				sequence_MenuElement(context, (MenuElement) semanticObject); 
				return; 
			case SamlPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case SamlPackage.MODULE_ELEMENT:
				sequence_ModuleElement(context, (ModuleElement) semanticObject); 
				return; 
			case SamlPackage.RADIO_BUTTON_ELEMENT:
				sequence_RadioButtonElement(context, (RadioButtonElement) semanticObject); 
				return; 
			case SamlPackage.RADIO_GROUP_ELEMENT:
				sequence_RadioGroupElement(context, (RadioGroupElement) semanticObject); 
				return; 
			case SamlPackage.SEQUENCE_BOX_ELEMENT:
				sequence_SequenceBoxElement(context, (SequenceBoxElement) semanticObject); 
				return; 
			case SamlPackage.SMARTFIELD_ELEMENT:
				sequence_SmartfieldElement(context, (SmartfieldElement) semanticObject); 
				return; 
			case SamlPackage.STRING_ELEMENT:
				sequence_StringElement(context, (StringElement) semanticObject); 
				return; 
			case SamlPackage.TAB_BOX_ELEMENT:
				sequence_TabBoxElement(context, (TabBoxElement) semanticObject); 
				return; 
			case SamlPackage.TAB_ELEMENT:
				sequence_TabElement(context, (TabElement) semanticObject); 
				return; 
			case SamlPackage.TABLE_ELEMENT:
				sequence_TableElement(context, (TableElement) semanticObject); 
				return; 
			case SamlPackage.TEMPLATE_ELEMENT:
				sequence_TemplateElement(context, (TemplateElement) semanticObject); 
				return; 
			case SamlPackage.TRANSLATION_ELEMENT:
				sequence_TranslationElement(context, (TranslationElement) semanticObject); 
				return; 
			}
		else if (epackage == TypesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TypesPackage.JVM_FORMAL_PARAMETER:
				if (rule == grammarAccess.getFullJvmFormalParameterRule()) {
					sequence_FullJvmFormalParameter(context, (JvmFormalParameter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmFormalParameterRule()) {
					sequence_JvmFormalParameter(context, (JvmFormalParameter) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_GENERIC_ARRAY_TYPE_REFERENCE:
				sequence_JvmTypeReference(context, (JvmGenericArrayTypeReference) semanticObject); 
				return; 
			case TypesPackage.JVM_INNER_TYPE_REFERENCE:
				sequence_JvmParameterizedTypeReference(context, (JvmInnerTypeReference) semanticObject); 
				return; 
			case TypesPackage.JVM_LOWER_BOUND:
				if (rule == grammarAccess.getJvmLowerBoundAndedRule()) {
					sequence_JvmLowerBoundAnded(context, (JvmLowerBound) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmLowerBoundRule()) {
					sequence_JvmLowerBound(context, (JvmLowerBound) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_PARAMETERIZED_TYPE_REFERENCE:
				if (action == grammarAccess.getJvmParameterizedTypeReferenceAccess().getJvmInnerTypeReferenceOuterAction_1_4_0_0_0()) {
					sequence_JvmParameterizedTypeReference_JvmInnerTypeReference_1_4_0_0_0(context, (JvmParameterizedTypeReference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmTypeReferenceRule()
						|| action == grammarAccess.getJvmTypeReferenceAccess().getJvmGenericArrayTypeReferenceComponentTypeAction_0_1_0_0()
						|| rule == grammarAccess.getJvmParameterizedTypeReferenceRule()
						|| rule == grammarAccess.getJvmArgumentTypeReferenceRule()) {
					sequence_JvmParameterizedTypeReference(context, (JvmParameterizedTypeReference) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_TYPE_PARAMETER:
				sequence_JvmTypeParameter(context, (JvmTypeParameter) semanticObject); 
				return; 
			case TypesPackage.JVM_UPPER_BOUND:
				if (rule == grammarAccess.getJvmUpperBoundAndedRule()) {
					sequence_JvmUpperBoundAnded(context, (JvmUpperBound) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmUpperBoundRule()) {
					sequence_JvmUpperBound(context, (JvmUpperBound) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_WILDCARD_TYPE_REFERENCE:
				sequence_JvmWildcardTypeReference(context, (JvmWildcardTypeReference) semanticObject); 
				return; 
			}
		else if (epackage == XbasePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XbasePackage.XASSIGNMENT:
				sequence_XAssignment_XMemberFeatureCall(context, (XAssignment) semanticObject); 
				return; 
			case XbasePackage.XBASIC_FOR_LOOP_EXPRESSION:
				sequence_XBasicForLoopExpression(context, (XBasicForLoopExpression) semanticObject); 
				return; 
			case XbasePackage.XBINARY_OPERATION:
				sequence_XAdditiveExpression_XAndExpression_XAssignment_XEqualityExpression_XMultiplicativeExpression_XOrExpression_XOtherOperatorExpression_XRelationalExpression(context, (XBinaryOperation) semanticObject); 
				return; 
			case XbasePackage.XBLOCK_EXPRESSION:
				if (rule == grammarAccess.getXExpressionRule()
						|| rule == grammarAccess.getXAssignmentRule()
						|| action == grammarAccess.getXAssignmentAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOrExpressionRule()
						|| action == grammarAccess.getXOrExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAndExpressionRule()
						|| action == grammarAccess.getXAndExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXEqualityExpressionRule()
						|| action == grammarAccess.getXEqualityExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXRelationalExpressionRule()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXInstanceOfExpressionExpressionAction_1_0_0_0_0()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOtherOperatorExpressionRule()
						|| action == grammarAccess.getXOtherOperatorExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAdditiveExpressionRule()
						|| action == grammarAccess.getXAdditiveExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXMultiplicativeExpressionRule()
						|| action == grammarAccess.getXMultiplicativeExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXUnaryOperationRule()
						|| rule == grammarAccess.getXCastedExpressionRule()
						|| action == grammarAccess.getXCastedExpressionAccess().getXCastedExpressionTargetAction_1_0_0_0()
						|| rule == grammarAccess.getXPostfixOperationRule()
						|| action == grammarAccess.getXPostfixOperationAccess().getXPostfixOperationOperandAction_1_0_0()
						|| rule == grammarAccess.getXMemberFeatureCallRule()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXAssignmentAssignableAction_1_0_0_0_0()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXMemberFeatureCallMemberCallTargetAction_1_1_0_0_0()
						|| rule == grammarAccess.getXPrimaryExpressionRule()
						|| rule == grammarAccess.getXParenthesizedExpressionRule()
						|| rule == grammarAccess.getXBlockExpressionRule()
						|| rule == grammarAccess.getXExpressionOrVarDeclarationRule()) {
					sequence_XBlockExpression(context, (XBlockExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getXExpressionInClosureRule()) {
					sequence_XExpressionInClosure(context, (XBlockExpression) semanticObject); 
					return; 
				}
				else break;
			case XbasePackage.XBOOLEAN_LITERAL:
				sequence_XBooleanLiteral(context, (XBooleanLiteral) semanticObject); 
				return; 
			case XbasePackage.XCASE_PART:
				sequence_XCasePart(context, (XCasePart) semanticObject); 
				return; 
			case XbasePackage.XCASTED_EXPRESSION:
				sequence_XCastedExpression(context, (XCastedExpression) semanticObject); 
				return; 
			case XbasePackage.XCATCH_CLAUSE:
				sequence_XCatchClause(context, (XCatchClause) semanticObject); 
				return; 
			case XbasePackage.XCLOSURE:
				if (rule == grammarAccess.getXExpressionRule()
						|| rule == grammarAccess.getXAssignmentRule()
						|| action == grammarAccess.getXAssignmentAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOrExpressionRule()
						|| action == grammarAccess.getXOrExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAndExpressionRule()
						|| action == grammarAccess.getXAndExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXEqualityExpressionRule()
						|| action == grammarAccess.getXEqualityExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXRelationalExpressionRule()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXInstanceOfExpressionExpressionAction_1_0_0_0_0()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOtherOperatorExpressionRule()
						|| action == grammarAccess.getXOtherOperatorExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAdditiveExpressionRule()
						|| action == grammarAccess.getXAdditiveExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXMultiplicativeExpressionRule()
						|| action == grammarAccess.getXMultiplicativeExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXUnaryOperationRule()
						|| rule == grammarAccess.getXCastedExpressionRule()
						|| action == grammarAccess.getXCastedExpressionAccess().getXCastedExpressionTargetAction_1_0_0_0()
						|| rule == grammarAccess.getXPostfixOperationRule()
						|| action == grammarAccess.getXPostfixOperationAccess().getXPostfixOperationOperandAction_1_0_0()
						|| rule == grammarAccess.getXMemberFeatureCallRule()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXAssignmentAssignableAction_1_0_0_0_0()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXMemberFeatureCallMemberCallTargetAction_1_1_0_0_0()
						|| rule == grammarAccess.getXPrimaryExpressionRule()
						|| rule == grammarAccess.getXLiteralRule()
						|| rule == grammarAccess.getXClosureRule()
						|| rule == grammarAccess.getXParenthesizedExpressionRule()
						|| rule == grammarAccess.getXExpressionOrVarDeclarationRule()) {
					sequence_XClosure(context, (XClosure) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getXShortClosureRule()) {
					sequence_XShortClosure(context, (XClosure) semanticObject); 
					return; 
				}
				else break;
			case XbasePackage.XCONSTRUCTOR_CALL:
				sequence_XConstructorCall(context, (XConstructorCall) semanticObject); 
				return; 
			case XbasePackage.XDO_WHILE_EXPRESSION:
				sequence_XDoWhileExpression(context, (XDoWhileExpression) semanticObject); 
				return; 
			case XbasePackage.XFEATURE_CALL:
				sequence_XFeatureCall(context, (XFeatureCall) semanticObject); 
				return; 
			case XbasePackage.XFOR_LOOP_EXPRESSION:
				sequence_XForLoopExpression(context, (XForLoopExpression) semanticObject); 
				return; 
			case XbasePackage.XIF_EXPRESSION:
				sequence_XIfExpression(context, (XIfExpression) semanticObject); 
				return; 
			case XbasePackage.XINSTANCE_OF_EXPRESSION:
				sequence_XRelationalExpression(context, (XInstanceOfExpression) semanticObject); 
				return; 
			case XbasePackage.XLIST_LITERAL:
				sequence_XListLiteral(context, (XListLiteral) semanticObject); 
				return; 
			case XbasePackage.XMEMBER_FEATURE_CALL:
				sequence_XMemberFeatureCall(context, (XMemberFeatureCall) semanticObject); 
				return; 
			case XbasePackage.XNULL_LITERAL:
				sequence_XNullLiteral(context, (XNullLiteral) semanticObject); 
				return; 
			case XbasePackage.XNUMBER_LITERAL:
				sequence_XNumberLiteral(context, (XNumberLiteral) semanticObject); 
				return; 
			case XbasePackage.XPOSTFIX_OPERATION:
				sequence_XPostfixOperation(context, (XPostfixOperation) semanticObject); 
				return; 
			case XbasePackage.XRETURN_EXPRESSION:
				sequence_XReturnExpression(context, (XReturnExpression) semanticObject); 
				return; 
			case XbasePackage.XSET_LITERAL:
				sequence_XSetLiteral(context, (XSetLiteral) semanticObject); 
				return; 
			case XbasePackage.XSTRING_LITERAL:
				sequence_XStringLiteral(context, (XStringLiteral) semanticObject); 
				return; 
			case XbasePackage.XSWITCH_EXPRESSION:
				sequence_XSwitchExpression(context, (XSwitchExpression) semanticObject); 
				return; 
			case XbasePackage.XSYNCHRONIZED_EXPRESSION:
				sequence_XSynchronizedExpression(context, (XSynchronizedExpression) semanticObject); 
				return; 
			case XbasePackage.XTHROW_EXPRESSION:
				sequence_XThrowExpression(context, (XThrowExpression) semanticObject); 
				return; 
			case XbasePackage.XTRY_CATCH_FINALLY_EXPRESSION:
				sequence_XTryCatchFinallyExpression(context, (XTryCatchFinallyExpression) semanticObject); 
				return; 
			case XbasePackage.XTYPE_LITERAL:
				sequence_XTypeLiteral(context, (XTypeLiteral) semanticObject); 
				return; 
			case XbasePackage.XUNARY_OPERATION:
				sequence_XUnaryOperation(context, (XUnaryOperation) semanticObject); 
				return; 
			case XbasePackage.XVARIABLE_DECLARATION:
				sequence_XVariableDeclaration(context, (XVariableDeclaration) semanticObject); 
				return; 
			case XbasePackage.XWHILE_EXPRESSION:
				sequence_XWhileExpression(context, (XWhileExpression) semanticObject); 
				return; 
			}
		else if (epackage == XtypePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XtypePackage.XFUNCTION_TYPE_REF:
				sequence_XFunctionTypeRef(context, (XFunctionTypeRef) semanticObject); 
				return; 
			case XtypePackage.XIMPORT_DECLARATION:
				sequence_XImportDeclaration(context, (XImportDeclaration) semanticObject); 
				return; 
			case XtypePackage.XIMPORT_SECTION:
				sequence_XImportSection(context, (XImportSection) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     FormFieldElement returns BigDecimalElement
	 *     NamedTypeElement returns BigDecimalElement
	 *     ValueFieldElement returns BigDecimalElement
	 *     BigDecimalElement returns BigDecimalElement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             text=[TranslationElement|QualifiedName] | 
	 *             enabled=BooleanType | 
	 *             visible=BooleanType | 
	 *             percent=BooleanType | 
	 *             grouping=BooleanType | 
	 *             labelVisible=BooleanType | 
	 *             master=[ValueFieldElement|ID] | 
	 *             mandatory=BooleanType | 
	 *             gridWidth=INT | 
	 *             widthInPixels=INT | 
	 *             horizontalAlign=HorizontalAlignmentType | 
	 *             fractionDigits=INT | 
	 *             min=Number | 
	 *             max=Number | 
	 *             superType=[TemplateElement|ID]
	 *         )* 
	 *         logic+=LogicElement*
	 *     )
	 * </pre>
	 */
	protected void sequence_BigDecimalElement(ISerializationContext context, BigDecimalElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FormFieldElement returns ButtonElement
	 *     NamedTypeElement returns ButtonElement
	 *     ButtonElement returns ButtonElement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         text=[TranslationElement|QualifiedName]? 
	 *         (
	 *             (
	 *                 enabled=BooleanType | 
	 *                 visible=BooleanType | 
	 *                 processButton=BooleanType | 
	 *                 type='normal' | 
	 *                 type='cancel' | 
	 *                 type='close' | 
	 *                 type='ok' | 
	 *                 type='reset' | 
	 *                 type='save' | 
	 *                 gridWidth=INT | 
	 *                 widthInPixels=INT | 
	 *                 superType=[TemplateElement|ID]
	 *             )? 
	 *             text=[TranslationElement|QualifiedName]?
	 *         )* 
	 *         (logic+=LogicElement | menus+=MenuElement)*
	 *     )
	 * </pre>
	 */
	protected void sequence_ButtonElement(ISerializationContext context, ButtonElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FormFieldElement returns CheckboxElement
	 *     NamedTypeElement returns CheckboxElement
	 *     ValueFieldElement returns CheckboxElement
	 *     CheckboxElement returns CheckboxElement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             text=[TranslationElement|QualifiedName] | 
	 *             enabled=BooleanType | 
	 *             visible=BooleanType | 
	 *             gridWidth=INT | 
	 *             widthInPixels=INT | 
	 *             labelVisible=BooleanType | 
	 *             master=[ValueFieldElement|ID] | 
	 *             mandatory=BooleanType | 
	 *             superType=[TemplateElement|ID]
	 *         )* 
	 *         logic+=LogicElement*
	 *     )
	 * </pre>
	 */
	protected void sequence_CheckboxElement(ISerializationContext context, CheckboxElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CodeElement returns CodeElement
	 *     NamedTypeElement returns CodeElement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (id=STRING | valueType=STRING | text=[TranslationElement|QualifiedName] | superType=[TemplateElement|ID])* 
	 *         logic+=LogicElement? 
	 *         (codes+=CodeElement? logic+=LogicElement?)*
	 *     )
	 * </pre>
	 */
	protected void sequence_CodeElement(ISerializationContext context, CodeElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ColumnElement returns ColumnElement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             type='date' | 
	 *             type='string' | 
	 *             type='int' | 
	 *             type='bigdecimal' | 
	 *             text=[TranslationElement|QualifiedName] | 
	 *             width=INT | 
	 *             visible=BooleanType | 
	 *             displayable=BooleanType
	 *         )*
	 *     )
	 * </pre>
	 */
	protected void sequence_ColumnElement(ISerializationContext context, ColumnElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FormFieldElement returns CustomFieldElement
	 *     NamedTypeElement returns CustomFieldElement
	 *     CustomFieldElement returns CustomFieldElement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         superType=[TemplateElement|ID]? 
	 *         (
	 *             (
	 *                 text=[TranslationElement|QualifiedName] | 
	 *                 enabled=BooleanType | 
	 *                 visible=BooleanType | 
	 *                 labelVisible=BooleanType | 
	 *                 gridWidth=INT | 
	 *                 widthInPixels=INT
	 *             )? 
	 *             superType=[TemplateElement|ID]?
	 *         )* 
	 *         (logic+=LogicElement | fields+=FormFieldElement)*
	 *     )
	 * </pre>
	 */
	protected void sequence_CustomFieldElement(ISerializationContext context, CustomFieldElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FormFieldElement returns DateElement
	 *     NamedTypeElement returns DateElement
	 *     ValueFieldElement returns DateElement
	 *     DateElement returns DateElement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             text=[TranslationElement|QualifiedName] | 
	 *             enabled=BooleanType | 
	 *             visible=BooleanType | 
	 *             labelVisible=BooleanType | 
	 *             master=[ValueFieldElement|ID] | 
	 *             mandatory=BooleanType | 
	 *             gridWidth=INT | 
	 *             widthInPixels=INT | 
	 *             superType=[TemplateElement|ID]
	 *         )* 
	 *         logic+=LogicElement*
	 *     )
	 * </pre>
	 */
	protected void sequence_DateElement(ISerializationContext context, DateElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FormFieldElement returns FileChooserElement
	 *     NamedTypeElement returns FileChooserElement
	 *     ValueFieldElement returns FileChooserElement
	 *     FileChooserElement returns FileChooserElement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             text=[TranslationElement|QualifiedName] | 
	 *             enabled=BooleanType | 
	 *             visible=BooleanType | 
	 *             gridWidth=INT | 
	 *             widthInPixels=INT | 
	 *             labelVisible=BooleanType | 
	 *             master=[ValueFieldElement|ID] | 
	 *             mandatory=BooleanType | 
	 *             maxlen=INT | 
	 *             mode='directory' | 
	 *             mode='file' | 
	 *             type='load' | 
	 *             type='store' | 
	 *             extensions=STRING | 
	 *             defaultDirectory=STRING | 
	 *             showDirectory=BooleanType | 
	 *             showFileName=BooleanType | 
	 *             showFileExtension=BooleanType | 
	 *             superType=[TemplateElement|ID]
	 *         )* 
	 *         logic+=LogicElement*
	 *     )
	 * </pre>
	 */
	protected void sequence_FileChooserElement(ISerializationContext context, FileChooserElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FormElement returns FormElement
	 *     NamedTypeElement returns FormElement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             modal=BooleanType | 
	 *             columns=INT | 
	 *             title=[TranslationElement|QualifiedName] | 
	 *             subtitle=[TranslationElement|QualifiedName] | 
	 *             widthInPixels=INT | 
	 *             superType=[TemplateElement|ID] | 
	 *             svcSuperType=[TemplateElement|ID]
	 *         )* 
	 *         logic+=LogicElement? 
	 *         ((fields+=FormFieldElement | keyStrokes+=KeyElement)? logic+=LogicElement?)*
	 *     )
	 * </pre>
	 */
	protected void sequence_FormElement(ISerializationContext context, FormElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FormFieldElement returns GroupBoxElement
	 *     NamedTypeElement returns GroupBoxElement
	 *     CompositeFieldElement returns GroupBoxElement
	 *     GroupBoxElement returns GroupBoxElement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         text=[TranslationElement|QualifiedName]? 
	 *         (
	 *             (
	 *                 columns=INT | 
	 *                 enabled=BooleanType | 
	 *                 visible=BooleanType | 
	 *                 labelVisible=BooleanType | 
	 *                 borderVisible=BooleanType | 
	 *                 borderDecoration='empty' | 
	 *                 borderDecoration='line' | 
	 *                 borderDecoration='section' | 
	 *                 borderDecoration='auto' | 
	 *                 gridHeight=INT | 
	 *                 gridWidth=INT | 
	 *                 widthInPixels=INT | 
	 *                 superType=[TemplateElement|ID]
	 *             )? 
	 *             text=[TranslationElement|QualifiedName]?
	 *         )* 
	 *         (logic+=LogicElement | fields+=FormFieldElement)*
	 *     )
	 * </pre>
	 */
	protected void sequence_GroupBoxElement(ISerializationContext context, GroupBoxElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ImportElement returns ImportElement
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildCard_1
	 * </pre>
	 */
	protected void sequence_ImportElement(ISerializationContext context, ImportElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SamlPackage.Literals.IMPORT_ELEMENT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SamlPackage.Literals.IMPORT_ELEMENT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportElementAccess().getImportedNamespaceQualifiedNameWithWildCard_1ParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     KeyElement returns KeyElement
	 *
	 * Constraint:
	 *     (name=ID stroke=STRING logic+=LogicElement+)
	 * </pre>
	 */
	protected void sequence_KeyElement(ISerializationContext context, KeyElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LanguageAttribute returns LanguageAttribute
	 *
	 * Constraint:
	 *     (lang=ID text=STRING)
	 * </pre>
	 */
	protected void sequence_LanguageAttribute(ISerializationContext context, LanguageAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SamlPackage.Literals.LANGUAGE_ATTRIBUTE__LANG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SamlPackage.Literals.LANGUAGE_ATTRIBUTE__LANG));
			if (transientValues.isValueTransient(semanticObject, SamlPackage.Literals.LANGUAGE_ATTRIBUTE__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SamlPackage.Literals.LANGUAGE_ATTRIBUTE__TEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLanguageAttributeAccess().getLangIDTerminalRuleCall_0_0(), semanticObject.getLang());
		feeder.accept(grammarAccess.getLanguageAttributeAccess().getTextSTRINGTerminalRuleCall_2_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FormFieldElement returns ListBoxElement
	 *     NamedTypeElement returns ListBoxElement
	 *     GenericValueFieldElement returns ListBoxElement
	 *     ValueFieldElement returns ListBoxElement
	 *     ListBoxElement returns ListBoxElement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             text=[TranslationElement|QualifiedName] | 
	 *             enabled=BooleanType | 
	 *             visible=BooleanType | 
	 *             labelVisible=BooleanType | 
	 *             master=[ValueFieldElement|ID] | 
	 *             mandatory=BooleanType | 
	 *             code=[CodeElement|ID] | 
	 *             valueType=STRING | 
	 *             lookup=[LookupElement|ID] | 
	 *             gridWidth=INT | 
	 *             widthInPixels=INT | 
	 *             gridHeight=INT | 
	 *             superType=[TemplateElement|ID]
	 *         )* 
	 *         logic+=LogicElement*
	 *     )
	 * </pre>
	 */
	protected void sequence_ListBoxElement(ISerializationContext context, ListBoxElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicElement returns LogicElement
	 *
	 * Constraint:
	 *     (name=ID? (event=LogicEventType | placement='client' | placement='server' | placement='inline' | exec=[LogicElement|ID])* source=STRING?)
	 * </pre>
	 */
	protected void sequence_LogicElement(ISerializationContext context, LogicElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FormFieldElement returns LongElement
	 *     NamedTypeElement returns LongElement
	 *     ValueFieldElement returns LongElement
	 *     LongElement returns LongElement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             text=[TranslationElement|QualifiedName] | 
	 *             enabled=BooleanType | 
	 *             visible=BooleanType | 
	 *             labelVisible=BooleanType | 
	 *             master=[ValueFieldElement|ID] | 
	 *             mandatory=BooleanType | 
	 *             gridWidth=INT | 
	 *             widthInPixels=INT | 
	 *             horizontalAlign=HorizontalAlignmentType | 
	 *             min=INT | 
	 *             max=INT | 
	 *             superType=[TemplateElement|ID]
	 *         )* 
	 *         logic+=LogicElement*
	 *     )
	 * </pre>
	 */
	protected void sequence_LongElement(ISerializationContext context, LongElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LookupElement returns LookupElement
	 *
	 * Constraint:
	 *     (name=ID logic+=LogicElement*)
	 * </pre>
	 */
	protected void sequence_LookupElement(ISerializationContext context, LookupElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MenuElement returns MenuElement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             enabled=BooleanType | 
	 *             visible=BooleanType | 
	 *             singleSelect=BooleanType | 
	 *             multiSelect=BooleanType | 
	 *             emptySelect=BooleanType | 
	 *             type='normal' | 
	 *             type='separator' | 
	 *             type='cancel' | 
	 *             text=[TranslationElement|QualifiedName] | 
	 *             superType=[TemplateElement|ID]
	 *         )* 
	 *         logic+=LogicElement? 
	 *         (menus+=MenuElement? logic+=LogicElement?)*
	 *     )
	 * </pre>
	 */
	protected void sequence_MenuElement(ISerializationContext context, MenuElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (
	 *         module=ModuleElement 
	 *         imports+=ImportElement* 
	 *         (
	 *             translations+=TranslationElement | 
	 *             codes+=CodeElement | 
	 *             lookups+=LookupElement | 
	 *             templates+=TemplateElement | 
	 *             forms+=FormElement | 
	 *             logics+=LogicElement
	 *         )*
	 *     )
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ModuleElement returns ModuleElement
	 *
	 * Constraint:
	 *     (name=QualifiedName (client=QualifiedName | shared=QualifiedName | server=QualifiedName)*)
	 * </pre>
	 */
	protected void sequence_ModuleElement(ISerializationContext context, ModuleElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NamedTypeElement returns RadioButtonElement
	 *     RadioButtonElement returns RadioButtonElement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (text=[TranslationElement|QualifiedName] | value=STRING | enabled=BooleanType | visible=BooleanType | superType=[TemplateElement|ID])*
	 *     )
	 * </pre>
	 */
	protected void sequence_RadioButtonElement(ISerializationContext context, RadioButtonElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FormFieldElement returns RadioGroupElement
	 *     NamedTypeElement returns RadioGroupElement
	 *     GenericValueFieldElement returns RadioGroupElement
	 *     ValueFieldElement returns RadioGroupElement
	 *     RadioGroupElement returns RadioGroupElement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         text=[TranslationElement|QualifiedName]? 
	 *         (
	 *             (
	 *                 enabled=BooleanType | 
	 *                 visible=BooleanType | 
	 *                 gridWidth=INT | 
	 *                 widthInPixels=INT | 
	 *                 labelVisible=BooleanType | 
	 *                 master=[ValueFieldElement|ID] | 
	 *                 mandatory=BooleanType | 
	 *                 valueType=STRING | 
	 *                 superType=[TemplateElement|ID]
	 *             )? 
	 *             text=[TranslationElement|QualifiedName]?
	 *         )* 
	 *         (logic+=LogicElement | options+=RadioButtonElement)+
	 *     )
	 * </pre>
	 */
	protected void sequence_RadioGroupElement(ISerializationContext context, RadioGroupElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FormFieldElement returns SequenceBoxElement
	 *     NamedTypeElement returns SequenceBoxElement
	 *     CompositeFieldElement returns SequenceBoxElement
	 *     SequenceBoxElement returns SequenceBoxElement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         text=[TranslationElement|QualifiedName]? 
	 *         (
	 *             (
	 *                 enabled=BooleanType | 
	 *                 visible=BooleanType | 
	 *                 labelVisible=BooleanType | 
	 *                 gridWidth=INT | 
	 *                 widthInPixels=INT | 
	 *                 superType=[TemplateElement|ID]
	 *             )? 
	 *             text=[TranslationElement|QualifiedName]?
	 *         )* 
	 *         (logic+=LogicElement | fields+=FormFieldElement)*
	 *     )
	 * </pre>
	 */
	protected void sequence_SequenceBoxElement(ISerializationContext context, SequenceBoxElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FormFieldElement returns SmartfieldElement
	 *     NamedTypeElement returns SmartfieldElement
	 *     GenericValueFieldElement returns SmartfieldElement
	 *     ValueFieldElement returns SmartfieldElement
	 *     SmartfieldElement returns SmartfieldElement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         text=[TranslationElement|QualifiedName]? 
	 *         (
	 *             (
	 *                 enabled=BooleanType | 
	 *                 visible=BooleanType | 
	 *                 labelVisible=BooleanType | 
	 *                 master=[ValueFieldElement|ID] | 
	 *                 mandatory=BooleanType | 
	 *                 code=[CodeElement|ID] | 
	 *                 valueType=STRING | 
	 *                 lookup=[LookupElement|ID] | 
	 *                 gridWidth=INT | 
	 *                 widthInPixels=INT | 
	 *                 superType=[TemplateElement|ID]
	 *             )? 
	 *             text=[TranslationElement|QualifiedName]?
	 *         )* 
	 *         (logic+=LogicElement | menus+=MenuElement)*
	 *     )
	 * </pre>
	 */
	protected void sequence_SmartfieldElement(ISerializationContext context, SmartfieldElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FormFieldElement returns StringElement
	 *     NamedTypeElement returns StringElement
	 *     ValueFieldElement returns StringElement
	 *     StringElement returns StringElement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             text=[TranslationElement|QualifiedName] | 
	 *             enabled=BooleanType | 
	 *             visible=BooleanType | 
	 *             labelVisible=BooleanType | 
	 *             master=[ValueFieldElement|ID] | 
	 *             mandatory=BooleanType | 
	 *             maxlen=INT | 
	 *             gridHeight=INT | 
	 *             gridWidth=INT | 
	 *             widthInPixels=INT | 
	 *             horizontalAlign=HorizontalAlignmentType | 
	 *             superType=[TemplateElement|ID]
	 *         )* 
	 *         logic+=LogicElement*
	 *     )
	 * </pre>
	 */
	protected void sequence_StringElement(ISerializationContext context, StringElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FormFieldElement returns TabBoxElement
	 *     NamedTypeElement returns TabBoxElement
	 *     TabBoxElement returns TabBoxElement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         enabled=BooleanType? 
	 *         ((visible=BooleanType | gridWidth=INT | widthInPixels=INT | superType=[TemplateElement|ID])? enabled=BooleanType?)* 
	 *         (logic+=LogicElement | tabs+=TabElement)*
	 *     )
	 * </pre>
	 */
	protected void sequence_TabBoxElement(ISerializationContext context, TabBoxElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FormFieldElement returns TabElement
	 *     NamedTypeElement returns TabElement
	 *     CompositeFieldElement returns TabElement
	 *     TabElement returns TabElement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         text=[TranslationElement|QualifiedName]? 
	 *         ((columns=INT | enabled=BooleanType | visible=BooleanType | superType=[TemplateElement|ID])? text=[TranslationElement|QualifiedName]?)* 
	 *         (logic+=LogicElement | fields+=FormFieldElement)*
	 *     )
	 * </pre>
	 */
	protected void sequence_TabElement(ISerializationContext context, TabElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FormFieldElement returns TableElement
	 *     NamedTypeElement returns TableElement
	 *     TableElement returns TableElement
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         text=[TranslationElement|QualifiedName]? 
	 *         (
	 *             (
	 *                 enabled=BooleanType | 
	 *                 visible=BooleanType | 
	 *                 labelVisible=BooleanType | 
	 *                 gridHeight=INT | 
	 *                 gridWidth=INT | 
	 *                 widthInPixels=INT | 
	 *                 superType=[TemplateElement|ID]
	 *             )? 
	 *             text=[TranslationElement|QualifiedName]?
	 *         )* 
	 *         (logic+=LogicElement | menus+=MenuElement | columns+=ColumnElement)*
	 *     )
	 * </pre>
	 */
	protected void sequence_TableElement(ISerializationContext context, TableElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TemplateElement returns TemplateElement
	 *
	 * Constraint:
	 *     (name=ID definition=STRING)
	 * </pre>
	 */
	protected void sequence_TemplateElement(ISerializationContext context, TemplateElement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SamlPackage.Literals.TEMPLATE_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SamlPackage.Literals.TEMPLATE_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, SamlPackage.Literals.TEMPLATE_ELEMENT__DEFINITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SamlPackage.Literals.TEMPLATE_ELEMENT__DEFINITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTemplateElementAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTemplateElementAccess().getDefinitionSTRINGTerminalRuleCall_4_0(), semanticObject.getDefinition());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TranslationElement returns TranslationElement
	 *
	 * Constraint:
	 *     (name=QualifiedName translations+=LanguageAttribute+)
	 * </pre>
	 */
	protected void sequence_TranslationElement(ISerializationContext context, TranslationElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}

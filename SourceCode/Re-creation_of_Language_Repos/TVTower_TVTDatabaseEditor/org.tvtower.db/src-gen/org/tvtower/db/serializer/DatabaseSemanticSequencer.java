/*
 * generated by Xtext 2.35.0
 */
package org.tvtower.db.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.tvtower.db.database.Achievement;
import org.tvtower.db.database.AchievementData;
import org.tvtower.db.database.Achievements;
import org.tvtower.db.database.AdConditions;
import org.tvtower.db.database.Advertisement;
import org.tvtower.db.database.AdvertisementData;
import org.tvtower.db.database.Advertisements;
import org.tvtower.db.database.Availability;
import org.tvtower.db.database.Blocks;
import org.tvtower.db.database.CelebrityPeople;
import org.tvtower.db.database.Database;
import org.tvtower.db.database.DatabasePackage;
import org.tvtower.db.database.Description;
import org.tvtower.db.database.Effect;
import org.tvtower.db.database.Effects;
import org.tvtower.db.database.Episodes;
import org.tvtower.db.database.ExportOptions;
import org.tvtower.db.database.GroupAttractivity;
import org.tvtower.db.database.InsignificantPeople;
import org.tvtower.db.database.Job;
import org.tvtower.db.database.Jobs;
import org.tvtower.db.database.LanguageString;
import org.tvtower.db.database.MinMaxSlope;
import org.tvtower.db.database.Modifier;
import org.tvtower.db.database.Modifiers;
import org.tvtower.db.database.News;
import org.tvtower.db.database.NewsData;
import org.tvtower.db.database.NewsItem;
import org.tvtower.db.database.Outcome;
import org.tvtower.db.database.Person;
import org.tvtower.db.database.PersonData;
import org.tvtower.db.database.PersonDetails;
import org.tvtower.db.database.PersonLocale;
import org.tvtower.db.database.PersonLocalization;
import org.tvtower.db.database.Potential;
import org.tvtower.db.database.Price;
import org.tvtower.db.database.ProductionTime;
import org.tvtower.db.database.Programme;
import org.tvtower.db.database.ProgrammeChildren;
import org.tvtower.db.database.ProgrammeData;
import org.tvtower.db.database.ProgrammeGroups;
import org.tvtower.db.database.ProgrammeRatings;
import org.tvtower.db.database.ProgrammeReleaseTime;
import org.tvtower.db.database.ProgrammeRole;
import org.tvtower.db.database.ProgrammeRoles;
import org.tvtower.db.database.Programmes;
import org.tvtower.db.database.Review;
import org.tvtower.db.database.Reward;
import org.tvtower.db.database.RewardData;
import org.tvtower.db.database.Rewards;
import org.tvtower.db.database.RoleLocale;
import org.tvtower.db.database.ScriptChildren;
import org.tvtower.db.database.ScriptData;
import org.tvtower.db.database.ScriptGenres;
import org.tvtower.db.database.ScriptTemplate;
import org.tvtower.db.database.ScriptTemplates;
import org.tvtower.db.database.Speed;
import org.tvtower.db.database.Staff;
import org.tvtower.db.database.StaffMember;
import org.tvtower.db.database.StudioSize;
import org.tvtower.db.database.Task;
import org.tvtower.db.database.TaskData;
import org.tvtower.db.database.Tasks;
import org.tvtower.db.database.Text;
import org.tvtower.db.database.Title;
import org.tvtower.db.database.TitleOriginal;
import org.tvtower.db.database.UnnamedProperty;
import org.tvtower.db.database.VariableDef;
import org.tvtower.db.database.Variables;
import org.tvtower.db.database.Version;
import org.tvtower.db.services.DatabaseGrammarAccess;

@SuppressWarnings("all")
public class DatabaseSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DatabaseGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DatabasePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DatabasePackage.ACHIEVEMENT:
				sequence_Achievement(context, (Achievement) semanticObject); 
				return; 
			case DatabasePackage.ACHIEVEMENT_DATA:
				sequence_AchievementData(context, (AchievementData) semanticObject); 
				return; 
			case DatabasePackage.ACHIEVEMENTS:
				sequence_Achievements(context, (Achievements) semanticObject); 
				return; 
			case DatabasePackage.AD_CONDITIONS:
				sequence_AdConditions(context, (AdConditions) semanticObject); 
				return; 
			case DatabasePackage.ADVERTISEMENT:
				sequence_Advertisement(context, (Advertisement) semanticObject); 
				return; 
			case DatabasePackage.ADVERTISEMENT_DATA:
				sequence_AdvertisementData(context, (AdvertisementData) semanticObject); 
				return; 
			case DatabasePackage.ADVERTISEMENTS:
				sequence_Advertisements(context, (Advertisements) semanticObject); 
				return; 
			case DatabasePackage.AVAILABILITY:
				sequence_Availability(context, (Availability) semanticObject); 
				return; 
			case DatabasePackage.BLOCKS:
				sequence_Blocks(context, (Blocks) semanticObject); 
				return; 
			case DatabasePackage.CELEBRITY_PEOPLE:
				sequence_CelebrityPeople(context, (CelebrityPeople) semanticObject); 
				return; 
			case DatabasePackage.DATABASE:
				sequence_Database(context, (Database) semanticObject); 
				return; 
			case DatabasePackage.DESCRIPTION:
				sequence_Description(context, (Description) semanticObject); 
				return; 
			case DatabasePackage.EFFECT:
				sequence_Effect(context, (Effect) semanticObject); 
				return; 
			case DatabasePackage.EFFECTS:
				sequence_Effects(context, (Effects) semanticObject); 
				return; 
			case DatabasePackage.EPISODES:
				sequence_Episodes(context, (Episodes) semanticObject); 
				return; 
			case DatabasePackage.EXPORT_OPTIONS:
				sequence_ExportOptions(context, (ExportOptions) semanticObject); 
				return; 
			case DatabasePackage.GROUP_ATTRACTIVITY:
				sequence_GroupAttractivity(context, (GroupAttractivity) semanticObject); 
				return; 
			case DatabasePackage.INSIGNIFICANT_PEOPLE:
				sequence_InsignificantPeople(context, (InsignificantPeople) semanticObject); 
				return; 
			case DatabasePackage.JOB:
				sequence_Job(context, (Job) semanticObject); 
				return; 
			case DatabasePackage.JOBS:
				sequence_Jobs(context, (Jobs) semanticObject); 
				return; 
			case DatabasePackage.LANGUAGE_STRING:
				sequence_LanguageString(context, (LanguageString) semanticObject); 
				return; 
			case DatabasePackage.MIN_MAX_SLOPE:
				sequence_MinMaxSlope(context, (MinMaxSlope) semanticObject); 
				return; 
			case DatabasePackage.MODIFIER:
				sequence_Modifier(context, (Modifier) semanticObject); 
				return; 
			case DatabasePackage.MODIFIERS:
				if (rule == grammarAccess.getModifiersRule()) {
					sequence_Modifiers(context, (Modifiers) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTemplateProgrammeModifiersRule()) {
					sequence_TemplateProgrammeModifiers(context, (Modifiers) semanticObject); 
					return; 
				}
				else break;
			case DatabasePackage.NEWS:
				sequence_News(context, (News) semanticObject); 
				return; 
			case DatabasePackage.NEWS_DATA:
				sequence_NewsData(context, (NewsData) semanticObject); 
				return; 
			case DatabasePackage.NEWS_ITEM:
				sequence_NewsItem(context, (NewsItem) semanticObject); 
				return; 
			case DatabasePackage.OUTCOME:
				sequence_Outcome(context, (Outcome) semanticObject); 
				return; 
			case DatabasePackage.PERSON:
				sequence_Person(context, (Person) semanticObject); 
				return; 
			case DatabasePackage.PERSON_DATA:
				sequence_PersonData(context, (PersonData) semanticObject); 
				return; 
			case DatabasePackage.PERSON_DETAILS:
				sequence_PersonDetails(context, (PersonDetails) semanticObject); 
				return; 
			case DatabasePackage.PERSON_LOCALE:
				sequence_PersonLocale(context, (PersonLocale) semanticObject); 
				return; 
			case DatabasePackage.PERSON_LOCALIZATION:
				sequence_PersonLocalization(context, (PersonLocalization) semanticObject); 
				return; 
			case DatabasePackage.POTENTIAL:
				sequence_Potential(context, (Potential) semanticObject); 
				return; 
			case DatabasePackage.PRICE:
				sequence_Price(context, (Price) semanticObject); 
				return; 
			case DatabasePackage.PRODUCTION_TIME:
				sequence_ProductionTime(context, (ProductionTime) semanticObject); 
				return; 
			case DatabasePackage.PROGRAMME:
				sequence_Programme(context, (Programme) semanticObject); 
				return; 
			case DatabasePackage.PROGRAMME_CHILDREN:
				sequence_ProgrammeChildren(context, (ProgrammeChildren) semanticObject); 
				return; 
			case DatabasePackage.PROGRAMME_DATA:
				sequence_ProgrammeData(context, (ProgrammeData) semanticObject); 
				return; 
			case DatabasePackage.PROGRAMME_GROUPS:
				sequence_ProgrammeGroups(context, (ProgrammeGroups) semanticObject); 
				return; 
			case DatabasePackage.PROGRAMME_RATINGS:
				sequence_ProgrammeRatings(context, (ProgrammeRatings) semanticObject); 
				return; 
			case DatabasePackage.PROGRAMME_RELEASE_TIME:
				sequence_ProgrammeReleaseTime(context, (ProgrammeReleaseTime) semanticObject); 
				return; 
			case DatabasePackage.PROGRAMME_ROLE:
				sequence_ProgrammeRole(context, (ProgrammeRole) semanticObject); 
				return; 
			case DatabasePackage.PROGRAMME_ROLES:
				sequence_ProgrammeRoles(context, (ProgrammeRoles) semanticObject); 
				return; 
			case DatabasePackage.PROGRAMMES:
				sequence_Programmes(context, (Programmes) semanticObject); 
				return; 
			case DatabasePackage.REVIEW:
				sequence_Review(context, (Review) semanticObject); 
				return; 
			case DatabasePackage.REWARD:
				sequence_Reward(context, (Reward) semanticObject); 
				return; 
			case DatabasePackage.REWARD_DATA:
				sequence_RewardData(context, (RewardData) semanticObject); 
				return; 
			case DatabasePackage.REWARDS:
				sequence_Rewards(context, (Rewards) semanticObject); 
				return; 
			case DatabasePackage.ROLE_LOCALE:
				sequence_RoleLocale(context, (RoleLocale) semanticObject); 
				return; 
			case DatabasePackage.SCRIPT_CHILDREN:
				sequence_ScriptChildren(context, (ScriptChildren) semanticObject); 
				return; 
			case DatabasePackage.SCRIPT_DATA:
				sequence_ScriptData(context, (ScriptData) semanticObject); 
				return; 
			case DatabasePackage.SCRIPT_GENRES:
				sequence_ScriptGenres(context, (ScriptGenres) semanticObject); 
				return; 
			case DatabasePackage.SCRIPT_TEMPLATE:
				sequence_ScriptTemplate(context, (ScriptTemplate) semanticObject); 
				return; 
			case DatabasePackage.SCRIPT_TEMPLATES:
				sequence_ScriptTemplates(context, (ScriptTemplates) semanticObject); 
				return; 
			case DatabasePackage.SPEED:
				sequence_Speed(context, (Speed) semanticObject); 
				return; 
			case DatabasePackage.STAFF:
				sequence_Staff(context, (Staff) semanticObject); 
				return; 
			case DatabasePackage.STAFF_MEMBER:
				sequence_StaffMember(context, (StaffMember) semanticObject); 
				return; 
			case DatabasePackage.STUDIO_SIZE:
				sequence_StudioSize(context, (StudioSize) semanticObject); 
				return; 
			case DatabasePackage.TASK:
				sequence_Task(context, (Task) semanticObject); 
				return; 
			case DatabasePackage.TASK_DATA:
				sequence_TaskData(context, (TaskData) semanticObject); 
				return; 
			case DatabasePackage.TASKS:
				sequence_Tasks(context, (Tasks) semanticObject); 
				return; 
			case DatabasePackage.TEXT:
				sequence_Text(context, (Text) semanticObject); 
				return; 
			case DatabasePackage.TITLE:
				sequence_Title(context, (Title) semanticObject); 
				return; 
			case DatabasePackage.TITLE_ORIGINAL:
				sequence_TitleOriginal(context, (TitleOriginal) semanticObject); 
				return; 
			case DatabasePackage.UNNAMED_PROPERTY:
				sequence_UnnamedProperty(context, (UnnamedProperty) semanticObject); 
				return; 
			case DatabasePackage.VARIABLE_DEF:
				sequence_VariableDef(context, (VariableDef) semanticObject); 
				return; 
			case DatabasePackage.VARIABLES:
				sequence_Variables(context, (Variables) semanticObject); 
				return; 
			case DatabasePackage.VERSION:
				sequence_Version(context, (Version) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     AchievementData returns AchievementData
	 *
	 * Constraint:
	 *     (
	 *         flags=STRING | 
	 *         group=STRING | 
	 *         category=STRING | 
	 *         spriteFinished=STRING | 
	 *         spriteUnfinished=STRING | 
	 *         index=STRING
	 *     )+
	 * </pre>
	 */
	protected void sequence_AchievementData(ISerializationContext context, AchievementData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Achievement returns Achievement
	 *
	 * Constraint:
	 *     (
	 *         name=STRING? 
	 *         ((comment=STRING | creator=STRING | createdBy=STRING)? name=STRING?)* 
	 *         (title=Title | text=Text | tasks=Tasks | rewards=Rewards | data=AchievementData)*
	 *     )
	 * </pre>
	 */
	protected void sequence_Achievement(ISerializationContext context, Achievement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Definition returns Achievements
	 *     Achievements returns Achievements
	 *
	 * Constraint:
	 *     achievements+=Achievement*
	 * </pre>
	 */
	protected void sequence_Achievements(ISerializationContext context, Achievements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdConditions returns AdConditions
	 *
	 * Constraint:
	 *     (
	 *         minAudience=STRING | 
	 *         minImage=STRING | 
	 *         maxImage=STRING | 
	 *         allowedGenre=STRING | 
	 *         prohibitedGenre=STRING | 
	 *         allowedProgrammeFlag=STRING | 
	 *         prohibitedProgrammeFlag=STRING | 
	 *         targetGroup=STRING | 
	 *         allowedProgrammeType=STRING | 
	 *         prohibitedProgrammeType=STRING | 
	 *         proPressureGroup=STRING | 
	 *         contraPressureGroup=STRING
	 *     )*
	 * </pre>
	 */
	protected void sequence_AdConditions(ISerializationContext context, AdConditions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AdvertisementData returns AdvertisementData
	 *
	 * Constraint:
	 *     (
	 *         quality=STRING | 
	 *         available=STRING | 
	 *         type=STRING | 
	 *         repetitions=STRING | 
	 *         duration=STRING | 
	 *         profit=STRING | 
	 *         fixPrice=STRING | 
	 *         penalty=STRING | 
	 *         infomercial=STRING | 
	 *         blocks=STRING | 
	 *         infomercialProfit=STRING | 
	 *         fixInfomercialProfit=STRING | 
	 *         proPressureGroup=STRING | 
	 *         contraPressureGroup=STRING
	 *     )*
	 * </pre>
	 */
	protected void sequence_AdvertisementData(ISerializationContext context, AdvertisementData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Advertisement returns Advertisement
	 *
	 * Constraint:
	 *     (
	 *         name=STRING? 
	 *         ((comment=STRING | creator=STRING | createdBy=STRING)? name=STRING?)* 
	 *         (
	 *             title=Title | 
	 *             description=Description | 
	 *             conditions=AdConditions | 
	 *             data=AdvertisementData | 
	 *             availability=Availability | 
	 *             modifiers=Modifiers
	 *         )*
	 *     )
	 * </pre>
	 */
	protected void sequence_Advertisement(ISerializationContext context, Advertisement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Definition returns Advertisements
	 *     Advertisements returns Advertisements
	 *
	 * Constraint:
	 *     ads+=Advertisement*
	 * </pre>
	 */
	protected void sequence_Advertisements(ISerializationContext context, Advertisements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Availability returns Availability
	 *
	 * Constraint:
	 *     (script=STRING | yearFrom=STRING | yearTo=STRING)*
	 * </pre>
	 */
	protected void sequence_Availability(ISerializationContext context, Availability semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContainsMinMaxSlope returns Blocks
	 *     Blocks returns Blocks
	 *
	 * Constraint:
	 *     data=MinMaxSlope
	 * </pre>
	 */
	protected void sequence_Blocks(ISerializationContext context, Blocks semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatabasePackage.Literals.CONTAINS_MIN_MAX_SLOPE__DATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatabasePackage.Literals.CONTAINS_MIN_MAX_SLOPE__DATA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBlocksAccess().getDataMinMaxSlopeParserRuleCall_2_0(), semanticObject.getData());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Definition returns CelebrityPeople
	 *     CelebrityPeople returns CelebrityPeople
	 *
	 * Constraint:
	 *     persons+=Person*
	 * </pre>
	 */
	protected void sequence_CelebrityPeople(ISerializationContext context, CelebrityPeople semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Database returns Database
	 *
	 * Constraint:
	 *     (
	 *         properties+=UnnamedProperty* 
	 *         (personLocalization=PersonLocalization | (version=Version? definitions+=Definition* exportOptions=ExportOptions?))?
	 *     )
	 * </pre>
	 */
	protected void sequence_Database(ISerializationContext context, Database semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContainsLanguageStrings returns Description
	 *     Description returns Description
	 *
	 * Constraint:
	 *     lstrings+=LanguageString*
	 * </pre>
	 */
	protected void sequence_Description(ISerializationContext context, Description semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Effect returns Effect
	 *
	 * Constraint:
	 *     (
	 *         trigger=STRING | 
	 *         type=STRING | 
	 *         news=[NewsItem|STRING] | 
	 *         genre=STRING | 
	 *         choose=STRING | 
	 *         guid=[EObject|STRING] | 
	 *         valueMin=STRING | 
	 *         valueMax=STRING | 
	 *         probability=STRING | 
	 *         news1=[NewsItem|STRING] | 
	 *         probability1=STRING | 
	 *         news2=[NewsItem|STRING] | 
	 *         probability2=STRING | 
	 *         news3=[NewsItem|STRING] | 
	 *         probability3=STRING | 
	 *         news4=[NewsItem|STRING] | 
	 *         probability4=STRING | 
	 *         enable=STRING | 
	 *         time=STRING
	 *     )*
	 * </pre>
	 */
	protected void sequence_Effect(ISerializationContext context, Effect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Effects returns Effects
	 *
	 * Constraint:
	 *     effects+=Effect*
	 * </pre>
	 */
	protected void sequence_Effects(ISerializationContext context, Effects semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContainsMinMaxSlope returns Episodes
	 *     Episodes returns Episodes
	 *
	 * Constraint:
	 *     data=MinMaxSlope
	 * </pre>
	 */
	protected void sequence_Episodes(ISerializationContext context, Episodes semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatabasePackage.Literals.CONTAINS_MIN_MAX_SLOPE__DATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatabasePackage.Literals.CONTAINS_MIN_MAX_SLOPE__DATA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEpisodesAccess().getDataMinMaxSlopeParserRuleCall_2_0(), semanticObject.getData());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExportOptions returns ExportOptions
	 *
	 * Constraint:
	 *     data+=UnnamedProperty*
	 * </pre>
	 */
	protected void sequence_ExportOptions(ISerializationContext context, ExportOptions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GroupAttractivity returns GroupAttractivity
	 *
	 * Constraint:
	 *     data+=UnnamedProperty*
	 * </pre>
	 */
	protected void sequence_GroupAttractivity(ISerializationContext context, GroupAttractivity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Definition returns InsignificantPeople
	 *     InsignificantPeople returns InsignificantPeople
	 *
	 * Constraint:
	 *     persons+=Person*
	 * </pre>
	 */
	protected void sequence_InsignificantPeople(ISerializationContext context, InsignificantPeople semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Job returns Job
	 *
	 * Constraint:
	 *     (index=STRING | function=STRING | required=STRING | gender=STRING | rolId=[ProgrammeRole|STRING])+
	 * </pre>
	 */
	protected void sequence_Job(ISerializationContext context, Job semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Jobs returns Jobs
	 *
	 * Constraint:
	 *     job+=Job*
	 * </pre>
	 */
	protected void sequence_Jobs(ISerializationContext context, Jobs semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LanguageString returns LanguageString
	 *
	 * Constraint:
	 *     (langage=ID text=TextContent langage2=ID)
	 * </pre>
	 */
	protected void sequence_LanguageString(ISerializationContext context, LanguageString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatabasePackage.Literals.LANGUAGE_STRING__LANGAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatabasePackage.Literals.LANGUAGE_STRING__LANGAGE));
			if (transientValues.isValueTransient(semanticObject, DatabasePackage.Literals.LANGUAGE_STRING__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatabasePackage.Literals.LANGUAGE_STRING__TEXT));
			if (transientValues.isValueTransient(semanticObject, DatabasePackage.Literals.LANGUAGE_STRING__LANGAGE2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatabasePackage.Literals.LANGUAGE_STRING__LANGAGE2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLanguageStringAccess().getLangageIDTerminalRuleCall_1_0(), semanticObject.getLangage());
		feeder.accept(grammarAccess.getLanguageStringAccess().getTextTextContentParserRuleCall_3_0(), semanticObject.getText());
		feeder.accept(grammarAccess.getLanguageStringAccess().getLangage2IDTerminalRuleCall_5_0(), semanticObject.getLangage2());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MinMaxSlope returns MinMaxSlope
	 *
	 * Constraint:
	 *     (value=STRING | (min=STRING | max=STRING | slope=STRING)+)
	 * </pre>
	 */
	protected void sequence_MinMaxSlope(ISerializationContext context, MinMaxSlope semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Modifier returns Modifier
	 *
	 * Constraint:
	 *     (modName=STRING | value=STRING)+
	 * </pre>
	 */
	protected void sequence_Modifier(ISerializationContext context, Modifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Modifiers returns Modifiers
	 *
	 * Constraint:
	 *     modifier+=Modifier*
	 * </pre>
	 */
	protected void sequence_Modifiers(ISerializationContext context, Modifiers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NewsData returns NewsData
	 *
	 * Constraint:
	 *     (
	 *         genre=STRING | 
	 *         price=STRING | 
	 *         quality=STRING | 
	 *         flags=STRING | 
	 *         happenTime=STRING | 
	 *         subscriptionLevel=STRING | 
	 *         fictional=STRING | 
	 *         available=STRING | 
	 *         qualityMin=STRING | 
	 *         qualityMax=STRING | 
	 *         qualitySlope=STRING
	 *     )*
	 * </pre>
	 */
	protected void sequence_NewsData(ISerializationContext context, NewsData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MayContainVariables returns NewsItem
	 *     NewsItem returns NewsItem
	 *
	 * Constraint:
	 *     (
	 *         name=STRING? 
	 *         ((threadId=STRING | type=STRING | creator=STRING | comment=STRING | createdBy=STRING)? name=STRING?)* 
	 *         (
	 *             title=Title | 
	 *             description=Description | 
	 *             variables=Variables | 
	 *             availability=Availability | 
	 *             data=NewsData | 
	 *             attractivity=GroupAttractivity | 
	 *             modifiers=Modifiers | 
	 *             effects=Effects
	 *         )*
	 *     )
	 * </pre>
	 */
	protected void sequence_NewsItem(ISerializationContext context, NewsItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Definition returns News
	 *     News returns News
	 *
	 * Constraint:
	 *     news+=NewsItem*
	 * </pre>
	 */
	protected void sequence_News(ISerializationContext context, News semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContainsMinMaxSlope returns Outcome
	 *     Outcome returns Outcome
	 *
	 * Constraint:
	 *     data=MinMaxSlope
	 * </pre>
	 */
	protected void sequence_Outcome(ISerializationContext context, Outcome semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatabasePackage.Literals.CONTAINS_MIN_MAX_SLOPE__DATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatabasePackage.Literals.CONTAINS_MIN_MAX_SLOPE__DATA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutcomeAccess().getDataMinMaxSlopeParserRuleCall_2_0(), semanticObject.getData());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PersonData returns PersonData
	 *
	 * Constraint:
	 *     (
	 *         popularity=STRING | 
	 *         popularityTarget=STRING | 
	 *         affinity=STRING | 
	 *         fame=STRING | 
	 *         scandalizing=STRING | 
	 *         priceMod=STRING | 
	 *         power=STRING | 
	 *         humor=STRING | 
	 *         charisma=STRING | 
	 *         appearance=STRING | 
	 *         topGenre=STRING
	 *     )*
	 * </pre>
	 */
	protected void sequence_PersonData(ISerializationContext context, PersonData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PersonDetails returns PersonDetails
	 *
	 * Constraint:
	 *     (
	 *         job=STRING | 
	 *         gender=STRING | 
	 *         birthday=STRING | 
	 *         deathday=STRING | 
	 *         fictional=STRING | 
	 *         faceCode=STRING | 
	 *         country=STRING
	 *     )*
	 * </pre>
	 */
	protected void sequence_PersonDetails(ISerializationContext context, PersonDetails semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PersonLocale returns PersonLocale
	 *
	 * Constraint:
	 *     (person=[Person|STRING] | firstName=STRING | lastName=STRING | nickName=STRING)+
	 * </pre>
	 */
	protected void sequence_PersonLocale(ISerializationContext context, PersonLocale semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PersonLocalization returns PersonLocalization
	 *
	 * Constraint:
	 *     (persons+=PersonLocale* roles+=RoleLocale*)
	 * </pre>
	 */
	protected void sequence_PersonLocalization(ISerializationContext context, PersonLocalization semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Person returns Person
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             name=STRING | 
	 *             tmdbId=STRING | 
	 *             imdbId=STRING | 
	 *             firstName=STRING | 
	 *             firstNameOrig=STRING | 
	 *             lastName=STRING | 
	 *             lastNameOrig=STRING | 
	 *             nickName=STRING | 
	 *             nickNameOrig=STRING | 
	 *             title=STRING | 
	 *             fictional=STRING | 
	 *             levelUp=STRING | 
	 *             castable=STRING | 
	 *             gender=STRING | 
	 *             faceCode=STRING | 
	 *             country=STRING | 
	 *             generator=STRING | 
	 *             job=STRING | 
	 *             birthday=STRING | 
	 *             deathday=STRING | 
	 *             comment=STRING | 
	 *             creator=STRING | 
	 *             createdBy=STRING
	 *         )* 
	 *         details=PersonDetails? 
	 *         (
	 *             (
	 *                 firstName=PersonName | 
	 *                 lastName=PersonName | 
	 *                 nickName=PersonName | 
	 *                 firstNameOrig=PersonName | 
	 *                 lastNameOrig=PersonName | 
	 *                 nickNameOrig=PersonName | 
	 *                 data=PersonData
	 *             )? 
	 *             details=PersonDetails?
	 *         )*
	 *     )
	 * </pre>
	 */
	protected void sequence_Person(ISerializationContext context, Person semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContainsMinMaxSlope returns Potential
	 *     Potential returns Potential
	 *
	 * Constraint:
	 *     data=MinMaxSlope
	 * </pre>
	 */
	protected void sequence_Potential(ISerializationContext context, Potential semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatabasePackage.Literals.CONTAINS_MIN_MAX_SLOPE__DATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatabasePackage.Literals.CONTAINS_MIN_MAX_SLOPE__DATA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPotentialAccess().getDataMinMaxSlopeParserRuleCall_2_0(), semanticObject.getData());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContainsMinMaxSlope returns Price
	 *     Price returns Price
	 *
	 * Constraint:
	 *     data=MinMaxSlope
	 * </pre>
	 */
	protected void sequence_Price(ISerializationContext context, Price semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatabasePackage.Literals.CONTAINS_MIN_MAX_SLOPE__DATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatabasePackage.Literals.CONTAINS_MIN_MAX_SLOPE__DATA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPriceAccess().getDataMinMaxSlopeParserRuleCall_2_0(), semanticObject.getData());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContainsMinMaxSlope returns ProductionTime
	 *     ProductionTime returns ProductionTime
	 *
	 * Constraint:
	 *     data=MinMaxSlope
	 * </pre>
	 */
	protected void sequence_ProductionTime(ISerializationContext context, ProductionTime semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatabasePackage.Literals.CONTAINS_MIN_MAX_SLOPE__DATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatabasePackage.Literals.CONTAINS_MIN_MAX_SLOPE__DATA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProductionTimeAccess().getDataMinMaxSlopeParserRuleCall_2_0(), semanticObject.getData());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProgrammeChildren returns ProgrammeChildren
	 *
	 * Constraint:
	 *     child+=Programme+
	 * </pre>
	 */
	protected void sequence_ProgrammeChildren(ISerializationContext context, ProgrammeChildren semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProgrammeData returns ProgrammeData
	 *
	 * Constraint:
	 *     (
	 *         country=STRING | 
	 *         year=STRING | 
	 *         price=STRING | 
	 *         distribution=STRING | 
	 *         maingenre=STRING | 
	 *         subgenre=STRING | 
	 *         flags=STRING | 
	 *         licenceFlags=STRING | 
	 *         blocks=STRING | 
	 *         slotStart=STRING | 
	 *         slotEnd=STRING | 
	 *         broadcastLimit=STRING | 
	 *         broadcastFlags=STRING | 
	 *         licenceBroadcastLimit=STRING | 
	 *         licenceBroadcastFlags=STRING | 
	 *         available=STRING | 
	 *         priceMod=STRING
	 *     )*
	 * </pre>
	 */
	protected void sequence_ProgrammeData(ISerializationContext context, ProgrammeData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProgrammeGroups returns ProgrammeGroups
	 *
	 * Constraint:
	 *     (targetGroup=STRING | optionalTargetGroup=STRING | proPressureGroup=STRING | contraPressureGroup=STRING)*
	 * </pre>
	 */
	protected void sequence_ProgrammeGroups(ISerializationContext context, ProgrammeGroups semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProgrammeRatings returns ProgrammeRatings
	 *
	 * Constraint:
	 *     (critics=STRING | speed=STRING | outcome=STRING)*
	 * </pre>
	 */
	protected void sequence_ProgrammeRatings(ISerializationContext context, ProgrammeRatings semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProgrammeReleaseTime returns ProgrammeReleaseTime
	 *
	 * Constraint:
	 *     (
	 *         year=STRING | 
	 *         day=STRING | 
	 *         hour=STRING | 
	 *         yearRelative=STRING | 
	 *         yearRelativeMin=STRING | 
	 *         yearRelativeMax=STRING
	 *     )*
	 * </pre>
	 */
	protected void sequence_ProgrammeReleaseTime(ISerializationContext context, ProgrammeReleaseTime semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProgrammeRole returns ProgrammeRole
	 *
	 * Constraint:
	 *     (
	 *         name=STRING | 
	 *         firstName=STRING | 
	 *         lastName=STRING | 
	 *         firstNameOriginal=STRING | 
	 *         lastNameOriginal=STRING | 
	 *         nickName=STRING | 
	 *         nickNameOriginal=STRING | 
	 *         title=STRING | 
	 *         country=STRING | 
	 *         comment=STRING | 
	 *         gender=STRING
	 *     )+
	 * </pre>
	 */
	protected void sequence_ProgrammeRole(ISerializationContext context, ProgrammeRole semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Definition returns ProgrammeRoles
	 *     ProgrammeRoles returns ProgrammeRoles
	 *
	 * Constraint:
	 *     roles+=ProgrammeRole*
	 * </pre>
	 */
	protected void sequence_ProgrammeRoles(ISerializationContext context, ProgrammeRoles semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Programme returns Programme
	 *
	 * Constraint:
	 *     (
	 *         name=STRING? 
	 *         (
	 *             (
	 *                 product=STRING | 
	 *                 licenceType=STRING | 
	 *                 tmdbId=STRING | 
	 *                 imdbId=STRING | 
	 *                 fictional=STRING | 
	 *                 ref=[Programme|STRING] | 
	 *                 comment=STRING | 
	 *                 creator=STRING | 
	 *                 createdBy=STRING
	 *             )? 
	 *             name=STRING?
	 *         )* 
	 *         (
	 *             title=Title | 
	 *             titleOrig=TitleOriginal | 
	 *             description=Description | 
	 *             groups=ProgrammeGroups | 
	 *             attractivity=GroupAttractivity | 
	 *             children=ProgrammeChildren | 
	 *             staff=Staff | 
	 *             releaseTime=ProgrammeReleaseTime | 
	 *             ratings=ProgrammeRatings | 
	 *             modifiers=Modifiers | 
	 *             data=ProgrammeData | 
	 *             effects=Effects
	 *         )*
	 *     )
	 * </pre>
	 */
	protected void sequence_Programme(ISerializationContext context, Programme semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Definition returns Programmes
	 *     Programmes returns Programmes
	 *
	 * Constraint:
	 *     programmes+=Programme*
	 * </pre>
	 */
	protected void sequence_Programmes(ISerializationContext context, Programmes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContainsMinMaxSlope returns Review
	 *     Review returns Review
	 *
	 * Constraint:
	 *     data=MinMaxSlope
	 * </pre>
	 */
	protected void sequence_Review(ISerializationContext context, Review semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatabasePackage.Literals.CONTAINS_MIN_MAX_SLOPE__DATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatabasePackage.Literals.CONTAINS_MIN_MAX_SLOPE__DATA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReviewAccess().getDataMinMaxSlopeParserRuleCall_2_0(), semanticObject.getData());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RewardData returns RewardData
	 *
	 * Constraint:
	 *     (type=STRING | money=STRING)+
	 * </pre>
	 */
	protected void sequence_RewardData(ISerializationContext context, RewardData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Reward returns Reward
	 *
	 * Constraint:
	 *     ((id=STRING | comment=STRING | creator=STRING | createdBy=STRING)* title=Title? ((text=Text | data=RewardData)? title=Title?)*)
	 * </pre>
	 */
	protected void sequence_Reward(ISerializationContext context, Reward semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Rewards returns Rewards
	 *
	 * Constraint:
	 *     rewards+=Reward*
	 * </pre>
	 */
	protected void sequence_Rewards(ISerializationContext context, Rewards semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RoleLocale returns RoleLocale
	 *
	 * Constraint:
	 *     (role=[ProgrammeRole|STRING] | firstName=STRING | lastName=STRING | title=STRING)+
	 * </pre>
	 */
	protected void sequence_RoleLocale(ISerializationContext context, RoleLocale semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ScriptChildren returns ScriptChildren
	 *
	 * Constraint:
	 *     child+=ScriptTemplate+
	 * </pre>
	 */
	protected void sequence_ScriptChildren(ISerializationContext context, ScriptChildren semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ScriptData returns ScriptData
	 *
	 * Constraint:
	 *     (
	 *         programmeFlags=STRING | 
	 *         optionalProgrammeFlags=STRING | 
	 *         scriptFlags=STRING | 
	 *         live_date=STRING | 
	 *         broadcastTimeSlotStart=STRING | 
	 *         broadcastTimeSlotEnd=STRING | 
	 *         productionLimit=STRING | 
	 *         broadcastLimit=STRING | 
	 *         broadcastFlags=STRING | 
	 *         licenceFlags=STRING | 
	 *         available=STRING
	 *     )*
	 * </pre>
	 */
	protected void sequence_ScriptData(ISerializationContext context, ScriptData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ScriptGenres returns ScriptGenres
	 *
	 * Constraint:
	 *     (mainGenre=STRING | subgenres=STRING)+
	 * </pre>
	 */
	protected void sequence_ScriptGenres(ISerializationContext context, ScriptGenres semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MayContainVariables returns ScriptTemplate
	 *     ScriptTemplate returns ScriptTemplate
	 *
	 * Constraint:
	 *     (
	 *         name=STRING? 
	 *         (
	 *             (
	 *                 product=STRING | 
	 *                 licenceType=STRING | 
	 *                 index=STRING | 
	 *                 comment=STRING | 
	 *                 creator=STRING | 
	 *                 createdBy=STRING
	 *             )? 
	 *             name=STRING?
	 *         )* 
	 *         (
	 *             title=Title | 
	 *             title_original=TitleOriginal | 
	 *             description=Description | 
	 *             variables=Variables | 
	 *             genres=ScriptGenres | 
	 *             jobs=Jobs | 
	 *             data=ScriptData | 
	 *             groups=ProgrammeGroups | 
	 *             availability=Availability | 
	 *             episodes=Episodes | 
	 *             studioSize=StudioSize | 
	 *             blocks=Blocks | 
	 *             price=Price | 
	 *             potential=Potential | 
	 *             outcome=Outcome | 
	 *             review=Review | 
	 *             speed=Speed | 
	 *             productionTime=ProductionTime | 
	 *             children=ScriptChildren | 
	 *             attractivity=GroupAttractivity | 
	 *             progDataModifiers=TemplateProgrammeModifiers | 
	 *             effects=Effects
	 *         )*
	 *     )
	 * </pre>
	 */
	protected void sequence_ScriptTemplate(ISerializationContext context, ScriptTemplate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Definition returns ScriptTemplates
	 *     ScriptTemplates returns ScriptTemplates
	 *
	 * Constraint:
	 *     templates+=ScriptTemplate*
	 * </pre>
	 */
	protected void sequence_ScriptTemplates(ISerializationContext context, ScriptTemplates semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContainsMinMaxSlope returns Speed
	 *     Speed returns Speed
	 *
	 * Constraint:
	 *     data=MinMaxSlope
	 * </pre>
	 */
	protected void sequence_Speed(ISerializationContext context, Speed semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatabasePackage.Literals.CONTAINS_MIN_MAX_SLOPE__DATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatabasePackage.Literals.CONTAINS_MIN_MAX_SLOPE__DATA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSpeedAccess().getDataMinMaxSlopeParserRuleCall_2_0(), semanticObject.getData());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StaffMember returns StaffMember
	 *
	 * Constraint:
	 *     (((index=STRING | function=STRING)+ (generator=STRING | ref=[Person|PersonRef])?) | generator=STRING | ref=[Person|PersonRef])?
	 * </pre>
	 */
	protected void sequence_StaffMember(ISerializationContext context, StaffMember semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Staff returns Staff
	 *
	 * Constraint:
	 *     member+=StaffMember*
	 * </pre>
	 */
	protected void sequence_Staff(ISerializationContext context, Staff semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContainsMinMaxSlope returns StudioSize
	 *     StudioSize returns StudioSize
	 *
	 * Constraint:
	 *     data=MinMaxSlope
	 * </pre>
	 */
	protected void sequence_StudioSize(ISerializationContext context, StudioSize semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatabasePackage.Literals.CONTAINS_MIN_MAX_SLOPE__DATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatabasePackage.Literals.CONTAINS_MIN_MAX_SLOPE__DATA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStudioSizeAccess().getDataMinMaxSlopeParserRuleCall_2_0(), semanticObject.getData());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TaskData returns TaskData
	 *
	 * Constraint:
	 *     (
	 *         type=STRING | 
	 *         minAudienceAbs=STRING | 
	 *         minAudiencePercent=STRING | 
	 *         limitToGenres=STRING | 
	 *         limitToFlags=STRING | 
	 *         minReachAbs=STRING | 
	 *         minReachPercent=STRING | 
	 *         keyword1=STRING | 
	 *         keyword2=STRING | 
	 *         keyword3=STRING | 
	 *         genre1=STRING | 
	 *         genre2=STRING | 
	 *         genre3=STRING | 
	 *         minQuality1=STRING | 
	 *         minQuality2=STRING | 
	 *         minQuality3=STRING | 
	 *         maxQuality1=STRING | 
	 *         maxQuality2=STRING | 
	 *         maxQuality3=STRING | 
	 *         checkMinute=STRING | 
	 *         checkHour=STRING
	 *     )+
	 * </pre>
	 */
	protected void sequence_TaskData(ISerializationContext context, TaskData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Task returns Task
	 *
	 * Constraint:
	 *     (id=STRING? ((comment=STRING | creator=STRING | createdBy=STRING)? id=STRING?)* (title=Title | text=Text | data=TaskData)*)
	 * </pre>
	 */
	protected void sequence_Task(ISerializationContext context, Task semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Tasks returns Tasks
	 *
	 * Constraint:
	 *     tasks+=Task*
	 * </pre>
	 */
	protected void sequence_Tasks(ISerializationContext context, Tasks semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TemplateProgrammeModifiers returns Modifiers
	 *
	 * Constraint:
	 *     modifier+=Modifier*
	 * </pre>
	 */
	protected void sequence_TemplateProgrammeModifiers(ISerializationContext context, Modifiers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContainsLanguageStrings returns Text
	 *     Text returns Text
	 *
	 * Constraint:
	 *     lstrings+=LanguageString*
	 * </pre>
	 */
	protected void sequence_Text(ISerializationContext context, Text semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TitleOriginal returns TitleOriginal
	 *
	 * Constraint:
	 *     languageString+=LanguageString*
	 * </pre>
	 */
	protected void sequence_TitleOriginal(ISerializationContext context, TitleOriginal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContainsLanguageStrings returns Title
	 *     Title returns Title
	 *
	 * Constraint:
	 *     lstrings+=LanguageString*
	 * </pre>
	 */
	protected void sequence_Title(ISerializationContext context, Title semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UnnamedProperty returns UnnamedProperty
	 *
	 * Constraint:
	 *     (key=IDorKeyword value=STRING)
	 * </pre>
	 */
	protected void sequence_UnnamedProperty(ISerializationContext context, UnnamedProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DatabasePackage.Literals.UNNAMED_PROPERTY__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatabasePackage.Literals.UNNAMED_PROPERTY__KEY));
			if (transientValues.isValueTransient(semanticObject, DatabasePackage.Literals.UNNAMED_PROPERTY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DatabasePackage.Literals.UNNAMED_PROPERTY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnnamedPropertyAccess().getKeyIDorKeywordParserRuleCall_0_0(), semanticObject.getKey());
		feeder.accept(grammarAccess.getUnnamedPropertyAccess().getValueSTRINGTerminalRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContainsLanguageStrings returns VariableDef
	 *     VariableDef returns VariableDef
	 *
	 * Constraint:
	 *     (var=IDorKeyword lstrings+=LanguageString*)
	 * </pre>
	 */
	protected void sequence_VariableDef(ISerializationContext context, VariableDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Variables returns Variables
	 *
	 * Constraint:
	 *     variable+=VariableDef*
	 * </pre>
	 */
	protected void sequence_Variables(ISerializationContext context, Variables semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Version returns Version
	 *
	 * Constraint:
	 *     props+=UnnamedProperty*
	 * </pre>
	 */
	protected void sequence_Version(ISerializationContext context, Version semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}

/*
 * generated by Xtext 2.35.0
 */
package de.sos.etj.serializer;

import com.google.inject.Inject;
import de.sos.etj.eTJ.Account;
import de.sos.etj.eTJ.AccountPrefix;
import de.sos.etj.eTJ.AccountRoot;
import de.sos.etj.eTJ.AccountShare;
import de.sos.etj.eTJ.Alert;
import de.sos.etj.eTJ.Allocate;
import de.sos.etj.eTJ.AllocateResource;
import de.sos.etj.eTJ.Alternative;
import de.sos.etj.eTJ.Author;
import de.sos.etj.eTJ.Balance;
import de.sos.etj.eTJ.Booking;
import de.sos.etj.eTJ.BookingResource;
import de.sos.etj.eTJ.BookingTask;
import de.sos.etj.eTJ.CellColor;
import de.sos.etj.eTJ.CellText;
import de.sos.etj.eTJ.Charge;
import de.sos.etj.eTJ.ChargeSet;
import de.sos.etj.eTJ.Column;
import de.sos.etj.eTJ.Columns;
import de.sos.etj.eTJ.Complete;
import de.sos.etj.eTJ.Copyright;
import de.sos.etj.eTJ.Credit;
import de.sos.etj.eTJ.Criterion;
import de.sos.etj.eTJ.Currency;
import de.sos.etj.eTJ.DailyWorkingHours;
import de.sos.etj.eTJ.Definitions;
import de.sos.etj.eTJ.Defintions;
import de.sos.etj.eTJ.Depends;
import de.sos.etj.eTJ.Duration;
import de.sos.etj.eTJ.DurationQuantity;
import de.sos.etj.eTJ.ETJPackage;
import de.sos.etj.eTJ.Efficiency;
import de.sos.etj.eTJ.Effort;
import de.sos.etj.eTJ.Email;
import de.sos.etj.eTJ.End;
import de.sos.etj.eTJ.EndCredit;
import de.sos.etj.eTJ.Export;
import de.sos.etj.eTJ.Extend;
import de.sos.etj.eTJ.ExtendResource;
import de.sos.etj.eTJ.ExtendTask;
import de.sos.etj.eTJ.ExtendedResourceAttribute;
import de.sos.etj.eTJ.ExtendedResourceAttributeColumn;
import de.sos.etj.eTJ.ExtendedTaskAttribute;
import de.sos.etj.eTJ.Fail;
import de.sos.etj.eTJ.Flags;
import de.sos.etj.eTJ.FontColor;
import de.sos.etj.eTJ.Formats;
import de.sos.etj.eTJ.Function;
import de.sos.etj.eTJ.Global;
import de.sos.etj.eTJ.HAlign;
import de.sos.etj.eTJ.HideAccount;
import de.sos.etj.eTJ.HideJournalEntry;
import de.sos.etj.eTJ.HideReport;
import de.sos.etj.eTJ.HideResource;
import de.sos.etj.eTJ.HideTask;
import de.sos.etj.eTJ.ISODATE;
import de.sos.etj.eTJ.IcalReport;
import de.sos.etj.eTJ.Include;
import de.sos.etj.eTJ.IncludeProperties;
import de.sos.etj.eTJ.Interval1;
import de.sos.etj.eTJ.Interval2;
import de.sos.etj.eTJ.Interval3;
import de.sos.etj.eTJ.Interval4;
import de.sos.etj.eTJ.JournalAttributes;
import de.sos.etj.eTJ.JournalEntry;
import de.sos.etj.eTJ.JournalMode;
import de.sos.etj.eTJ.LeaveDetails;
import de.sos.etj.eTJ.Leaves;
import de.sos.etj.eTJ.Length;
import de.sos.etj.eTJ.Limit;
import de.sos.etj.eTJ.LimitAttribute;
import de.sos.etj.eTJ.Limits;
import de.sos.etj.eTJ.ListType;
import de.sos.etj.eTJ.LoadUnit;
import de.sos.etj.eTJ.LogicalAbsoluteIdExression;
import de.sos.etj.eTJ.LogicalBooleanLiteral;
import de.sos.etj.eTJ.LogicalDateLiteral;
import de.sos.etj.eTJ.LogicalExpression;
import de.sos.etj.eTJ.LogicalFlagExpression;
import de.sos.etj.eTJ.LogicalFunctionExpression;
import de.sos.etj.eTJ.LogicalNumeralLiteral;
import de.sos.etj.eTJ.LogicalStringLiteral;
import de.sos.etj.eTJ.Macro;
import de.sos.etj.eTJ.MacroCall;
import de.sos.etj.eTJ.Managers;
import de.sos.etj.eTJ.Mandatory;
import de.sos.etj.eTJ.MaxEnd;
import de.sos.etj.eTJ.MaxStart;
import de.sos.etj.eTJ.Milestone;
import de.sos.etj.eTJ.MinEnd;
import de.sos.etj.eTJ.MinStart;
import de.sos.etj.eTJ.Navigator;
import de.sos.etj.eTJ.NewTask;
import de.sos.etj.eTJ.NikuReport;
import de.sos.etj.eTJ.Note;
import de.sos.etj.eTJ.Now;
import de.sos.etj.eTJ.Period;
import de.sos.etj.eTJ.Persistent;
import de.sos.etj.eTJ.Priority;
import de.sos.etj.eTJ.Project;
import de.sos.etj.eTJ.ProjectId;
import de.sos.etj.eTJ.ProjectIds;
import de.sos.etj.eTJ.PurgeReport;
import de.sos.etj.eTJ.PurgeResource;
import de.sos.etj.eTJ.PurgeTask;
import de.sos.etj.eTJ.RGB;
import de.sos.etj.eTJ.Rate;
import de.sos.etj.eTJ.RealFormat;
import de.sos.etj.eTJ.Remaining;
import de.sos.etj.eTJ.Report;
import de.sos.etj.eTJ.ReportPrefix;
import de.sos.etj.eTJ.Resource;
import de.sos.etj.eTJ.ResourceAttributes;
import de.sos.etj.eTJ.ResourcePrefix;
import de.sos.etj.eTJ.ResourceRoot;
import de.sos.etj.eTJ.Responsible;
import de.sos.etj.eTJ.RichText;
import de.sos.etj.eTJ.RollupAccount;
import de.sos.etj.eTJ.RollupResource;
import de.sos.etj.eTJ.RollupTask;
import de.sos.etj.eTJ.Scale;
import de.sos.etj.eTJ.Scenario;
import de.sos.etj.eTJ.ScenarioIcal;
import de.sos.etj.eTJ.Scenarios;
import de.sos.etj.eTJ.Scheduled;
import de.sos.etj.eTJ.Scheduling;
import de.sos.etj.eTJ.Select;
import de.sos.etj.eTJ.SelfContained;
import de.sos.etj.eTJ.Shift;
import de.sos.etj.eTJ.ShiftTimesheet;
import de.sos.etj.eTJ.Shifts;
import de.sos.etj.eTJ.ShiftsAllocate;
import de.sos.etj.eTJ.ShiftsLimit;
import de.sos.etj.eTJ.ShortTimeFormat;
import de.sos.etj.eTJ.Sort;
import de.sos.etj.eTJ.Start;
import de.sos.etj.eTJ.StatusSheet;
import de.sos.etj.eTJ.StatusSheetReport;
import de.sos.etj.eTJ.StatusStatusSheet;
import de.sos.etj.eTJ.StatusTimesheet;
import de.sos.etj.eTJ.SupplementAccount;
import de.sos.etj.eTJ.SupplementReport;
import de.sos.etj.eTJ.SupplementResource;
import de.sos.etj.eTJ.SupplementTask;
import de.sos.etj.eTJ.TagFile;
import de.sos.etj.eTJ.Task;
import de.sos.etj.eTJ.TaskAttribute;
import de.sos.etj.eTJ.TaskAttributes;
import de.sos.etj.eTJ.TaskDependency;
import de.sos.etj.eTJ.TaskPrefix;
import de.sos.etj.eTJ.TaskRoot;
import de.sos.etj.eTJ.TaskStatusSheet;
import de.sos.etj.eTJ.TaskTimesheet;
import de.sos.etj.eTJ.TimeFormat;
import de.sos.etj.eTJ.Timeoff;
import de.sos.etj.eTJ.Timesheet;
import de.sos.etj.eTJ.TimesheetReport;
import de.sos.etj.eTJ.Timezone;
import de.sos.etj.eTJ.TimingResolution;
import de.sos.etj.eTJ.Title;
import de.sos.etj.eTJ.ToolTip;
import de.sos.etj.eTJ.TrackingScenario;
import de.sos.etj.eTJ.TreeLevel;
import de.sos.etj.eTJ.Vacation;
import de.sos.etj.eTJ.Warn;
import de.sos.etj.eTJ.WeekStarts;
import de.sos.etj.eTJ.Weekdays;
import de.sos.etj.eTJ.Width;
import de.sos.etj.eTJ.Work;
import de.sos.etj.eTJ.WorkHours;
import de.sos.etj.eTJ.WorkingHours;
import de.sos.etj.eTJ.YearlyWorkingDays;
import de.sos.etj.services.ETJGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ETJSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ETJGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ETJPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ETJPackage.ACCOUNT:
				sequence_Account(context, (Account) semanticObject); 
				return; 
			case ETJPackage.ACCOUNT_PREFIX:
				sequence_AccountPrefix(context, (AccountPrefix) semanticObject); 
				return; 
			case ETJPackage.ACCOUNT_ROOT:
				sequence_AccountRoot(context, (AccountRoot) semanticObject); 
				return; 
			case ETJPackage.ACCOUNT_SHARE:
				sequence_AccountShare(context, (AccountShare) semanticObject); 
				return; 
			case ETJPackage.ALERT:
				sequence_Alert(context, (Alert) semanticObject); 
				return; 
			case ETJPackage.ALLOCATE:
				sequence_Allocate(context, (Allocate) semanticObject); 
				return; 
			case ETJPackage.ALLOCATE_RESOURCE:
				sequence_AllocateResource(context, (AllocateResource) semanticObject); 
				return; 
			case ETJPackage.ALTERNATIVE:
				sequence_Alternative(context, (Alternative) semanticObject); 
				return; 
			case ETJPackage.AUTHOR:
				sequence_Author(context, (Author) semanticObject); 
				return; 
			case ETJPackage.BALANCE:
				sequence_Balance(context, (Balance) semanticObject); 
				return; 
			case ETJPackage.BOOKING:
				sequence_Booking(context, (Booking) semanticObject); 
				return; 
			case ETJPackage.BOOKING_RESOURCE:
				sequence_BookingResource(context, (BookingResource) semanticObject); 
				return; 
			case ETJPackage.BOOKING_TASK:
				sequence_BookingTask(context, (BookingTask) semanticObject); 
				return; 
			case ETJPackage.CELL_COLOR:
				sequence_CellColor(context, (CellColor) semanticObject); 
				return; 
			case ETJPackage.CELL_TEXT:
				sequence_CellText(context, (CellText) semanticObject); 
				return; 
			case ETJPackage.CHARGE:
				sequence_Charge(context, (Charge) semanticObject); 
				return; 
			case ETJPackage.CHARGE_SET:
				sequence_ChargeSet(context, (ChargeSet) semanticObject); 
				return; 
			case ETJPackage.COLUMN:
				sequence_Column(context, (Column) semanticObject); 
				return; 
			case ETJPackage.COLUMNS:
				sequence_Columns(context, (Columns) semanticObject); 
				return; 
			case ETJPackage.COMPLETE:
				sequence_Complete(context, (Complete) semanticObject); 
				return; 
			case ETJPackage.COPYRIGHT:
				sequence_Copyright(context, (Copyright) semanticObject); 
				return; 
			case ETJPackage.CREDIT:
				sequence_Credit(context, (Credit) semanticObject); 
				return; 
			case ETJPackage.CRITERION:
				sequence_Criterion(context, (Criterion) semanticObject); 
				return; 
			case ETJPackage.CURRENCY:
				sequence_Currency(context, (Currency) semanticObject); 
				return; 
			case ETJPackage.DAILY_WORKING_HOURS:
				sequence_DailyWorkingHours(context, (DailyWorkingHours) semanticObject); 
				return; 
			case ETJPackage.DEFINITIONS:
				sequence_Definitions(context, (Definitions) semanticObject); 
				return; 
			case ETJPackage.DEFINTIONS:
				sequence_Definitions(context, (Defintions) semanticObject); 
				return; 
			case ETJPackage.DEPENDS:
				sequence_Depends(context, (Depends) semanticObject); 
				return; 
			case ETJPackage.DURATION:
				sequence_Duration(context, (Duration) semanticObject); 
				return; 
			case ETJPackage.DURATION_QUANTITY:
				sequence_DurationQuantity(context, (DurationQuantity) semanticObject); 
				return; 
			case ETJPackage.EFFICIENCY:
				sequence_Efficiency(context, (Efficiency) semanticObject); 
				return; 
			case ETJPackage.EFFORT:
				sequence_Effort(context, (Effort) semanticObject); 
				return; 
			case ETJPackage.EMAIL:
				sequence_Email(context, (Email) semanticObject); 
				return; 
			case ETJPackage.END:
				sequence_End(context, (End) semanticObject); 
				return; 
			case ETJPackage.END_CREDIT:
				sequence_EndCredit(context, (EndCredit) semanticObject); 
				return; 
			case ETJPackage.EXPORT:
				sequence_Export(context, (Export) semanticObject); 
				return; 
			case ETJPackage.EXTEND:
				sequence_Extend(context, (Extend) semanticObject); 
				return; 
			case ETJPackage.EXTEND_RESOURCE:
				sequence_ExtendResource(context, (ExtendResource) semanticObject); 
				return; 
			case ETJPackage.EXTEND_TASK:
				sequence_ExtendTask(context, (ExtendTask) semanticObject); 
				return; 
			case ETJPackage.EXTENDED_RESOURCE_ATTRIBUTE:
				sequence_ExtendedResourceAttribute(context, (ExtendedResourceAttribute) semanticObject); 
				return; 
			case ETJPackage.EXTENDED_RESOURCE_ATTRIBUTE_COLUMN:
				sequence_ExtendedResourceAttributeColumn(context, (ExtendedResourceAttributeColumn) semanticObject); 
				return; 
			case ETJPackage.EXTENDED_TASK_ATTRIBUTE:
				sequence_ExtendedTaskAttribute(context, (ExtendedTaskAttribute) semanticObject); 
				return; 
			case ETJPackage.FAIL:
				sequence_Fail(context, (Fail) semanticObject); 
				return; 
			case ETJPackage.FLAGS:
				sequence_Flags(context, (Flags) semanticObject); 
				return; 
			case ETJPackage.FONT_COLOR:
				sequence_FontColor(context, (FontColor) semanticObject); 
				return; 
			case ETJPackage.FORMATS:
				sequence_Formats(context, (Formats) semanticObject); 
				return; 
			case ETJPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case ETJPackage.GLOBAL:
				sequence_Global(context, (Global) semanticObject); 
				return; 
			case ETJPackage.HALIGN:
				sequence_HAlign(context, (HAlign) semanticObject); 
				return; 
			case ETJPackage.HIDE_ACCOUNT:
				sequence_HideAccount(context, (HideAccount) semanticObject); 
				return; 
			case ETJPackage.HIDE_JOURNAL_ENTRY:
				sequence_HideJournalEntry(context, (HideJournalEntry) semanticObject); 
				return; 
			case ETJPackage.HIDE_REPORT:
				sequence_HideReport(context, (HideReport) semanticObject); 
				return; 
			case ETJPackage.HIDE_RESOURCE:
				sequence_HideResource(context, (HideResource) semanticObject); 
				return; 
			case ETJPackage.HIDE_TASK:
				sequence_HideTask(context, (HideTask) semanticObject); 
				return; 
			case ETJPackage.ISODATE:
				sequence_ISODATE(context, (ISODATE) semanticObject); 
				return; 
			case ETJPackage.ICAL_REPORT:
				sequence_IcalReport(context, (IcalReport) semanticObject); 
				return; 
			case ETJPackage.INCLUDE:
				sequence_Include(context, (Include) semanticObject); 
				return; 
			case ETJPackage.INCLUDE_PROPERTIES:
				sequence_IncludeProperties(context, (IncludeProperties) semanticObject); 
				return; 
			case ETJPackage.INTERVAL1:
				sequence_Interval1(context, (Interval1) semanticObject); 
				return; 
			case ETJPackage.INTERVAL2:
				sequence_Interval2(context, (Interval2) semanticObject); 
				return; 
			case ETJPackage.INTERVAL3:
				sequence_Interval3(context, (Interval3) semanticObject); 
				return; 
			case ETJPackage.INTERVAL4:
				sequence_Interval4(context, (Interval4) semanticObject); 
				return; 
			case ETJPackage.JOURNAL_ATTRIBUTES:
				sequence_JournalAttributes(context, (JournalAttributes) semanticObject); 
				return; 
			case ETJPackage.JOURNAL_ENTRY:
				sequence_JournalEntry(context, (JournalEntry) semanticObject); 
				return; 
			case ETJPackage.JOURNAL_MODE:
				sequence_JournalMode(context, (JournalMode) semanticObject); 
				return; 
			case ETJPackage.LEAVE_DETAILS:
				sequence_LeaveDetails(context, (LeaveDetails) semanticObject); 
				return; 
			case ETJPackage.LEAVES:
				sequence_Leaves(context, (Leaves) semanticObject); 
				return; 
			case ETJPackage.LENGTH:
				sequence_Length(context, (Length) semanticObject); 
				return; 
			case ETJPackage.LIMIT:
				sequence_Limit(context, (Limit) semanticObject); 
				return; 
			case ETJPackage.LIMIT_ATTRIBUTE:
				sequence_LimitAttribute(context, (LimitAttribute) semanticObject); 
				return; 
			case ETJPackage.LIMITS:
				sequence_Limits(context, (Limits) semanticObject); 
				return; 
			case ETJPackage.LIST_TYPE:
				sequence_ListType(context, (ListType) semanticObject); 
				return; 
			case ETJPackage.LOAD_UNIT:
				sequence_LoadUnit(context, (LoadUnit) semanticObject); 
				return; 
			case ETJPackage.LOGICAL_ABSOLUTE_ID_EXRESSION:
				sequence_LogicalAbsoluteIdExpression(context, (LogicalAbsoluteIdExression) semanticObject); 
				return; 
			case ETJPackage.LOGICAL_BOOLEAN_LITERAL:
				sequence_LogicalBooleanLiteral(context, (LogicalBooleanLiteral) semanticObject); 
				return; 
			case ETJPackage.LOGICAL_DATE_LITERAL:
				sequence_LogicalISODateLiteral(context, (LogicalDateLiteral) semanticObject); 
				return; 
			case ETJPackage.LOGICAL_EXPRESSION:
				if (rule == grammarAccess.getLogicalAndExpressionRule()) {
					sequence_LogicalAndExpression(context, (LogicalExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLogicalEqualityExpressionRule()) {
					sequence_LogicalEqualityExpression(context, (LogicalExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLogicalExpressionRule()
						|| rule == grammarAccess.getLogicalOrExpressionRule()
						|| rule == grammarAccess.getLogicalPrimaryExpressionRule()
						|| rule == grammarAccess.getLogicalPrenthesizedExpressionRule()) {
					sequence_LogicalOrExpression(context, (LogicalExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLogicalRelationalExpressionRule()) {
					sequence_LogicalRelationalExpression(context, (LogicalExpression) semanticObject); 
					return; 
				}
				else break;
			case ETJPackage.LOGICAL_FLAG_EXPRESSION:
				sequence_LogicalFlagLiteral(context, (LogicalFlagExpression) semanticObject); 
				return; 
			case ETJPackage.LOGICAL_FUNCTION_EXPRESSION:
				sequence_LogicalFunctionExpression(context, (LogicalFunctionExpression) semanticObject); 
				return; 
			case ETJPackage.LOGICAL_NUMERAL_LITERAL:
				sequence_LogicalNumeralLiteral(context, (LogicalNumeralLiteral) semanticObject); 
				return; 
			case ETJPackage.LOGICAL_STRING_LITERAL:
				sequence_LogicalStringLiteral(context, (LogicalStringLiteral) semanticObject); 
				return; 
			case ETJPackage.MACRO:
				sequence_Macro(context, (Macro) semanticObject); 
				return; 
			case ETJPackage.MACRO_CALL:
				sequence_MacroCall(context, (MacroCall) semanticObject); 
				return; 
			case ETJPackage.MANAGERS:
				sequence_Managers(context, (Managers) semanticObject); 
				return; 
			case ETJPackage.MANDATORY:
				sequence_Mandatory(context, (Mandatory) semanticObject); 
				return; 
			case ETJPackage.MAX_END:
				sequence_MaxEnd(context, (MaxEnd) semanticObject); 
				return; 
			case ETJPackage.MAX_START:
				sequence_MaxStart(context, (MaxStart) semanticObject); 
				return; 
			case ETJPackage.MILESTONE:
				sequence_Milestone(context, (Milestone) semanticObject); 
				return; 
			case ETJPackage.MIN_END:
				sequence_MinEnd(context, (MinEnd) semanticObject); 
				return; 
			case ETJPackage.MIN_START:
				sequence_MinStart(context, (MinStart) semanticObject); 
				return; 
			case ETJPackage.NAVIGATOR:
				sequence_Navigator(context, (Navigator) semanticObject); 
				return; 
			case ETJPackage.NEW_TASK:
				sequence_NewTask(context, (NewTask) semanticObject); 
				return; 
			case ETJPackage.NIKU_REPORT:
				sequence_NikuReport(context, (NikuReport) semanticObject); 
				return; 
			case ETJPackage.NOTE:
				sequence_Note(context, (Note) semanticObject); 
				return; 
			case ETJPackage.NOW:
				sequence_Now(context, (Now) semanticObject); 
				return; 
			case ETJPackage.PERIOD:
				sequence_Period(context, (Period) semanticObject); 
				return; 
			case ETJPackage.PERSISTENT:
				sequence_Persistent(context, (Persistent) semanticObject); 
				return; 
			case ETJPackage.PRIORITY:
				sequence_Priority(context, (Priority) semanticObject); 
				return; 
			case ETJPackage.PROJECT:
				sequence_Project(context, (Project) semanticObject); 
				return; 
			case ETJPackage.PROJECT_ID:
				sequence_ProjectId(context, (ProjectId) semanticObject); 
				return; 
			case ETJPackage.PROJECT_IDS:
				sequence_ProjectIds(context, (ProjectIds) semanticObject); 
				return; 
			case ETJPackage.PURGE_REPORT:
				sequence_PurgeReport(context, (PurgeReport) semanticObject); 
				return; 
			case ETJPackage.PURGE_RESOURCE:
				sequence_PurgeResource(context, (PurgeResource) semanticObject); 
				return; 
			case ETJPackage.PURGE_TASK:
				sequence_PurgeTask(context, (PurgeTask) semanticObject); 
				return; 
			case ETJPackage.RGB:
				sequence_RGB(context, (RGB) semanticObject); 
				return; 
			case ETJPackage.RATE:
				sequence_Rate(context, (Rate) semanticObject); 
				return; 
			case ETJPackage.REAL_FORMAT:
				sequence_RealFormat(context, (RealFormat) semanticObject); 
				return; 
			case ETJPackage.REMAINING:
				sequence_Remaining(context, (Remaining) semanticObject); 
				return; 
			case ETJPackage.REPORT:
				sequence_Report(context, (Report) semanticObject); 
				return; 
			case ETJPackage.REPORT_PREFIX:
				sequence_ReportPrefix(context, (ReportPrefix) semanticObject); 
				return; 
			case ETJPackage.RESOURCE:
				sequence_Resource(context, (Resource) semanticObject); 
				return; 
			case ETJPackage.RESOURCE_ATTRIBUTES:
				sequence_ResourceAttributes(context, (ResourceAttributes) semanticObject); 
				return; 
			case ETJPackage.RESOURCE_PREFIX:
				sequence_ResourcePrefix(context, (ResourcePrefix) semanticObject); 
				return; 
			case ETJPackage.RESOURCE_ROOT:
				sequence_ResourceRoot(context, (ResourceRoot) semanticObject); 
				return; 
			case ETJPackage.RESPONSIBLE:
				sequence_Responsible(context, (Responsible) semanticObject); 
				return; 
			case ETJPackage.RICH_TEXT:
				sequence_RichText(context, (RichText) semanticObject); 
				return; 
			case ETJPackage.ROLLUP_ACCOUNT:
				sequence_RollupAccount(context, (RollupAccount) semanticObject); 
				return; 
			case ETJPackage.ROLLUP_RESOURCE:
				sequence_RollupResource(context, (RollupResource) semanticObject); 
				return; 
			case ETJPackage.ROLLUP_TASK:
				sequence_RollupTask(context, (RollupTask) semanticObject); 
				return; 
			case ETJPackage.SCALE:
				sequence_Scale(context, (Scale) semanticObject); 
				return; 
			case ETJPackage.SCENARIO:
				sequence_Scenario(context, (Scenario) semanticObject); 
				return; 
			case ETJPackage.SCENARIO_ICAL:
				sequence_ScenarioIcal(context, (ScenarioIcal) semanticObject); 
				return; 
			case ETJPackage.SCENARIOS:
				sequence_Scenarios(context, (Scenarios) semanticObject); 
				return; 
			case ETJPackage.SCHEDULED:
				sequence_Scheduled(context, (Scheduled) semanticObject); 
				return; 
			case ETJPackage.SCHEDULING:
				sequence_Scheduling(context, (Scheduling) semanticObject); 
				return; 
			case ETJPackage.SELECT:
				sequence_Select(context, (Select) semanticObject); 
				return; 
			case ETJPackage.SELF_CONTAINED:
				sequence_SelfContained(context, (SelfContained) semanticObject); 
				return; 
			case ETJPackage.SHIFT:
				sequence_Shift(context, (Shift) semanticObject); 
				return; 
			case ETJPackage.SHIFT_TIMESHEET:
				sequence_ShiftTimesheet(context, (ShiftTimesheet) semanticObject); 
				return; 
			case ETJPackage.SHIFTS:
				sequence_Shifts(context, (Shifts) semanticObject); 
				return; 
			case ETJPackage.SHIFTS_ALLOCATE:
				sequence_ShiftsAllocate(context, (ShiftsAllocate) semanticObject); 
				return; 
			case ETJPackage.SHIFTS_LIMIT:
				sequence_ShiftsLimit(context, (ShiftsLimit) semanticObject); 
				return; 
			case ETJPackage.SHORT_TIME_FORMAT:
				sequence_ShortTimeFormat(context, (ShortTimeFormat) semanticObject); 
				return; 
			case ETJPackage.SORT:
				sequence_Sort(context, (Sort) semanticObject); 
				return; 
			case ETJPackage.START:
				sequence_Start(context, (Start) semanticObject); 
				return; 
			case ETJPackage.STATUS_SHEET:
				sequence_StatusSheet(context, (StatusSheet) semanticObject); 
				return; 
			case ETJPackage.STATUS_SHEET_REPORT:
				sequence_StatusSheetReport(context, (StatusSheetReport) semanticObject); 
				return; 
			case ETJPackage.STATUS_STATUS_SHEET:
				sequence_StatusStatusSheet(context, (StatusStatusSheet) semanticObject); 
				return; 
			case ETJPackage.STATUS_TIMESHEET:
				sequence_StatusTimesheet(context, (StatusTimesheet) semanticObject); 
				return; 
			case ETJPackage.SUPPLEMENT_ACCOUNT:
				sequence_SupplementAccount(context, (SupplementAccount) semanticObject); 
				return; 
			case ETJPackage.SUPPLEMENT_REPORT:
				sequence_SupplementReport(context, (SupplementReport) semanticObject); 
				return; 
			case ETJPackage.SUPPLEMENT_RESOURCE:
				sequence_SupplementResource(context, (SupplementResource) semanticObject); 
				return; 
			case ETJPackage.SUPPLEMENT_TASK:
				sequence_SupplementTask(context, (SupplementTask) semanticObject); 
				return; 
			case ETJPackage.TAG_FILE:
				sequence_TagFile(context, (TagFile) semanticObject); 
				return; 
			case ETJPackage.TASK:
				sequence_Task(context, (Task) semanticObject); 
				return; 
			case ETJPackage.TASK_ATTRIBUTE:
				sequence_TaskAttribute(context, (TaskAttribute) semanticObject); 
				return; 
			case ETJPackage.TASK_ATTRIBUTES:
				sequence_TaskAttributes(context, (TaskAttributes) semanticObject); 
				return; 
			case ETJPackage.TASK_DEPENDENCY:
				sequence_TaskDependency(context, (TaskDependency) semanticObject); 
				return; 
			case ETJPackage.TASK_PREFIX:
				sequence_TaskPrefix(context, (TaskPrefix) semanticObject); 
				return; 
			case ETJPackage.TASK_ROOT:
				sequence_TaskRoot(context, (TaskRoot) semanticObject); 
				return; 
			case ETJPackage.TASK_STATUS_SHEET:
				sequence_TaskStatusSheet(context, (TaskStatusSheet) semanticObject); 
				return; 
			case ETJPackage.TASK_TIMESHEET:
				sequence_TaskTimesheet(context, (TaskTimesheet) semanticObject); 
				return; 
			case ETJPackage.TIME_FORMAT:
				sequence_TimeFormat(context, (TimeFormat) semanticObject); 
				return; 
			case ETJPackage.TIMEOFF:
				sequence_Timeoff(context, (Timeoff) semanticObject); 
				return; 
			case ETJPackage.TIMESHEET:
				sequence_Timesheet(context, (Timesheet) semanticObject); 
				return; 
			case ETJPackage.TIMESHEET_REPORT:
				sequence_TimesheetReport(context, (TimesheetReport) semanticObject); 
				return; 
			case ETJPackage.TIMEZONE:
				sequence_Timezone(context, (Timezone) semanticObject); 
				return; 
			case ETJPackage.TIMING_RESOLUTION:
				sequence_TimingResolution(context, (TimingResolution) semanticObject); 
				return; 
			case ETJPackage.TITLE:
				sequence_Title(context, (Title) semanticObject); 
				return; 
			case ETJPackage.TOOL_TIP:
				sequence_ToolTip(context, (ToolTip) semanticObject); 
				return; 
			case ETJPackage.TRACKING_SCENARIO:
				sequence_TrackingScenario(context, (TrackingScenario) semanticObject); 
				return; 
			case ETJPackage.TREE_LEVEL:
				sequence_TreeLevel(context, (TreeLevel) semanticObject); 
				return; 
			case ETJPackage.VACATION:
				if (rule == grammarAccess.getResourceAttributeRule()
						|| rule == grammarAccess.getVacationResourceRule()) {
					sequence_VacationResource(context, (Vacation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVacationShiftRule()) {
					sequence_VacationShift(context, (Vacation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPropertyRule()
						|| rule == grammarAccess.getVacationRule()) {
					sequence_Vacation(context, (Vacation) semanticObject); 
					return; 
				}
				else break;
			case ETJPackage.WARN:
				sequence_Warn(context, (Warn) semanticObject); 
				return; 
			case ETJPackage.WEEK_STARTS:
				sequence_WeekStarts(context, (WeekStarts) semanticObject); 
				return; 
			case ETJPackage.WEEKDAYS:
				sequence_Weekdays(context, (Weekdays) semanticObject); 
				return; 
			case ETJPackage.WIDTH:
				sequence_Width(context, (Width) semanticObject); 
				return; 
			case ETJPackage.WORK:
				sequence_Work(context, (Work) semanticObject); 
				return; 
			case ETJPackage.WORK_HOURS:
				sequence_WorkHours(context, (WorkHours) semanticObject); 
				return; 
			case ETJPackage.WORKING_HOURS:
				sequence_WorkingHours(context, (WorkingHours) semanticObject); 
				return; 
			case ETJPackage.YEARLY_WORKING_DAYS:
				sequence_YearlyWorkingDays(context, (YearlyWorkingDays) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     AccountPrefix returns AccountPrefix
	 *     IncludePropertiesAttribute returns AccountPrefix
	 *
	 * Constraint:
	 *     account=[Account|ID]
	 * </pre>
	 */
	protected void sequence_AccountPrefix(ISerializationContext context, AccountPrefix semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getAccountPrefix_Account()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getAccountPrefix_Account()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAccountPrefixAccess().getAccountAccountIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ETJPackage.eINSTANCE.getAccountPrefix_Account(), false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AccountRoot returns AccountRoot
	 *     ReportAttribute returns AccountRoot
	 *
	 * Constraint:
	 *     account=[Account|ID]
	 * </pre>
	 */
	protected void sequence_AccountRoot(ISerializationContext context, AccountRoot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getAccountRoot_Account()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getAccountRoot_Account()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAccountRootAccess().getAccountAccountIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ETJPackage.eINSTANCE.getAccountRoot_Account(), false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AccountShare returns AccountShare
	 *
	 * Constraint:
	 *     (account=[Account|ID] share=XFloat?)
	 * </pre>
	 */
	protected void sequence_AccountShare(ISerializationContext context, AccountShare semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns Account
	 *     Account returns Account
	 *     AccountAttribute returns Account
	 *
	 * Constraint:
	 *     (id=ID? name=STRING attributes+=AccountAttribute*)
	 * </pre>
	 */
	protected void sequence_Account(ISerializationContext context, Account semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Alert returns Alert
	 *
	 * Constraint:
	 *     level=AlertLevel
	 * </pre>
	 */
	protected void sequence_Alert(ISerializationContext context, Alert semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getAlert_Level()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getAlert_Level()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAlertAccess().getLevelAlertLevelEnumRuleCall_1_0(), semanticObject.getLevel());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AllocateResource returns AllocateResource
	 *
	 * Constraint:
	 *     (resource=[Resource|ID] attributes+=AllocateResourceAttribute*)
	 * </pre>
	 */
	protected void sequence_AllocateResource(ISerializationContext context, AllocateResource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns Allocate
	 *     Allocate returns Allocate
	 *
	 * Constraint:
	 *     (resources+=AllocateResource resources+=AllocateResource*)
	 * </pre>
	 */
	protected void sequence_Allocate(ISerializationContext context, Allocate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AllocateResourceAttribute returns Alternative
	 *     Alternative returns Alternative
	 *
	 * Constraint:
	 *     (resources+=[Resource|ID] resources+=[Resource|ID]*)
	 * </pre>
	 */
	protected void sequence_Alternative(ISerializationContext context, Alternative semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Author returns Author
	 *     StatusStatusSheetAttribute returns Author
	 *
	 * Constraint:
	 *     resource=[Resource|ID]
	 * </pre>
	 */
	protected void sequence_Author(ISerializationContext context, Author semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getAuthor_Resource()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getAuthor_Resource()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAuthorAccess().getResourceResourceIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ETJPackage.eINSTANCE.getAuthor_Resource(), false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns Balance
	 *     ReportAttribute returns Balance
	 *     Balance returns Balance
	 *
	 * Constraint:
	 *     (cost=[Account|ID] revenue=[Account|ID])
	 * </pre>
	 */
	protected void sequence_Balance(ISerializationContext context, Balance semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getBalance_Cost()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getBalance_Cost()));
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getBalance_Revenue()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getBalance_Revenue()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBalanceAccess().getCostAccountIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ETJPackage.eINSTANCE.getBalance_Cost(), false));
		feeder.accept(grammarAccess.getBalanceAccess().getRevenueAccountIDTerminalRuleCall_2_0_1(), semanticObject.eGet(ETJPackage.eINSTANCE.getBalance_Revenue(), false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ResourceAttribute returns BookingResource
	 *     BookingResource returns BookingResource
	 *
	 * Constraint:
	 *     (task=[Task|ID] booking=Booking)
	 * </pre>
	 */
	protected void sequence_BookingResource(ISerializationContext context, BookingResource semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getBookingResource_Task()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getBookingResource_Task()));
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getBookingResource_Booking()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getBookingResource_Booking()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBookingResourceAccess().getTaskTaskIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ETJPackage.eINSTANCE.getBookingResource_Task(), false));
		feeder.accept(grammarAccess.getBookingResourceAccess().getBookingBookingParserRuleCall_2_0(), semanticObject.getBooking());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     BookingTask returns BookingTask
	 *
	 * Constraint:
	 *     (resource=[Resource|ID] booking=Booking)
	 * </pre>
	 */
	protected void sequence_BookingTask(ISerializationContext context, BookingTask semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getBookingTask_Resource()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getBookingTask_Resource()));
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getBookingTask_Booking()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getBookingTask_Booking()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBookingTaskAccess().getResourceResourceIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ETJPackage.eINSTANCE.getBookingTask_Resource(), false));
		feeder.accept(grammarAccess.getBookingTaskAccess().getBookingBookingParserRuleCall_2_0(), semanticObject.getBooking());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Booking returns Booking
	 *
	 * Constraint:
	 *     (interval=Interval4 (overtime=INT | sloppy=INT)*)
	 * </pre>
	 */
	protected void sequence_Booking(ISerializationContext context, Booking semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns CellColor
	 *     CellColor returns CellColor
	 *     ColumnAttribute returns CellColor
	 *
	 * Constraint:
	 *     (expression=LogicalExpression color=RGB)
	 * </pre>
	 */
	protected void sequence_CellColor(ISerializationContext context, CellColor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getCellColor_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getCellColor_Expression()));
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getCellColor_Color()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getCellColor_Color()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCellColorAccess().getExpressionLogicalExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getCellColorAccess().getColorRGBParserRuleCall_2_0(), semanticObject.getColor());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CellText returns CellText
	 *     ColumnAttribute returns CellText
	 *
	 * Constraint:
	 *     (expresssion=LogicalExpression text=STRING)
	 * </pre>
	 */
	protected void sequence_CellText(ISerializationContext context, CellText semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getCellText_Expresssion()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getCellText_Expresssion()));
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getCellText_Text()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getCellText_Text()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCellTextAccess().getExpresssionLogicalExpressionParserRuleCall_1_0(), semanticObject.getExpresssion());
		feeder.accept(grammarAccess.getCellTextAccess().getTextSTRINGTerminalRuleCall_2_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ChargeSet returns ChargeSet
	 *
	 * Constraint:
	 *     (accountShares+=AccountShare accountShares+=AccountShare*)
	 * </pre>
	 */
	protected void sequence_ChargeSet(ISerializationContext context, ChargeSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Charge returns Charge
	 *
	 * Constraint:
	 *     (amount=XFloat applies=ChargeApplies)
	 * </pre>
	 */
	protected void sequence_Charge(ISerializationContext context, Charge semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getCharge_Amount()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getCharge_Amount()));
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getCharge_Applies()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getCharge_Applies()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChargeAccess().getAmountXFloatParserRuleCall_1_0(), semanticObject.getAmount());
		feeder.accept(grammarAccess.getChargeAccess().getAppliesChargeAppliesEnumRuleCall_2_0(), semanticObject.getApplies());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Column returns Column
	 *
	 * Constraint:
	 *     ((id=ColumnId | ext=ExtendedResourceAttributeColumn) attributes+=ColumnAttribute*)
	 * </pre>
	 */
	protected void sequence_Column(ISerializationContext context, Column semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReportAttribute returns Columns
	 *     Columns returns Columns
	 *
	 * Constraint:
	 *     (columns+=Column columns+=Column*)
	 * </pre>
	 */
	protected void sequence_Columns(ISerializationContext context, Columns semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Complete returns Complete
	 *
	 * Constraint:
	 *     complete=XFloat
	 * </pre>
	 */
	protected void sequence_Complete(ISerializationContext context, Complete semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getComplete_Complete()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getComplete_Complete()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompleteAccess().getCompleteXFloatParserRuleCall_1_0(), semanticObject.getComplete());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns Copyright
	 *     Copyright returns Copyright
	 *
	 * Constraint:
	 *     text=STRING
	 * </pre>
	 */
	protected void sequence_Copyright(ISerializationContext context, Copyright semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getCopyright_Text()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getCopyright_Text()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCopyrightAccess().getTextSTRINGTerminalRuleCall_1_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AccountAttribute returns Credit
	 *     Credit returns Credit
	 *
	 * Constraint:
	 *     (date=ISODATE description=STRING amount=XFloat)
	 * </pre>
	 */
	protected void sequence_Credit(ISerializationContext context, Credit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getCredit_Date()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getCredit_Date()));
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getCredit_Description()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getCredit_Description()));
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getCredit_Amount()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getCredit_Amount()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCreditAccess().getDateISODATEParserRuleCall_1_0(), semanticObject.getDate());
		feeder.accept(grammarAccess.getCreditAccess().getDescriptionSTRINGTerminalRuleCall_2_0(), semanticObject.getDescription());
		feeder.accept(grammarAccess.getCreditAccess().getAmountXFloatParserRuleCall_3_0(), semanticObject.getAmount());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Criterion returns Criterion
	 *
	 * Constraint:
	 *     (scenario=[Scenario|ID]? columnId=ColumnId direction=CriterionDirection)
	 * </pre>
	 */
	protected void sequence_Criterion(ISerializationContext context, Criterion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProjectAttribute returns Currency
	 *     Currency returns Currency
	 *
	 * Constraint:
	 *     currency=STRING
	 * </pre>
	 */
	protected void sequence_Currency(ISerializationContext context, Currency semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getCurrency_Currency()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getCurrency_Currency()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCurrencyAccess().getCurrencySTRINGTerminalRuleCall_1_0(), semanticObject.getCurrency());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProjectAttribute returns DailyWorkingHours
	 *     DailyWorkingHours returns DailyWorkingHours
	 *
	 * Constraint:
	 *     dailyWorkingHours=XFloat
	 * </pre>
	 */
	protected void sequence_DailyWorkingHours(ISerializationContext context, DailyWorkingHours semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getDailyWorkingHours_DailyWorkingHours()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getDailyWorkingHours_DailyWorkingHours()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDailyWorkingHoursAccess().getDailyWorkingHoursXFloatParserRuleCall_1_0(), semanticObject.getDailyWorkingHours());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExportAttribute returns Definitions
	 *     Definitions returns Definitions
	 *
	 * Constraint:
	 *     (all?='*' | none?='-')
	 * </pre>
	 */
	protected void sequence_Definitions(ISerializationContext context, Definitions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExportAttribute returns Defintions
	 *     Definitions returns Defintions
	 *
	 * Constraint:
	 *     (flags?='flags' | resources?='resources' | tasks?='tasks' | project?='project' | projectids?='projectids')*
	 * </pre>
	 */
	protected void sequence_Definitions(ISerializationContext context, Defintions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Depends returns Depends
	 *
	 * Constraint:
	 *     (dependency+=TaskDependency dependency+=TaskDependency*)
	 * </pre>
	 */
	protected void sequence_Depends(ISerializationContext context, Depends semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GapDuration returns DurationQuantity
	 *     GapLength returns DurationQuantity
	 *     DurationQuantity returns DurationQuantity
	 *
	 * Constraint:
	 *     (value=XFloat unit=TimeUnit)
	 * </pre>
	 */
	protected void sequence_DurationQuantity(ISerializationContext context, DurationQuantity semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getDurationQuantity_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getDurationQuantity_Value()));
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getDurationQuantity_Unit()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getDurationQuantity_Unit()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDurationQuantityAccess().getValueXFloatParserRuleCall_0_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getDurationQuantityAccess().getUnitTimeUnitEnumRuleCall_1_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Duration returns Duration
	 *
	 * Constraint:
	 *     duration=DurationQuantity
	 * </pre>
	 */
	protected void sequence_Duration(ISerializationContext context, Duration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getDuration_Duration()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getDuration_Duration()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDurationAccess().getDurationDurationQuantityParserRuleCall_1_0(), semanticObject.getDuration());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ResourceAttribute returns Efficiency
	 *     Efficiency returns Efficiency
	 *
	 * Constraint:
	 *     efficiency=XFloat
	 * </pre>
	 */
	protected void sequence_Efficiency(ISerializationContext context, Efficiency semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getEfficiency_Efficiency()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getEfficiency_Efficiency()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEfficiencyAccess().getEfficiencyXFloatParserRuleCall_1_0(), semanticObject.getEfficiency());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Effort returns Effort
	 *
	 * Constraint:
	 *     effort=DurationQuantity
	 * </pre>
	 */
	protected void sequence_Effort(ISerializationContext context, Effort semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getEffort_Effort()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getEffort_Effort()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEffortAccess().getEffortDurationQuantityParserRuleCall_1_0(), semanticObject.getEffort());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ResourceAttribute returns Email
	 *     Email returns Email
	 *
	 * Constraint:
	 *     address=STRING
	 * </pre>
	 */
	protected void sequence_Email(ISerializationContext context, Email semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getEmail_Address()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getEmail_Address()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEmailAccess().getAddressSTRINGTerminalRuleCall_1_0(), semanticObject.getAddress());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EndCredit returns EndCredit
	 *
	 * Constraint:
	 *     credit=XFloat
	 * </pre>
	 */
	protected void sequence_EndCredit(ISerializationContext context, EndCredit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getEndCredit_Credit()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getEndCredit_Credit()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEndCreditAccess().getCreditXFloatParserRuleCall_1_0(), semanticObject.getCredit());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReportAttribute returns End
	 *     IcalReportAttribute returns End
	 *     ExportAttribute returns End
	 *     NewTaskAttribute returns End
	 *     NikuReportAttribute returns End
	 *     End returns End
	 *     StatusSheetReportAttribute returns End
	 *     TaskTimesheetAttribute returns End
	 *     TimesheetReportAttribute returns End
	 *     ColumnAttribute returns End
	 *
	 * Constraint:
	 *     end=ISODATE
	 * </pre>
	 */
	protected void sequence_End(ISerializationContext context, End semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getEnd_End()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getEnd_End()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEndAccess().getEndISODATEParserRuleCall_1_0_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns Export
	 *     Export returns Export
	 *
	 * Constraint:
	 *     (id=ID? filename=STRING attributes+=ExportAttribute*)
	 * </pre>
	 */
	protected void sequence_Export(ISerializationContext context, Export semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProjectAttribute returns ExtendResource
	 *     ExtendResource returns ExtendResource
	 *
	 * Constraint:
	 *     extends+=Extend*
	 * </pre>
	 */
	protected void sequence_ExtendResource(ISerializationContext context, ExtendResource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProjectAttribute returns ExtendTask
	 *     ExtendTask returns ExtendTask
	 *
	 * Constraint:
	 *     extends+=Extend*
	 * </pre>
	 */
	protected void sequence_ExtendTask(ISerializationContext context, ExtendTask semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Extend returns Extend
	 *
	 * Constraint:
	 *     (name=ID description=STRING (inherit?='inherit' | scenariospecific?='scenariospecific')*)
	 * </pre>
	 */
	protected void sequence_Extend(ISerializationContext context, Extend semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ColumnAttribute returns ExtendedResourceAttributeColumn
	 *     ExtendedResourceAttributeColumn returns ExtendedResourceAttributeColumn
	 *
	 * Constraint:
	 *     extension=[Extend|ID]
	 * </pre>
	 */
	protected void sequence_ExtendedResourceAttributeColumn(ISerializationContext context, ExtendedResourceAttributeColumn semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getExtendedResourceAttributeColumn_Extension()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getExtendedResourceAttributeColumn_Extension()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExtendedResourceAttributeColumnAccess().getExtensionExtendIDTerminalRuleCall_0_1(), semanticObject.eGet(ETJPackage.eINSTANCE.getExtendedResourceAttributeColumn_Extension(), false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ResourceAttribute returns ExtendedResourceAttribute
	 *     ExtendedResourceAttribute returns ExtendedResourceAttribute
	 *
	 * Constraint:
	 *     (extend=[Extend|QualifiedName] value=STRING)
	 * </pre>
	 */
	protected void sequence_ExtendedResourceAttribute(ISerializationContext context, ExtendedResourceAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getExtendedResourceAttribute_Extend()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getExtendedResourceAttribute_Extend()));
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getExtendedResourceAttribute_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getExtendedResourceAttribute_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExtendedResourceAttributeAccess().getExtendExtendQualifiedNameParserRuleCall_0_0_1(), semanticObject.eGet(ETJPackage.eINSTANCE.getExtendedResourceAttribute_Extend(), false));
		feeder.accept(grammarAccess.getExtendedResourceAttributeAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExtendedTaskAttribute returns ExtendedTaskAttribute
	 *
	 * Constraint:
	 *     (extend=[Extend|ID] value=STRING)
	 * </pre>
	 */
	protected void sequence_ExtendedTaskAttribute(ISerializationContext context, ExtendedTaskAttribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getExtendedTaskAttribute_Extend()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getExtendedTaskAttribute_Extend()));
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getExtendedTaskAttribute_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getExtendedTaskAttribute_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExtendedTaskAttributeAccess().getExtendExtendIDTerminalRuleCall_0_0_1(), semanticObject.eGet(ETJPackage.eINSTANCE.getExtendedTaskAttribute_Extend(), false));
		feeder.accept(grammarAccess.getExtendedTaskAttributeAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ResourceAttribute returns Fail
	 *     Fail returns Fail
	 *
	 * Constraint:
	 *     expression=LogicalExpression
	 * </pre>
	 */
	protected void sequence_Fail(ISerializationContext context, Fail semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getFail_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getFail_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFailAccess().getExpressionLogicalExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns Flags
	 *     AccountAttribute returns Flags
	 *     ReportAttribute returns Flags
	 *     ResourceAttribute returns Flags
	 *     Flags returns Flags
	 *     StatusStatusSheetAttribute returns Flags
	 *     StatusTimesheetAttribute returns Flags
	 *
	 * Constraint:
	 *     (flags+=ID flags+=ID*)
	 * </pre>
	 */
	protected void sequence_Flags(ISerializationContext context, Flags semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FontColor returns FontColor
	 *     ColumnAttribute returns FontColor
	 *
	 * Constraint:
	 *     color=STRING
	 * </pre>
	 */
	protected void sequence_FontColor(ISerializationContext context, FontColor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getFontColor_Color()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getFontColor_Color()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFontColorAccess().getColorSTRINGTerminalRuleCall_1_0(), semanticObject.getColor());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReportAttribute returns Formats
	 *     NikuReportAttribute returns Formats
	 *     Formats returns Formats
	 *
	 * Constraint:
	 *     (formats+=ReportFormat formats+=ReportFormat*)
	 * </pre>
	 */
	protected void sequence_Formats(ISerializationContext context, Formats semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (
	 *         (level=INT date=ISODATE?) | 
	 *         scenario=[Scenario|ID] | 
	 *         parentId=ID | 
	 *         (task=[Task|ID] scenario=[Scenario|ID] distance=INT) | 
	 *         (resource=[Resource|ID] scenario=[Scenario|ID]) | 
	 *         (task=[Task|ID] scenario=[Scenario|ID]) | 
	 *         scenario=[Scenario|ID] | 
	 *         scenario=[Scenario|ID] | 
	 *         (resource=[Resource|ID] scenario=[Scenario|ID])
	 *     )?
	 * </pre>
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Global returns Global
	 *
	 * Constraint:
	 *     ((project=Project properties+=Property+) | properties+=Property+)?
	 * </pre>
	 */
	protected void sequence_Global(ISerializationContext context, Global semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     HAlign returns HAlign
	 *     ColumnAttribute returns HAlign
	 *
	 * Constraint:
	 *     (expression=LogicalExpression justification=Justification)
	 * </pre>
	 */
	protected void sequence_HAlign(ISerializationContext context, HAlign semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getHAlign_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getHAlign_Expression()));
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getHAlign_Justification()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getHAlign_Justification()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHAlignAccess().getExpressionLogicalExpressionParserRuleCall_0_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getHAlignAccess().getJustificationJustificationEnumRuleCall_1_0(), semanticObject.getJustification());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReportAttribute returns HideAccount
	 *     HideAccount returns HideAccount
	 *
	 * Constraint:
	 *     expression=LogicalFlagExpression
	 * </pre>
	 */
	protected void sequence_HideAccount(ISerializationContext context, HideAccount semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getHideAccount_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getHideAccount_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHideAccountAccess().getExpressionLogicalFlagExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReportAttribute returns HideJournalEntry
	 *     IcalReportAttribute returns HideJournalEntry
	 *     HideJournalEntry returns HideJournalEntry
	 *
	 * Constraint:
	 *     expression=LogicalFlagExpression
	 * </pre>
	 */
	protected void sequence_HideJournalEntry(ISerializationContext context, HideJournalEntry semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getHideJournalEntry_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getHideJournalEntry_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHideJournalEntryAccess().getExpressionLogicalFlagExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NavigatorAttribute returns HideReport
	 *     HideReport returns HideReport
	 *
	 * Constraint:
	 *     expression=LogicalExpression
	 * </pre>
	 */
	protected void sequence_HideReport(ISerializationContext context, HideReport semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getHideReport_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getHideReport_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHideReportAccess().getExpressionLogicalExpressionParserRuleCall_2_0_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReportAttribute returns HideResource
	 *     IcalReportAttribute returns HideResource
	 *     ExportAttribute returns HideResource
	 *     NikuReportAttribute returns HideResource
	 *     HideResource returns HideResource
	 *     StatusSheetReportAttribute returns HideResource
	 *     TimesheetReportAttribute returns HideResource
	 *
	 * Constraint:
	 *     expression=LogicalExpression
	 * </pre>
	 */
	protected void sequence_HideResource(ISerializationContext context, HideResource semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getHideResource_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getHideResource_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHideResourceAccess().getExpressionLogicalExpressionParserRuleCall_2_0_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReportAttribute returns HideTask
	 *     IcalReportAttribute returns HideTask
	 *     ExportAttribute returns HideTask
	 *     NikuReportAttribute returns HideTask
	 *     HideTask returns HideTask
	 *     StatusSheetReportAttribute returns HideTask
	 *
	 * Constraint:
	 *     expression=LogicalExpression
	 * </pre>
	 */
	protected void sequence_HideTask(ISerializationContext context, HideTask semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getHideTask_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getHideTask_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHideTaskAccess().getExpressionLogicalExpressionParserRuleCall_2_0_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ISODATE returns ISODATE
	 *
	 * Constraint:
	 *     (date=ExtDate | (date=ExtDate duration=DurationQuantity))
	 * </pre>
	 */
	protected void sequence_ISODATE(ISerializationContext context, ISODATE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns IcalReport
	 *     IcalReport returns IcalReport
	 *
	 * Constraint:
	 *     (filename=STRING attributes+=IcalReportAttribute*)
	 * </pre>
	 */
	protected void sequence_IcalReport(ISerializationContext context, IcalReport semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns IncludeProperties
	 *     IncludeProperties returns IncludeProperties
	 *
	 * Constraint:
	 *     (importURI=STRING attributes+=IncludePropertiesAttribute*)
	 * </pre>
	 */
	protected void sequence_IncludeProperties(ISerializationContext context, IncludeProperties semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProjectAttribute returns Include
	 *     Include returns Include
	 *
	 * Constraint:
	 *     importURI=STRING
	 * </pre>
	 */
	protected void sequence_Include(ISerializationContext context, Include semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getInclude_ImportURI()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getInclude_ImportURI()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIncludeAccess().getImportURISTRINGTerminalRuleCall_1_0(), semanticObject.getImportURI());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Interval1 returns Interval1
	 *
	 * Constraint:
	 *     (start=ISODATE (end=ISODATE | duration=DurationQuantity))
	 * </pre>
	 */
	protected void sequence_Interval1(ISerializationContext context, Interval1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Interval2 returns Interval2
	 *
	 * Constraint:
	 *     (start=ISODATE (end=ISODATE | duration=DurationQuantity))
	 * </pre>
	 */
	protected void sequence_Interval2(ISerializationContext context, Interval2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Interval3 returns Interval3
	 *
	 * Constraint:
	 *     (start=ISODATE (end=ISODATE | duration=DurationQuantity)?)
	 * </pre>
	 */
	protected void sequence_Interval3(ISerializationContext context, Interval3 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Interval4 returns Interval4
	 *
	 * Constraint:
	 *     (start=ISODATE (end=ISODATE | duration=DurationQuantity)?)
	 * </pre>
	 */
	protected void sequence_Interval4(ISerializationContext context, Interval4 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReportAttribute returns JournalAttributes
	 *     JournalAttributes returns JournalAttributes
	 *
	 * Constraint:
	 *     (args+=JournalAttributeValues args+=JournalAttributeValues*)
	 * </pre>
	 */
	protected void sequence_JournalAttributes(ISerializationContext context, JournalAttributes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProjectAttribute returns JournalEntry
	 *     ResourceAttribute returns JournalEntry
	 *     JournalEntry returns JournalEntry
	 *
	 * Constraint:
	 *     (date=ISODATE headline=STRING (alert=Alert | author=Author | details=Details | summary=Summary)*)
	 * </pre>
	 */
	protected void sequence_JournalEntry(ISerializationContext context, JournalEntry semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReportAttribute returns JournalMode
	 *     JournalMode returns JournalMode
	 *
	 * Constraint:
	 *     mode=JournalModeValue
	 * </pre>
	 */
	protected void sequence_JournalMode(ISerializationContext context, JournalMode semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getJournalMode_Mode()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getJournalMode_Mode()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getJournalModeAccess().getModeJournalModeValueEnumRuleCall_1_0(), semanticObject.getMode());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LeaveDetails returns LeaveDetails
	 *
	 * Constraint:
	 *     (type=LeaveType (name=ID | name=STRING)? interval=Interval3)
	 * </pre>
	 */
	protected void sequence_LeaveDetails(ISerializationContext context, LeaveDetails semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns Leaves
	 *     Leaves returns Leaves
	 *     ResourceAttribute returns Leaves
	 *
	 * Constraint:
	 *     (details+=LeaveDetails details+=LeaveDetails*)
	 * </pre>
	 */
	protected void sequence_Leaves(ISerializationContext context, Leaves semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Length returns Length
	 *
	 * Constraint:
	 *     length=DurationQuantity
	 * </pre>
	 */
	protected void sequence_Length(ISerializationContext context, Length semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getLength_Length()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getLength_Length()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLengthAccess().getLengthDurationQuantityParserRuleCall_1_0(), semanticObject.getLength());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LimitAttribute returns LimitAttribute
	 *
	 * Constraint:
	 *     (end=ISODATE | period=Interval1 | (resources+=[Resource|ID] resources+=[Resource|ID]*) | start=ISODATE)
	 * </pre>
	 */
	protected void sequence_LimitAttribute(ISerializationContext context, LimitAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DailyMax returns Limit
	 *     DailyMin returns Limit
	 *     LimitsAttribute returns Limit
	 *     Maximum returns Limit
	 *     Minimum returns Limit
	 *     MonthlyMax returns Limit
	 *     MonthlyMin returns Limit
	 *     WeeklyMax returns Limit
	 *     WeeklyMin returns Limit
	 *     Limit returns Limit
	 *
	 * Constraint:
	 *     (duration=DurationQuantity attributes+=LimitAttribute*)
	 * </pre>
	 */
	protected void sequence_Limit(ISerializationContext context, Limit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns Limits
	 *     ResourceAttribute returns Limits
	 *     Limits returns Limits
	 *
	 * Constraint:
	 *     attributes+=LimitsAttribute*
	 * </pre>
	 */
	protected void sequence_Limits(ISerializationContext context, Limits semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ListType returns ListType
	 *     ColumnAttribute returns ListType
	 *
	 * Constraint:
	 *     type=ListTypeValues
	 * </pre>
	 */
	protected void sequence_ListType(ISerializationContext context, ListType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getListType_Type()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getListType_Type()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getListTypeAccess().getTypeListTypeValuesEnumRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReportAttribute returns LoadUnit
	 *     LoadUnit returns LoadUnit
	 *
	 * Constraint:
	 *     unit=LoadDisplayUnit
	 * </pre>
	 */
	protected void sequence_LoadUnit(ISerializationContext context, LoadUnit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getLoadUnit_Unit()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getLoadUnit_Unit()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoadUnitAccess().getUnitLoadDisplayUnitEnumRuleCall_1_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicalPrimaryExpression returns LogicalAbsoluteIdExression
	 *     LogicalAbsoluteIdExpression returns LogicalAbsoluteIdExression
	 *
	 * Constraint:
	 *     value=AbsoluteId
	 * </pre>
	 */
	protected void sequence_LogicalAbsoluteIdExpression(ISerializationContext context, LogicalAbsoluteIdExression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getLogicalAbsoluteIdExression_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getLogicalAbsoluteIdExression_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicalAbsoluteIdExpressionAccess().getValueAbsoluteIdParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicalAndExpression returns LogicalExpression
	 *
	 * Constraint:
	 *     (leftOperant=LogicalEqualityExpression (op=LEOpAnd rightOperand=LogicalEqualityExpression)?)
	 * </pre>
	 */
	protected void sequence_LogicalAndExpression(ISerializationContext context, LogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicalPrimaryExpression returns LogicalBooleanLiteral
	 *     LogicalBooleanLiteral returns LogicalBooleanLiteral
	 *
	 * Constraint:
	 *     isTrue?='true'?
	 * </pre>
	 */
	protected void sequence_LogicalBooleanLiteral(ISerializationContext context, LogicalBooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicalEqualityExpression returns LogicalExpression
	 *
	 * Constraint:
	 *     (leftOperant=LogicalRelationalExpression (op=LEOpEquality rightOperand=LogicalRelationalExpression)?)
	 * </pre>
	 */
	protected void sequence_LogicalEqualityExpression(ISerializationContext context, LogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicalPrimaryExpression returns LogicalFlagExpression
	 *     LogicalFlagLiteral returns LogicalFlagExpression
	 *
	 * Constraint:
	 *     (scenario=[Scenario|ID] columId=ColumnId)
	 * </pre>
	 */
	protected void sequence_LogicalFlagLiteral(ISerializationContext context, LogicalFlagExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getLogicalFlagExpression_Scenario()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getLogicalFlagExpression_Scenario()));
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getLogicalFlagExpression_ColumId()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getLogicalFlagExpression_ColumId()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicalFlagLiteralAccess().getScenarioScenarioIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ETJPackage.eINSTANCE.getLogicalFlagExpression_Scenario(), false));
		feeder.accept(grammarAccess.getLogicalFlagLiteralAccess().getColumIdColumnIdEnumRuleCall_3_0(), semanticObject.getColumId());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicalPrimaryExpression returns LogicalFunctionExpression
	 *     LogicalFunctionExpression returns LogicalFunctionExpression
	 *
	 * Constraint:
	 *     function=Function
	 * </pre>
	 */
	protected void sequence_LogicalFunctionExpression(ISerializationContext context, LogicalFunctionExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getLogicalFunctionExpression_Function()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getLogicalFunctionExpression_Function()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicalFunctionExpressionAccess().getFunctionFunctionParserRuleCall_1_0(), semanticObject.getFunction());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicalPrimaryExpression returns LogicalDateLiteral
	 *     LogicalISODateLiteral returns LogicalDateLiteral
	 *
	 * Constraint:
	 *     value=ISODATE
	 * </pre>
	 */
	protected void sequence_LogicalISODateLiteral(ISerializationContext context, LogicalDateLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getLogicalDateLiteral_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getLogicalDateLiteral_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicalISODateLiteralAccess().getValueISODATEParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicalPrimaryExpression returns LogicalNumeralLiteral
	 *     LogicalNumeralLiteral returns LogicalNumeralLiteral
	 *
	 * Constraint:
	 *     value=XFloat
	 * </pre>
	 */
	protected void sequence_LogicalNumeralLiteral(ISerializationContext context, LogicalNumeralLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getLogicalNumeralLiteral_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getLogicalNumeralLiteral_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicalNumeralLiteralAccess().getValueXFloatParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicalExpression returns LogicalExpression
	 *     LogicalOrExpression returns LogicalExpression
	 *     LogicalPrimaryExpression returns LogicalExpression
	 *     LogicalPrenthesizedExpression returns LogicalExpression
	 *
	 * Constraint:
	 *     (leftOperant=LogicalAndExpression (op=LEOpOr rightOperand=LogicalAndExpression)?)
	 * </pre>
	 */
	protected void sequence_LogicalOrExpression(ISerializationContext context, LogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicalRelationalExpression returns LogicalExpression
	 *
	 * Constraint:
	 *     (leftOperant=LogicalPrimaryExpression (op=OpCompare rightOperand=LogicalPrimaryExpression)?)
	 * </pre>
	 */
	protected void sequence_LogicalRelationalExpression(ISerializationContext context, LogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicalPrimaryExpression returns LogicalStringLiteral
	 *     LogicalStringLiteral returns LogicalStringLiteral
	 *
	 * Constraint:
	 *     (value=STRING | macro=MacroCall)
	 * </pre>
	 */
	protected void sequence_LogicalStringLiteral(ISerializationContext context, LogicalStringLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MacroCall returns MacroCall
	 *     ReportAttribute returns MacroCall
	 *     IcalReportAttribute returns MacroCall
	 *     ExportAttribute returns MacroCall
	 *     NewTaskAttribute returns MacroCall
	 *     NikuReportAttribute returns MacroCall
	 *     End returns MacroCall
	 *     Start returns MacroCall
	 *     StatusSheetReportAttribute returns MacroCall
	 *     TaskTimesheetAttribute returns MacroCall
	 *     TimesheetReportAttribute returns MacroCall
	 *     ColumnAttribute returns MacroCall
	 *     ExtDate returns MacroCall
	 *
	 * Constraint:
	 *     (macro=[Macro|QualifiedName] | buildin=BuildInMacro)
	 * </pre>
	 */
	protected void sequence_MacroCall(ISerializationContext context, MacroCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns Macro
	 *     Macro returns Macro
	 *
	 * Constraint:
	 *     (id=ID (value=STRING | properties+=Property)*)
	 * </pre>
	 */
	protected void sequence_Macro(ISerializationContext context, Macro semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ResourceAttribute returns Managers
	 *     Managers returns Managers
	 *
	 * Constraint:
	 *     (resources+=[Resource|ID] resources+=[Resource|ID]*)
	 * </pre>
	 */
	protected void sequence_Managers(ISerializationContext context, Managers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AllocateResourceAttribute returns Mandatory
	 *     Mandatory returns Mandatory
	 *
	 * Constraint:
	 *     mandatory?='mandatory'
	 * </pre>
	 */
	protected void sequence_Mandatory(ISerializationContext context, Mandatory semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getMandatory_Mandatory()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getMandatory_Mandatory()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMandatoryAccess().getMandatoryMandatoryKeyword_0(), semanticObject.isMandatory());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MaxEnd returns MaxEnd
	 *
	 * Constraint:
	 *     maxEnd=ISODATE
	 * </pre>
	 */
	protected void sequence_MaxEnd(ISerializationContext context, MaxEnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getMaxEnd_MaxEnd()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getMaxEnd_MaxEnd()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMaxEndAccess().getMaxEndISODATEParserRuleCall_1_0(), semanticObject.getMaxEnd());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MaxStart returns MaxStart
	 *
	 * Constraint:
	 *     maxStart=ISODATE
	 * </pre>
	 */
	protected void sequence_MaxStart(ISerializationContext context, MaxStart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getMaxStart_MaxStart()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getMaxStart_MaxStart()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMaxStartAccess().getMaxStartISODATEParserRuleCall_1_0(), semanticObject.getMaxStart());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Milestone returns Milestone
	 *
	 * Constraint:
	 *     milestone?='milestone'
	 * </pre>
	 */
	protected void sequence_Milestone(ISerializationContext context, Milestone semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getMilestone_Milestone()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getMilestone_Milestone()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMilestoneAccess().getMilestoneMilestoneKeyword_0(), semanticObject.isMilestone());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MinEnd returns MinEnd
	 *
	 * Constraint:
	 *     minEnd=ISODATE
	 * </pre>
	 */
	protected void sequence_MinEnd(ISerializationContext context, MinEnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getMinEnd_MinEnd()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getMinEnd_MinEnd()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMinEndAccess().getMinEndISODATEParserRuleCall_1_0(), semanticObject.getMinEnd());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MinStart returns MinStart
	 *
	 * Constraint:
	 *     minStart=ISODATE
	 * </pre>
	 */
	protected void sequence_MinStart(ISerializationContext context, MinStart semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getMinStart_MinStart()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getMinStart_MinStart()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMinStartAccess().getMinStartISODATEParserRuleCall_1_0(), semanticObject.getMinStart());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns Navigator
	 *     Navigator returns Navigator
	 *
	 * Constraint:
	 *     (id=ID attributes+=NavigatorAttribute*)
	 * </pre>
	 */
	protected void sequence_Navigator(ISerializationContext context, Navigator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NewTask returns NewTask
	 *     TimesheetAttribute returns NewTask
	 *
	 * Constraint:
	 *     (id=ID text=STRING attributes+=NewTaskAttribute*)
	 * </pre>
	 */
	protected void sequence_NewTask(ISerializationContext context, NewTask semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns NikuReport
	 *     NikuReport returns NikuReport
	 *
	 * Constraint:
	 *     (filename=STRING attributes+=NikuReportAttribute*)
	 * </pre>
	 */
	protected void sequence_NikuReport(ISerializationContext context, NikuReport semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Note returns Note
	 *
	 * Constraint:
	 *     note=STRING
	 * </pre>
	 */
	protected void sequence_Note(ISerializationContext context, Note semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getNote_Note()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getNote_Note()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNoteAccess().getNoteSTRINGTerminalRuleCall_1_0(), semanticObject.getNote());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProjectAttribute returns Now
	 *     Now returns Now
	 *
	 * Constraint:
	 *     now=ISODATE
	 * </pre>
	 */
	protected void sequence_Now(ISerializationContext context, Now semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getNow_Now()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getNow_Now()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNowAccess().getNowISODATEParserRuleCall_1_0(), semanticObject.getNow());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReportAttribute returns Period
	 *     IcalReportAttribute returns Period
	 *     ExportAttribute returns Period
	 *     NikuReportAttribute returns Period
	 *     Period returns Period
	 *     StatusSheetReportAttribute returns Period
	 *     TimesheetReportAttribute returns Period
	 *     ColumnAttribute returns Period
	 *
	 * Constraint:
	 *     period=Interval2
	 * </pre>
	 */
	protected void sequence_Period(ISerializationContext context, Period semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getPeriod_Period()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getPeriod_Period()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPeriodAccess().getPeriodInterval2ParserRuleCall_1_0(), semanticObject.getPeriod());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AllocateResourceAttribute returns Persistent
	 *     Persistent returns Persistent
	 *
	 * Constraint:
	 *     persistent?='persistent'
	 * </pre>
	 */
	protected void sequence_Persistent(ISerializationContext context, Persistent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getPersistent_Persistent()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getPersistent_Persistent()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPersistentAccess().getPersistentPersistentKeyword_0(), semanticObject.isPersistent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NewTaskAttribute returns Priority
	 *     Priority returns Priority
	 *     TaskTimesheetAttribute returns Priority
	 *
	 * Constraint:
	 *     priority=INT
	 * </pre>
	 */
	protected void sequence_Priority(ISerializationContext context, Priority semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getPriority_Priority()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getPriority_Priority()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPriorityAccess().getPriorityINTTerminalRuleCall_1_0(), semanticObject.getPriority());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProjectId returns ProjectId
	 *
	 * Constraint:
	 *     projectId=ID
	 * </pre>
	 */
	protected void sequence_ProjectId(ISerializationContext context, ProjectId semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getProjectId_ProjectId()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getProjectId_ProjectId()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProjectIdAccess().getProjectIdIDTerminalRuleCall_1_0(), semanticObject.getProjectId());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns ProjectIds
	 *     ProjectIds returns ProjectIds
	 *
	 * Constraint:
	 *     (ids+=ID ids+=ID*)
	 * </pre>
	 */
	protected void sequence_ProjectIds(ISerializationContext context, ProjectIds semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Project returns Project
	 *
	 * Constraint:
	 *     (id=ID? name=STRING version=STRING? interval=Interval2 attributes+=ProjectAttribute*)
	 * </pre>
	 */
	protected void sequence_Project(ISerializationContext context, Project semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReportAttribute returns PurgeReport
	 *     PurgeReport returns PurgeReport
	 *
	 * Constraint:
	 *     listAttribute=PurgeReportAttribute
	 * </pre>
	 */
	protected void sequence_PurgeReport(ISerializationContext context, PurgeReport semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getPurgeReport_ListAttribute()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getPurgeReport_ListAttribute()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPurgeReportAccess().getListAttributePurgeReportAttributeEnumRuleCall_1_0(), semanticObject.getListAttribute());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ResourceAttribute returns PurgeResource
	 *     PurgeResource returns PurgeResource
	 *
	 * Constraint:
	 *     listAttribute=PurgeResourceAttribute
	 * </pre>
	 */
	protected void sequence_PurgeResource(ISerializationContext context, PurgeResource semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getPurgeResource_ListAttribute()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getPurgeResource_ListAttribute()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPurgeResourceAccess().getListAttributePurgeResourceAttributeEnumRuleCall_1_0(), semanticObject.getListAttribute());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PurgeTask returns PurgeTask
	 *
	 * Constraint:
	 *     listAttribute=PurgeTaskAttribute
	 * </pre>
	 */
	protected void sequence_PurgeTask(ISerializationContext context, PurgeTask semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getPurgeTask_ListAttribute()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getPurgeTask_ListAttribute()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPurgeTaskAccess().getListAttributePurgeTaskAttributeEnumRuleCall_1_0(), semanticObject.getListAttribute());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RGB returns RGB
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_RGB(ISerializationContext context, RGB semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRGB_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRGB_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRGBAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns Rate
	 *     ResourceAttribute returns Rate
	 *     Rate returns Rate
	 *
	 * Constraint:
	 *     rate=XFloat
	 * </pre>
	 */
	protected void sequence_Rate(ISerializationContext context, Rate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRate_Rate()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRate_Rate()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRateAccess().getRateXFloatParserRuleCall_1_0(), semanticObject.getRate());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProjectAttribute returns RealFormat
	 *     ReportAttribute returns RealFormat
	 *     NikuReportAttribute returns RealFormat
	 *     CurrencyFormat returns RealFormat
	 *     NumberFormat returns RealFormat
	 *     RealFormat returns RealFormat
	 *
	 * Constraint:
	 *     (negativePrefix=STRING negativeSuffix=STRING thousandsSeparator=STRING fractionSeparator=STRING fractionDigits=INT)
	 * </pre>
	 */
	protected void sequence_RealFormat(ISerializationContext context, RealFormat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRealFormat_NegativePrefix()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRealFormat_NegativePrefix()));
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRealFormat_NegativeSuffix()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRealFormat_NegativeSuffix()));
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRealFormat_ThousandsSeparator()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRealFormat_ThousandsSeparator()));
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRealFormat_FractionSeparator()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRealFormat_FractionSeparator()));
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRealFormat_FractionDigits()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRealFormat_FractionDigits()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealFormatAccess().getNegativePrefixSTRINGTerminalRuleCall_0_0(), semanticObject.getNegativePrefix());
		feeder.accept(grammarAccess.getRealFormatAccess().getNegativeSuffixSTRINGTerminalRuleCall_1_0(), semanticObject.getNegativeSuffix());
		feeder.accept(grammarAccess.getRealFormatAccess().getThousandsSeparatorSTRINGTerminalRuleCall_2_0(), semanticObject.getThousandsSeparator());
		feeder.accept(grammarAccess.getRealFormatAccess().getFractionSeparatorSTRINGTerminalRuleCall_3_0(), semanticObject.getFractionSeparator());
		feeder.accept(grammarAccess.getRealFormatAccess().getFractionDigitsINTTerminalRuleCall_4_0(), semanticObject.getFractionDigits());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NewTaskAttribute returns Remaining
	 *     Remaining returns Remaining
	 *     TaskTimesheetAttribute returns Remaining
	 *
	 * Constraint:
	 *     remaining=DurationQuantity
	 * </pre>
	 */
	protected void sequence_Remaining(ISerializationContext context, Remaining semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRemaining_Remaining()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRemaining_Remaining()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRemainingAccess().getRemainingDurationQuantityParserRuleCall_1_0(), semanticObject.getRemaining());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IncludePropertiesAttribute returns ReportPrefix
	 *     ReportPrefix returns ReportPrefix
	 *
	 * Constraint:
	 *     report=[Report|ID]
	 * </pre>
	 */
	protected void sequence_ReportPrefix(ISerializationContext context, ReportPrefix semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getReportPrefix_Report()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getReportPrefix_Report()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReportPrefixAccess().getReportReportIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ETJPackage.eINSTANCE.getReportPrefix_Report(), false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns Report
	 *     AccountReport returns Report
	 *     Report returns Report
	 *     ReportAttribute returns Report
	 *     ResourceReport returns Report
	 *     TaskReport returns Report
	 *     TextReport returns Report
	 *
	 * Constraint:
	 *     (id=ID? name=STRING attributes+=ReportAttribute*)
	 * </pre>
	 */
	protected void sequence_Report(ISerializationContext context, Report semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExportAttribute returns ResourceAttributes
	 *     ResourceAttributes returns ResourceAttributes
	 *
	 * Constraint:
	 *     (all?='*' | none?='-' | (vacation?='vacation' | booking?='booking' | workingHours?='workinghours')+)?
	 * </pre>
	 */
	protected void sequence_ResourceAttributes(ISerializationContext context, ResourceAttributes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IncludePropertiesAttribute returns ResourcePrefix
	 *     ResourcePrefix returns ResourcePrefix
	 *
	 * Constraint:
	 *     resource=[Resource|ID]
	 * </pre>
	 */
	protected void sequence_ResourcePrefix(ISerializationContext context, ResourcePrefix semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getResourcePrefix_Resource()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getResourcePrefix_Resource()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getResourcePrefixAccess().getResourceResourceIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ETJPackage.eINSTANCE.getResourcePrefix_Resource(), false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReportAttribute returns ResourceRoot
	 *     ResourceRoot returns ResourceRoot
	 *
	 * Constraint:
	 *     resource=[Resource|ID]
	 * </pre>
	 */
	protected void sequence_ResourceRoot(ISerializationContext context, ResourceRoot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getResourceRoot_Resource()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getResourceRoot_Resource()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getResourceRootAccess().getResourceResourceIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ETJPackage.eINSTANCE.getResourceRoot_Resource(), false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns Resource
	 *     Resource returns Resource
	 *     ResourceAttribute returns Resource
	 *
	 * Constraint:
	 *     (id=ID? name=STRING attributes+=ResourceAttribute*)
	 * </pre>
	 */
	protected void sequence_Resource(ISerializationContext context, Resource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Responsible returns Responsible
	 *
	 * Constraint:
	 *     (resources+=[Resource|ID] resources+=[Resource|ID]*)
	 * </pre>
	 */
	protected void sequence_Responsible(ISerializationContext context, Responsible semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReportAttribute returns RichText
	 *     NikuReportAttribute returns RichText
	 *     Caption returns RichText
	 *     Center returns RichText
	 *     Details returns RichText
	 *     Epilog returns RichText
	 *     Footer returns RichText
	 *     Header returns RichText
	 *     Headline returns RichText
	 *     Left returns RichText
	 *     ListItem returns RichText
	 *     Prolog returns RichText
	 *     Right returns RichText
	 *     StatusStatusSheetAttribute returns RichText
	 *     StatusTimesheetAttribute returns RichText
	 *     Summary returns RichText
	 *     ColumnAttribute returns RichText
	 *     RichText returns RichText
	 *
	 * Constraint:
	 *     text=STRING
	 * </pre>
	 */
	protected void sequence_RichText(ISerializationContext context, RichText semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRichText_Text()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRichText_Text()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRichTextAccess().getTextSTRINGTerminalRuleCall_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReportAttribute returns RollupAccount
	 *     RollupAccount returns RollupAccount
	 *
	 * Constraint:
	 *     expression=LogicalExpression
	 * </pre>
	 */
	protected void sequence_RollupAccount(ISerializationContext context, RollupAccount semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRollupAccount_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRollupAccount_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRollupAccountAccess().getExpressionLogicalExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReportAttribute returns RollupResource
	 *     IcalReportAttribute returns RollupResource
	 *     ExportAttribute returns RollupResource
	 *     RollupResource returns RollupResource
	 *
	 * Constraint:
	 *     expression=LogicalExpression
	 * </pre>
	 */
	protected void sequence_RollupResource(ISerializationContext context, RollupResource semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRollupResource_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRollupResource_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRollupResourceAccess().getExpressionLogicalExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReportAttribute returns RollupTask
	 *     IcalReportAttribute returns RollupTask
	 *     ExportAttribute returns RollupTask
	 *     RollupTask returns RollupTask
	 *
	 * Constraint:
	 *     expression=LogicalExpression
	 * </pre>
	 */
	protected void sequence_RollupTask(ISerializationContext context, RollupTask semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getRollupTask_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getRollupTask_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRollupTaskAccess().getExpressionLogicalExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Scale returns Scale
	 *     ColumnAttribute returns Scale
	 *
	 * Constraint:
	 *     (
	 *         scale='hour' | 
	 *         scale='day' | 
	 *         scale='week' | 
	 *         scale='month' | 
	 *         scale='quarter' | 
	 *         scale='year'
	 *     )
	 * </pre>
	 */
	protected void sequence_Scale(ISerializationContext context, Scale semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IcalReportAttribute returns ScenarioIcal
	 *     ScenarioIcal returns ScenarioIcal
	 *
	 * Constraint:
	 *     scenario=[Scenario|ID]
	 * </pre>
	 */
	protected void sequence_ScenarioIcal(ISerializationContext context, ScenarioIcal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getScenarioIcal_Scenario()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getScenarioIcal_Scenario()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScenarioIcalAccess().getScenarioScenarioIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ETJPackage.eINSTANCE.getScenarioIcal_Scenario(), false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProjectAttribute returns Scenario
	 *     Scenario returns Scenario
	 *
	 * Constraint:
	 *     (id=ID name=STRING (active=YesNo | scenario=Scenario)*)
	 * </pre>
	 */
	protected void sequence_Scenario(ISerializationContext context, Scenario semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReportAttribute returns Scenarios
	 *     ExportAttribute returns Scenarios
	 *     Scenarios returns Scenarios
	 *
	 * Constraint:
	 *     (scenarios+=[Scenario|ID] scenarios+=[Scenario|ID]*)
	 * </pre>
	 */
	protected void sequence_Scenarios(ISerializationContext context, Scenarios semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Scheduled returns Scheduled
	 *
	 * Constraint:
	 *     scheduled?='scheduled'
	 * </pre>
	 */
	protected void sequence_Scheduled(ISerializationContext context, Scheduled semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getScheduled_Scheduled()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getScheduled_Scheduled()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScheduledAccess().getScheduledScheduledKeyword_0(), semanticObject.isScheduled());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Scheduling returns Scheduling
	 *
	 * Constraint:
	 *     scheduling=SchedulingPolicy
	 * </pre>
	 */
	protected void sequence_Scheduling(ISerializationContext context, Scheduling semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getScheduling_Scheduling()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getScheduling_Scheduling()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSchedulingAccess().getSchedulingSchedulingPolicyEnumRuleCall_1_0(), semanticObject.getScheduling());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AllocateResourceAttribute returns Select
	 *     Select returns Select
	 *
	 * Constraint:
	 *     argument=SelectArgument
	 * </pre>
	 */
	protected void sequence_Select(ISerializationContext context, Select semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getSelect_Argument()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getSelect_Argument()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSelectAccess().getArgumentSelectArgumentEnumRuleCall_1_0(), semanticObject.getArgument());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReportAttribute returns SelfContained
	 *     SelfContained returns SelfContained
	 *
	 * Constraint:
	 *     selfcontained=YesNo
	 * </pre>
	 */
	protected void sequence_SelfContained(ISerializationContext context, SelfContained semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getSelfContained_Selfcontained()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getSelfContained_Selfcontained()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSelfContainedAccess().getSelfcontainedYesNoEnumRuleCall_1_0(), semanticObject.getSelfcontained());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ShiftTimesheet returns ShiftTimesheet
	 *     TimesheetAttribute returns ShiftTimesheet
	 *
	 * Constraint:
	 *     shift=[Shift|ID]
	 * </pre>
	 */
	protected void sequence_ShiftTimesheet(ISerializationContext context, ShiftTimesheet semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getShiftTimesheet_Shift()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getShiftTimesheet_Shift()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShiftTimesheetAccess().getShiftShiftIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ETJPackage.eINSTANCE.getShiftTimesheet_Shift(), false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns Shift
	 *     Shift returns Shift
	 *
	 * Constraint:
	 *     (id=ID? name=STRING (replace='replace' | timezone=STRING | vacation=VacationShift | shift=Shift | workingHours=WorkingHours)*)
	 * </pre>
	 */
	protected void sequence_Shift(ISerializationContext context, Shift semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AllocateResourceAttribute returns ShiftsAllocate
	 *     ShiftsAllocate returns ShiftsAllocate
	 *
	 * Constraint:
	 *     (shift=[Shift|ID] (intervals+=Interval3 intervals+=Interval3*)?)
	 * </pre>
	 */
	protected void sequence_ShiftsAllocate(ISerializationContext context, ShiftsAllocate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ShiftsLimit returns ShiftsLimit
	 *
	 * Constraint:
	 *     (shift=[Shift|ID] limit=Interval2?)
	 * </pre>
	 */
	protected void sequence_ShiftsLimit(ISerializationContext context, ShiftsLimit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ResourceAttribute returns Shifts
	 *     Shifts returns Shifts
	 *     ShiftsResource returns Shifts
	 *     ShiftsTask returns Shifts
	 *
	 * Constraint:
	 *     (limits+=ShiftsLimit limits+=ShiftsLimit*)
	 * </pre>
	 */
	protected void sequence_Shifts(ISerializationContext context, Shifts semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProjectAttribute returns ShortTimeFormat
	 *     ShortTimeFormat returns ShortTimeFormat
	 *
	 * Constraint:
	 *     shortTimeFormat=STRING
	 * </pre>
	 */
	protected void sequence_ShortTimeFormat(ISerializationContext context, ShortTimeFormat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getShortTimeFormat_ShortTimeFormat()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getShortTimeFormat_ShortTimeFormat()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShortTimeFormatAccess().getShortTimeFormatSTRINGTerminalRuleCall_1_0(), semanticObject.getShortTimeFormat());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReportAttribute returns Sort
	 *     Sort returns Sort
	 *     SortAccounts returns Sort
	 *     SortJournalEntries returns Sort
	 *     SortResources returns Sort
	 *     SortTasks returns Sort
	 *     StatusSheetReportAttribute returns Sort
	 *
	 * Constraint:
	 *     ((tree?='tree' | criteria+=Criterion)? criteria+=Criterion*)
	 * </pre>
	 */
	protected void sequence_Sort(ISerializationContext context, Sort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReportAttribute returns Start
	 *     IcalReportAttribute returns Start
	 *     ExportAttribute returns Start
	 *     NikuReportAttribute returns Start
	 *     Start returns Start
	 *     StatusSheetReportAttribute returns Start
	 *     TimesheetReportAttribute returns Start
	 *     ColumnAttribute returns Start
	 *
	 * Constraint:
	 *     start=ISODATE
	 * </pre>
	 */
	protected void sequence_Start(ISerializationContext context, Start semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getStart_Start()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getStart_Start()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStartAccess().getStartISODATEParserRuleCall_1_0_0(), semanticObject.getStart());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns StatusSheetReport
	 *     StatusSheetReport returns StatusSheetReport
	 *
	 * Constraint:
	 *     (filename=STRING attributes+=StatusSheetReportAttribute*)
	 * </pre>
	 */
	protected void sequence_StatusSheetReport(ISerializationContext context, StatusSheetReport semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns StatusSheet
	 *     StatusSheet returns StatusSheet
	 *
	 * Constraint:
	 *     (resource=[Resource|ID] interval=Interval4 attributes+=StatusSheetAttribute*)
	 * </pre>
	 */
	protected void sequence_StatusSheet(ISerializationContext context, StatusSheet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StatusStatusSheet returns StatusStatusSheet
	 *     TaskStatusSheetAttribute returns StatusStatusSheet
	 *
	 * Constraint:
	 *     (level=AlertLevel text=STRING attributes+=StatusStatusSheetAttribute*)
	 * </pre>
	 */
	protected void sequence_StatusStatusSheet(ISerializationContext context, StatusStatusSheet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StatusTimesheet returns StatusTimesheet
	 *     TaskTimesheetAttribute returns StatusTimesheet
	 *     TimesheetAttribute returns StatusTimesheet
	 *
	 * Constraint:
	 *     (level=AlertLevel text=STRING attributes+=StatusTimesheetAttribute*)
	 * </pre>
	 */
	protected void sequence_StatusTimesheet(ISerializationContext context, StatusTimesheet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns SupplementAccount
	 *     SupplementAccount returns SupplementAccount
	 *
	 * Constraint:
	 *     (account=[Account|ID] attributes+=AccountAttribute*)
	 * </pre>
	 */
	protected void sequence_SupplementAccount(ISerializationContext context, SupplementAccount semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns SupplementReport
	 *     SupplementReport returns SupplementReport
	 *
	 * Constraint:
	 *     (report=[Report|ID] attributes+=ReportAttribute*)
	 * </pre>
	 */
	protected void sequence_SupplementReport(ISerializationContext context, SupplementReport semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns SupplementResource
	 *     ResourceAttribute returns SupplementResource
	 *     SupplementResource returns SupplementResource
	 *
	 * Constraint:
	 *     (resource=[Resource|ID] attributes+=ResourceAttribute*)
	 * </pre>
	 */
	protected void sequence_SupplementResource(ISerializationContext context, SupplementResource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns SupplementTask
	 *     SupplementTask returns SupplementTask
	 *
	 * Constraint:
	 *     (task=[Task|TaskPath] attributes+=TaskAttribute*)
	 * </pre>
	 */
	protected void sequence_SupplementTask(ISerializationContext context, SupplementTask semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns TagFile
	 *     TagFile returns TagFile
	 *
	 * Constraint:
	 *     (id=ID? filename=STRING (hideResource=HideResource | hideTask=HideTask | rollupResource=RollupResource | rollupTask=RollupTask)*)
	 * </pre>
	 */
	protected void sequence_TagFile(ISerializationContext context, TagFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TaskAttribute returns TaskAttribute
	 *
	 * Constraint:
	 *     (
	 *         scenario=[Scenario|QualifiedName]? 
	 *         (
	 *             attr=Allocate | 
	 *             attr=BookingTask | 
	 *             attr=Charge | 
	 *             attr=ChargeSet | 
	 *             attr=Complete | 
	 *             attr=Depends | 
	 *             attr=Duration | 
	 *             attr=Effort | 
	 *             attr=End | 
	 *             attr=EndCredit | 
	 *             attr=ExtendedTaskAttribute | 
	 *             attr=Fail | 
	 *             attr=Flags | 
	 *             attr=JournalEntry | 
	 *             attr=Length | 
	 *             attr=Limits | 
	 *             attr=MaxEnd | 
	 *             attr=MaxStart | 
	 *             attr=Milestone | 
	 *             attr=MinEnd | 
	 *             attr=MinStart | 
	 *             attr=Note | 
	 *             attr=Period | 
	 *             attr=Precedes | 
	 *             attr=Priority | 
	 *             attr=ProjectId | 
	 *             attr=PurgeTask | 
	 *             attr=Responsible | 
	 *             attr=Scheduled | 
	 *             attr=Scheduling | 
	 *             attr=ShiftsTask | 
	 *             attr=Start | 
	 *             attr=SupplementTask | 
	 *             attr=Task | 
	 *             attr=Warn | 
	 *             attr=MacroCall
	 *         )
	 *     )
	 * </pre>
	 */
	protected void sequence_TaskAttribute(ISerializationContext context, TaskAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExportAttribute returns TaskAttributes
	 *     TaskAttributes returns TaskAttributes
	 *
	 * Constraint:
	 *     (
	 *         all?='*' | 
	 *         none?='-' | 
	 *         (
	 *             responsible?='responsible' | 
	 *             flags?='flags' | 
	 *             maxstart?='maxstart' | 
	 *             maxend?='maxend' | 
	 *             priority?='priority' | 
	 *             booking?='booking' | 
	 *             note?='note' | 
	 *             minstart?='minstart' | 
	 *             minend?='minend' | 
	 *             complete?='complete' | 
	 *             depends?='depends'
	 *         )+
	 *     )?
	 * </pre>
	 */
	protected void sequence_TaskAttributes(ISerializationContext context, TaskAttributes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Precedes returns TaskDependency
	 *     TaskDependency returns TaskDependency
	 *
	 * Constraint:
	 *     (task=[Task|TaskPath] (gapDuration=GapDuration | gapLength=GapLength | policy=DependsPolicy)*)
	 * </pre>
	 */
	protected void sequence_TaskDependency(ISerializationContext context, TaskDependency semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IncludePropertiesAttribute returns TaskPrefix
	 *     TaskPrefix returns TaskPrefix
	 *
	 * Constraint:
	 *     task=[Task|ID]
	 * </pre>
	 */
	protected void sequence_TaskPrefix(ISerializationContext context, TaskPrefix semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getTaskPrefix_Task()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getTaskPrefix_Task()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTaskPrefixAccess().getTaskTaskIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ETJPackage.eINSTANCE.getTaskPrefix_Task(), false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReportAttribute returns TaskRoot
	 *     TaskRoot returns TaskRoot
	 *
	 * Constraint:
	 *     task=[Task|AbsoluteId]
	 * </pre>
	 */
	protected void sequence_TaskRoot(ISerializationContext context, TaskRoot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getTaskRoot_Task()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getTaskRoot_Task()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTaskRootAccess().getTaskTaskAbsoluteIdParserRuleCall_1_0_1(), semanticObject.eGet(ETJPackage.eINSTANCE.getTaskRoot_Task(), false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StatusSheetAttribute returns TaskStatusSheet
	 *     TaskStatusSheet returns TaskStatusSheet
	 *     TaskStatusSheetAttribute returns TaskStatusSheet
	 *
	 * Constraint:
	 *     (task=[Task|AbsoluteId] attributes+=TaskStatusSheetAttribute*)
	 * </pre>
	 */
	protected void sequence_TaskStatusSheet(ISerializationContext context, TaskStatusSheet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TaskTimesheet returns TaskTimesheet
	 *     TimesheetAttribute returns TaskTimesheet
	 *
	 * Constraint:
	 *     (task=[Task|ID] attributes+=TaskTimesheetAttribute*)
	 * </pre>
	 */
	protected void sequence_TaskTimesheet(ISerializationContext context, TaskTimesheet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns Task
	 *     Task returns Task
	 *
	 * Constraint:
	 *     (id=ID? name=STRING attributes+=TaskAttribute*)
	 * </pre>
	 */
	protected void sequence_Task(ISerializationContext context, Task semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProjectAttribute returns TimeFormat
	 *     ReportAttribute returns TimeFormat
	 *     TimeFormat returns TimeFormat
	 *
	 * Constraint:
	 *     timeformat=STRING
	 * </pre>
	 */
	protected void sequence_TimeFormat(ISerializationContext context, TimeFormat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getTimeFormat_Timeformat()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getTimeFormat_Timeformat()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeFormatAccess().getTimeformatSTRINGTerminalRuleCall_1_0(), semanticObject.getTimeformat());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NikuReportAttribute returns Timeoff
	 *     Timeoff returns Timeoff
	 *
	 * Constraint:
	 *     (id=STRING name=STRING)
	 * </pre>
	 */
	protected void sequence_Timeoff(ISerializationContext context, Timeoff semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getTimeoff_Id()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getTimeoff_Id()));
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getTimeoff_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getTimeoff_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeoffAccess().getIdSTRINGTerminalRuleCall_1_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getTimeoffAccess().getNameSTRINGTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns TimesheetReport
	 *     TimesheetReport returns TimesheetReport
	 *
	 * Constraint:
	 *     (filename=STRING attributes+=TimesheetReportAttribute*)
	 * </pre>
	 */
	protected void sequence_TimesheetReport(ISerializationContext context, TimesheetReport semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns Timesheet
	 *     Timesheet returns Timesheet
	 *
	 * Constraint:
	 *     (resource=[Resource|ID] interval=Interval4 attributes+=TimesheetAttribute*)
	 * </pre>
	 */
	protected void sequence_Timesheet(ISerializationContext context, Timesheet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProjectAttribute returns Timezone
	 *     ReportAttribute returns Timezone
	 *     ExportAttribute returns Timezone
	 *     Timezone returns Timezone
	 *
	 * Constraint:
	 *     timezone=STRING
	 * </pre>
	 */
	protected void sequence_Timezone(ISerializationContext context, Timezone semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getTimezone_Timezone()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getTimezone_Timezone()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimezoneAccess().getTimezoneSTRINGTerminalRuleCall_1_0(), semanticObject.getTimezone());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProjectAttribute returns TimingResolution
	 *     TimingResolution returns TimingResolution
	 *
	 * Constraint:
	 *     timingResolution=INT
	 * </pre>
	 */
	protected void sequence_TimingResolution(ISerializationContext context, TimingResolution semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getTimingResolution_TimingResolution()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getTimingResolution_TimingResolution()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimingResolutionAccess().getTimingResolutionINTTerminalRuleCall_1_0(), semanticObject.getTimingResolution());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReportAttribute returns Title
	 *     NikuReportAttribute returns Title
	 *     Title returns Title
	 *     ColumnAttribute returns Title
	 *
	 * Constraint:
	 *     title=STRING
	 * </pre>
	 */
	protected void sequence_Title(ISerializationContext context, Title semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getTitle_Title()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getTitle_Title()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTitleAccess().getTitleSTRINGTerminalRuleCall_1_0(), semanticObject.getTitle());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns ToolTip
	 *     ToolTip returns ToolTip
	 *     ColumnAttribute returns ToolTip
	 *
	 * Constraint:
	 *     (expression=LogicalExpression tip=STRING)
	 * </pre>
	 */
	protected void sequence_ToolTip(ISerializationContext context, ToolTip semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getToolTip_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getToolTip_Expression()));
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getToolTip_Tip()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getToolTip_Tip()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getToolTipAccess().getExpressionLogicalExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getToolTipAccess().getTipSTRINGTerminalRuleCall_2_0(), semanticObject.getTip());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProjectAttribute returns TrackingScenario
	 *     TrackingScenario returns TrackingScenario
	 *
	 * Constraint:
	 *     scenario=[Scenario|ID]
	 * </pre>
	 */
	protected void sequence_TrackingScenario(ISerializationContext context, TrackingScenario semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getTrackingScenario_Scenario()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getTrackingScenario_Scenario()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTrackingScenarioAccess().getScenarioScenarioIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ETJPackage.eINSTANCE.getTrackingScenario_Scenario(), false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TreeLevel returns TreeLevel
	 *
	 * Constraint:
	 *     level=STRING
	 * </pre>
	 */
	protected void sequence_TreeLevel(ISerializationContext context, TreeLevel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getTreeLevel_Level()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getTreeLevel_Level()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTreeLevelAccess().getLevelSTRINGTerminalRuleCall_1_0(), semanticObject.getLevel());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ResourceAttribute returns Vacation
	 *     VacationResource returns Vacation
	 *
	 * Constraint:
	 *     (name=STRING? intervals+=Interval3 intervals+=Interval3*)
	 * </pre>
	 */
	protected void sequence_VacationResource(ISerializationContext context, Vacation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VacationShift returns Vacation
	 *
	 * Constraint:
	 *     (name=STRING? (intervals+=Interval3 intervals+=Interval3*)?)
	 * </pre>
	 */
	protected void sequence_VacationShift(ISerializationContext context, Vacation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns Vacation
	 *     Vacation returns Vacation
	 *
	 * Constraint:
	 *     (name=STRING intervals+=Interval3 intervals+=Interval3*)
	 * </pre>
	 */
	protected void sequence_Vacation(ISerializationContext context, Vacation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ResourceAttribute returns Warn
	 *     Warn returns Warn
	 *
	 * Constraint:
	 *     expression=LogicalExpression
	 * </pre>
	 */
	protected void sequence_Warn(ISerializationContext context, Warn semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getWarn_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getWarn_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWarnAccess().getExpressionLogicalExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProjectAttribute returns WeekStarts
	 *     WeekStarts returns WeekStarts
	 *
	 * Constraint:
	 *     (sunday?='weekstartssunday' | monday?='weekstartsmonday')
	 * </pre>
	 */
	protected void sequence_WeekStarts(ISerializationContext context, WeekStarts semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Weekdays returns Weekdays
	 *
	 * Constraint:
	 *     (first=Weekday last=Weekday?)
	 * </pre>
	 */
	protected void sequence_Weekdays(ISerializationContext context, Weekdays semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Width returns Width
	 *     ColumnAttribute returns Width
	 *
	 * Constraint:
	 *     width=XFloat
	 * </pre>
	 */
	protected void sequence_Width(ISerializationContext context, Width semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getWidth_Width()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getWidth_Width()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWidthAccess().getWidthXFloatParserRuleCall_1_0(), semanticObject.getWidth());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     WorkHours returns WorkHours
	 *
	 * Constraint:
	 *     (start=TIME stop=TIME)
	 * </pre>
	 */
	protected void sequence_WorkHours(ISerializationContext context, WorkHours semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getWorkHours_Start()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getWorkHours_Start()));
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getWorkHours_Stop()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getWorkHours_Stop()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWorkHoursAccess().getStartTIMETerminalRuleCall_0_0(), semanticObject.getStart());
		feeder.accept(grammarAccess.getWorkHoursAccess().getStopTIMETerminalRuleCall_2_0(), semanticObject.getStop());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NewTaskAttribute returns Work
	 *     TaskTimesheetAttribute returns Work
	 *     Work returns Work
	 *
	 * Constraint:
	 *     (value=XFloat unit=WorkQuantityUnit)
	 * </pre>
	 */
	protected void sequence_Work(ISerializationContext context, Work semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getWork_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getWork_Value()));
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getWork_Unit()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getWork_Unit()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWorkAccess().getValueXFloatParserRuleCall_1_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getWorkAccess().getUnitWorkQuantityUnitEnumRuleCall_2_0(), semanticObject.getUnit());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProjectAttribute returns WorkingHours
	 *     ResourceAttribute returns WorkingHours
	 *     WorkingHours returns WorkingHours
	 *
	 * Constraint:
	 *     (weekdays+=Weekdays weekdays+=Weekdays* (off?='off' | (hours+=WorkHours hours+=WorkHours*)))
	 * </pre>
	 */
	protected void sequence_WorkingHours(ISerializationContext context, WorkingHours semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProjectAttribute returns YearlyWorkingDays
	 *     YearlyWorkingDays returns YearlyWorkingDays
	 *
	 * Constraint:
	 *     yearlyWorkingDays=INT
	 * </pre>
	 */
	protected void sequence_YearlyWorkingDays(ISerializationContext context, YearlyWorkingDays semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ETJPackage.eINSTANCE.getYearlyWorkingDays_YearlyWorkingDays()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ETJPackage.eINSTANCE.getYearlyWorkingDays_YearlyWorkingDays()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getYearlyWorkingDaysAccess().getYearlyWorkingDaysINTTerminalRuleCall_1_0(), semanticObject.getYearlyWorkingDays());
		feeder.finish();
	}
	
	
}

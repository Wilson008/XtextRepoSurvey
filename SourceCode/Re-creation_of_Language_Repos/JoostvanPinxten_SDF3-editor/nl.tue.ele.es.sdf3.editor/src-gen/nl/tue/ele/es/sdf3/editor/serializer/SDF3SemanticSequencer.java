/*
 * generated by Xtext 2.35.0
 */
package nl.tue.ele.es.sdf3.editor.serializer;

import com.google.inject.Inject;
import java.util.Set;
import nl.tue.ele.es.sdf3.editor.sDF3.Actor;
import nl.tue.ele.es.sdf3.editor.sDF3.ActorProperty;
import nl.tue.ele.es.sdf3.editor.sDF3.ApplicationGraph;
import nl.tue.ele.es.sdf3.editor.sDF3.Channel;
import nl.tue.ele.es.sdf3.editor.sDF3.ChannelProperty;
import nl.tue.ele.es.sdf3.editor.sDF3.GraphProperty;
import nl.tue.ele.es.sdf3.editor.sDF3.Port;
import nl.tue.ele.es.sdf3.editor.sDF3.SDF3;
import nl.tue.ele.es.sdf3.editor.sDF3.SDF3Package;
import nl.tue.ele.es.sdf3.editor.services.SDF3GrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SDF3SemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SDF3GrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SDF3Package.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SDF3Package.ACTOR:
				sequence_Actor(context, (Actor) semanticObject); 
				return; 
			case SDF3Package.ACTOR_PROPERTY:
				sequence_ActorProperty(context, (ActorProperty) semanticObject); 
				return; 
			case SDF3Package.APPLICATION_GRAPH:
				sequence_ApplicationGraph(context, (ApplicationGraph) semanticObject); 
				return; 
			case SDF3Package.CHANNEL:
				sequence_Channel(context, (Channel) semanticObject); 
				return; 
			case SDF3Package.CHANNEL_PROPERTY:
				sequence_ChannelProperty(context, (ChannelProperty) semanticObject); 
				return; 
			case SDF3Package.GRAPH_PROPERTY:
				sequence_GraphProperty(context, (GraphProperty) semanticObject); 
				return; 
			case SDF3Package.PORT:
				sequence_Port(context, (Port) semanticObject); 
				return; 
			case SDF3Package.SDF3:
				sequence_SDF3(context, (SDF3) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns ActorProperty
	 *     ActorProperty returns ActorProperty
	 *
	 * Constraint:
	 *     actor=[Actor|FQN]
	 * </pre>
	 */
	protected void sequence_ActorProperty(ISerializationContext context, ActorProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SDF3Package.Literals.ACTOR_PROPERTY__ACTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SDF3Package.Literals.ACTOR_PROPERTY__ACTOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getActorPropertyAccess().getActorActorFQNParserRuleCall_2_0_1(), semanticObject.eGet(SDF3Package.Literals.ACTOR_PROPERTY__ACTOR, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Actor returns Actor
	 *
	 * Constraint:
	 *     (name=ID type=ID ports+=Port ports+=Port*)
	 * </pre>
	 */
	protected void sequence_Actor(ISerializationContext context, Actor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ApplicationGraph returns ApplicationGraph
	 *
	 * Constraint:
	 *     (name=ID actors+=Actor+ channels+=Channel+)
	 * </pre>
	 */
	protected void sequence_ApplicationGraph(ISerializationContext context, ApplicationGraph semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns ChannelProperty
	 *     ChannelProperty returns ChannelProperty
	 *
	 * Constraint:
	 *     channel=[Channel|ID]
	 * </pre>
	 */
	protected void sequence_ChannelProperty(ISerializationContext context, ChannelProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SDF3Package.Literals.CHANNEL_PROPERTY__CHANNEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SDF3Package.Literals.CHANNEL_PROPERTY__CHANNEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChannelPropertyAccess().getChannelChannelIDTerminalRuleCall_2_0_1(), semanticObject.eGet(SDF3Package.Literals.CHANNEL_PROPERTY__CHANNEL, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Channel returns Channel
	 *
	 * Constraint:
	 *     (name=ID source=[Port|FQN] destination=[Port|FQN] initialTokens=INT?)
	 * </pre>
	 */
	protected void sequence_Channel(ISerializationContext context, Channel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns GraphProperty
	 *     GraphProperty returns GraphProperty
	 *
	 * Constraint:
	 *     throughput=DECIMAL
	 * </pre>
	 */
	protected void sequence_GraphProperty(ISerializationContext context, GraphProperty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SDF3Package.Literals.GRAPH_PROPERTY__THROUGHPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SDF3Package.Literals.GRAPH_PROPERTY__THROUGHPUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGraphPropertyAccess().getThroughputDECIMALTerminalRuleCall_1_0(), semanticObject.getThroughput());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Port returns Port
	 *
	 * Constraint:
	 *     (portType=PortType name=ID rate=INT)
	 * </pre>
	 */
	protected void sequence_Port(ISerializationContext context, Port semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SDF3Package.Literals.PORT__PORT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SDF3Package.Literals.PORT__PORT_TYPE));
			if (transientValues.isValueTransient(semanticObject, SDF3Package.Literals.PORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SDF3Package.Literals.PORT__NAME));
			if (transientValues.isValueTransient(semanticObject, SDF3Package.Literals.PORT__RATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SDF3Package.Literals.PORT__RATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPortAccess().getPortTypePortTypeEnumRuleCall_0_0(), semanticObject.getPortType());
		feeder.accept(grammarAccess.getPortAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPortAccess().getRateINTTerminalRuleCall_2_0(), semanticObject.getRate());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SDF3 returns SDF3
	 *
	 * Constraint:
	 *     (application=ApplicationGraph properties+=Property*)
	 * </pre>
	 */
	protected void sequence_SDF3(ISerializationContext context, SDF3 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}

/*
 * generated by Xtext 2.35.0
 */
package org.xtext.example.rmodp.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.common.types.JvmFormalParameter;
import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;
import org.eclipse.xtext.common.types.JvmInnerTypeReference;
import org.eclipse.xtext.common.types.JvmLowerBound;
import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;
import org.eclipse.xtext.common.types.JvmTypeParameter;
import org.eclipse.xtext.common.types.JvmUpperBound;
import org.eclipse.xtext.common.types.JvmWildcardTypeReference;
import org.eclipse.xtext.common.types.TypesPackage;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.eclipse.xtext.xbase.XAssignment;
import org.eclipse.xtext.xbase.XBasicForLoopExpression;
import org.eclipse.xtext.xbase.XBinaryOperation;
import org.eclipse.xtext.xbase.XBlockExpression;
import org.eclipse.xtext.xbase.XBooleanLiteral;
import org.eclipse.xtext.xbase.XCasePart;
import org.eclipse.xtext.xbase.XCastedExpression;
import org.eclipse.xtext.xbase.XCatchClause;
import org.eclipse.xtext.xbase.XClosure;
import org.eclipse.xtext.xbase.XConstructorCall;
import org.eclipse.xtext.xbase.XDoWhileExpression;
import org.eclipse.xtext.xbase.XFeatureCall;
import org.eclipse.xtext.xbase.XForLoopExpression;
import org.eclipse.xtext.xbase.XIfExpression;
import org.eclipse.xtext.xbase.XInstanceOfExpression;
import org.eclipse.xtext.xbase.XListLiteral;
import org.eclipse.xtext.xbase.XMemberFeatureCall;
import org.eclipse.xtext.xbase.XNullLiteral;
import org.eclipse.xtext.xbase.XNumberLiteral;
import org.eclipse.xtext.xbase.XPostfixOperation;
import org.eclipse.xtext.xbase.XReturnExpression;
import org.eclipse.xtext.xbase.XSetLiteral;
import org.eclipse.xtext.xbase.XStringLiteral;
import org.eclipse.xtext.xbase.XSwitchExpression;
import org.eclipse.xtext.xbase.XSynchronizedExpression;
import org.eclipse.xtext.xbase.XThrowExpression;
import org.eclipse.xtext.xbase.XTryCatchFinallyExpression;
import org.eclipse.xtext.xbase.XTypeLiteral;
import org.eclipse.xtext.xbase.XUnaryOperation;
import org.eclipse.xtext.xbase.XVariableDeclaration;
import org.eclipse.xtext.xbase.XWhileExpression;
import org.eclipse.xtext.xbase.XbasePackage;
import org.eclipse.xtext.xbase.serializer.XbaseSemanticSequencer;
import org.eclipse.xtext.xtype.XFunctionTypeRef;
import org.eclipse.xtext.xtype.XImportDeclaration;
import org.eclipse.xtext.xtype.XImportSection;
import org.eclipse.xtext.xtype.XtypePackage;
import org.xtext.example.rmodp.rmOdp.ActionProperty;
import org.xtext.example.rmodp.rmOdp.ActionType;
import org.xtext.example.rmodp.rmOdp.Artefact;
import org.xtext.example.rmodp.rmOdp.CV_spec;
import org.xtext.example.rmodp.rmOdp.Command;
import org.xtext.example.rmodp.rmOdp.Community;
import org.xtext.example.rmodp.rmOdp.CommunityContract;
import org.xtext.example.rmodp.rmOdp.Corr_spec;
import org.xtext.example.rmodp.rmOdp.Decision;
import org.xtext.example.rmodp.rmOdp.DynamicSchema;
import org.xtext.example.rmodp.rmOdp.EV_spec;
import org.xtext.example.rmodp.rmOdp.End;
import org.xtext.example.rmodp.rmOdp.EndPoint;
import org.xtext.example.rmodp.rmOdp.Enumeration;
import org.xtext.example.rmodp.rmOdp.Event;
import org.xtext.example.rmodp.rmOdp.FieldOfApplication;
import org.xtext.example.rmodp.rmOdp.HostNode;
import org.xtext.example.rmodp.rmOdp.IV_spec;
import org.xtext.example.rmodp.rmOdp.IXIT;
import org.xtext.example.rmodp.rmOdp.ImplementableStandard;
import org.xtext.example.rmodp.rmOdp.Import;
import org.xtext.example.rmodp.rmOdp.Incoming;
import org.xtext.example.rmodp.rmOdp.Interaction;
import org.xtext.example.rmodp.rmOdp.InteractionArtefact;
import org.xtext.example.rmodp.rmOdp.Interface;
import org.xtext.example.rmodp.rmOdp.InvariantSchema;
import org.xtext.example.rmodp.rmOdp.Lane;
import org.xtext.example.rmodp.rmOdp.Link;
import org.xtext.example.rmodp.rmOdp.Model;
import org.xtext.example.rmodp.rmOdp.NV_spec;
import org.xtext.example.rmodp.rmOdp.OR_Relation;
import org.xtext.example.rmodp.rmOdp.ObjectInstance;
import org.xtext.example.rmodp.rmOdp.ObjectObligation;
import org.xtext.example.rmodp.rmOdp.ObjectPermission;
import org.xtext.example.rmodp.rmOdp.ObjectProhibition;
import org.xtext.example.rmodp.rmOdp.Objective;
import org.xtext.example.rmodp.rmOdp.Outgoing;
import org.xtext.example.rmodp.rmOdp.PackageDeclaration;
import org.xtext.example.rmodp.rmOdp.Param;
import org.xtext.example.rmodp.rmOdp.Policy;
import org.xtext.example.rmodp.rmOdp.Property;
import org.xtext.example.rmodp.rmOdp.PropertyInstance;
import org.xtext.example.rmodp.rmOdp.RmOdpPackage;
import org.xtext.example.rmodp.rmOdp.Role;
import org.xtext.example.rmodp.rmOdp.RoleObligation;
import org.xtext.example.rmodp.rmOdp.RolePermission;
import org.xtext.example.rmodp.rmOdp.RoleProhibition;
import org.xtext.example.rmodp.rmOdp.SignatureDef;
import org.xtext.example.rmodp.rmOdp.SignatureReference;
import org.xtext.example.rmodp.rmOdp.SimpleType;
import org.xtext.example.rmodp.rmOdp.Start;
import org.xtext.example.rmodp.rmOdp.State;
import org.xtext.example.rmodp.rmOdp.StateMachine;
import org.xtext.example.rmodp.rmOdp.StateTransition;
import org.xtext.example.rmodp.rmOdp.StaticSchema;
import org.xtext.example.rmodp.rmOdp.Subprocess;
import org.xtext.example.rmodp.rmOdp.TV_spec;
import org.xtext.example.rmodp.services.RmOdpGrammarAccess;

@SuppressWarnings("all")
public class RmOdpSemanticSequencer extends XbaseSemanticSequencer {

	@Inject
	private RmOdpGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == RmOdpPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case RmOdpPackage.ACTION:
				sequence_Action(context, (org.xtext.example.rmodp.rmOdp.Action) semanticObject); 
				return; 
			case RmOdpPackage.ACTION_PROPERTY:
				sequence_ActionProperty(context, (ActionProperty) semanticObject); 
				return; 
			case RmOdpPackage.ACTION_TYPE:
				sequence_ActionType(context, (ActionType) semanticObject); 
				return; 
			case RmOdpPackage.ARTEFACT:
				sequence_Artefact(context, (Artefact) semanticObject); 
				return; 
			case RmOdpPackage.CV_SPEC:
				sequence_CV_spec(context, (CV_spec) semanticObject); 
				return; 
			case RmOdpPackage.COMMAND:
				sequence_Command(context, (Command) semanticObject); 
				return; 
			case RmOdpPackage.COMMUNITY:
				sequence_Community(context, (Community) semanticObject); 
				return; 
			case RmOdpPackage.COMMUNITY_CONTRACT:
				sequence_CommunityContract(context, (CommunityContract) semanticObject); 
				return; 
			case RmOdpPackage.CORR_SPEC:
				sequence_Corr_spec(context, (Corr_spec) semanticObject); 
				return; 
			case RmOdpPackage.DECISION:
				sequence_Decision(context, (Decision) semanticObject); 
				return; 
			case RmOdpPackage.DYNAMIC_SCHEMA:
				sequence_DynamicSchema(context, (DynamicSchema) semanticObject); 
				return; 
			case RmOdpPackage.EV_SPEC:
				sequence_EV_spec(context, (EV_spec) semanticObject); 
				return; 
			case RmOdpPackage.END:
				sequence_End(context, (End) semanticObject); 
				return; 
			case RmOdpPackage.END_POINT:
				sequence_EndPoint(context, (EndPoint) semanticObject); 
				return; 
			case RmOdpPackage.ENUMERATION:
				sequence_Enumeration(context, (Enumeration) semanticObject); 
				return; 
			case RmOdpPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case RmOdpPackage.FIELD_OF_APPLICATION:
				sequence_FieldOfApplication(context, (FieldOfApplication) semanticObject); 
				return; 
			case RmOdpPackage.HOST_NODE:
				sequence_HostNode(context, (HostNode) semanticObject); 
				return; 
			case RmOdpPackage.IV_SPEC:
				sequence_IV_spec(context, (IV_spec) semanticObject); 
				return; 
			case RmOdpPackage.IXIT:
				sequence_IXIT(context, (IXIT) semanticObject); 
				return; 
			case RmOdpPackage.IMPLEMENTABLE_STANDARD:
				sequence_ImplementableStandard(context, (ImplementableStandard) semanticObject); 
				return; 
			case RmOdpPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case RmOdpPackage.INCOMING:
				sequence_Incoming(context, (Incoming) semanticObject); 
				return; 
			case RmOdpPackage.INTERACTION:
				sequence_Interaction(context, (Interaction) semanticObject); 
				return; 
			case RmOdpPackage.INTERACTION_ARTEFACT:
				sequence_InteractionArtefact(context, (InteractionArtefact) semanticObject); 
				return; 
			case RmOdpPackage.INTERFACE:
				sequence_Interface(context, (Interface) semanticObject); 
				return; 
			case RmOdpPackage.INVARIANT_SCHEMA:
				sequence_InvariantSchema(context, (InvariantSchema) semanticObject); 
				return; 
			case RmOdpPackage.LANE:
				sequence_Lane(context, (Lane) semanticObject); 
				return; 
			case RmOdpPackage.LINK:
				sequence_Link(context, (Link) semanticObject); 
				return; 
			case RmOdpPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case RmOdpPackage.NV_SPEC:
				sequence_NV_spec(context, (NV_spec) semanticObject); 
				return; 
			case RmOdpPackage.OR_RELATION:
				sequence_OR_Relation(context, (OR_Relation) semanticObject); 
				return; 
			case RmOdpPackage.OBJECT:
				sequence_Object(context, (org.xtext.example.rmodp.rmOdp.Object) semanticObject); 
				return; 
			case RmOdpPackage.OBJECT_INSTANCE:
				sequence_ObjectInstance(context, (ObjectInstance) semanticObject); 
				return; 
			case RmOdpPackage.OBJECT_OBLIGATION:
				sequence_ObjectObligation(context, (ObjectObligation) semanticObject); 
				return; 
			case RmOdpPackage.OBJECT_PERMISSION:
				sequence_ObjectPermission(context, (ObjectPermission) semanticObject); 
				return; 
			case RmOdpPackage.OBJECT_PROHIBITION:
				sequence_ObjectProhibition(context, (ObjectProhibition) semanticObject); 
				return; 
			case RmOdpPackage.OBJECTIVE:
				sequence_Objective(context, (Objective) semanticObject); 
				return; 
			case RmOdpPackage.OUTGOING:
				sequence_Outgoing(context, (Outgoing) semanticObject); 
				return; 
			case RmOdpPackage.PACKAGE_DECLARATION:
				sequence_PackageDeclaration(context, (PackageDeclaration) semanticObject); 
				return; 
			case RmOdpPackage.PARAM:
				sequence_Param(context, (Param) semanticObject); 
				return; 
			case RmOdpPackage.POLICY:
				sequence_Policy(context, (Policy) semanticObject); 
				return; 
			case RmOdpPackage.PROCESS:
				sequence_Process(context, (org.xtext.example.rmodp.rmOdp.Process) semanticObject); 
				return; 
			case RmOdpPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case RmOdpPackage.PROPERTY_INSTANCE:
				sequence_PropertyInstance(context, (PropertyInstance) semanticObject); 
				return; 
			case RmOdpPackage.ROLE:
				sequence_Role(context, (Role) semanticObject); 
				return; 
			case RmOdpPackage.ROLE_OBLIGATION:
				sequence_RoleObligation(context, (RoleObligation) semanticObject); 
				return; 
			case RmOdpPackage.ROLE_PERMISSION:
				sequence_RolePermission(context, (RolePermission) semanticObject); 
				return; 
			case RmOdpPackage.ROLE_PROHIBITION:
				sequence_RoleProhibition(context, (RoleProhibition) semanticObject); 
				return; 
			case RmOdpPackage.SIGNATURE_DEF:
				sequence_SignatureDef(context, (SignatureDef) semanticObject); 
				return; 
			case RmOdpPackage.SIGNATURE_REFERENCE:
				sequence_SignatureReference(context, (SignatureReference) semanticObject); 
				return; 
			case RmOdpPackage.SIMPLE_TYPE:
				sequence_SimpleType(context, (SimpleType) semanticObject); 
				return; 
			case RmOdpPackage.START:
				sequence_Start(context, (Start) semanticObject); 
				return; 
			case RmOdpPackage.STATE:
				sequence_State(context, (State) semanticObject); 
				return; 
			case RmOdpPackage.STATE_MACHINE:
				sequence_StateMachine(context, (StateMachine) semanticObject); 
				return; 
			case RmOdpPackage.STATE_TRANSITION:
				sequence_StateTransition(context, (StateTransition) semanticObject); 
				return; 
			case RmOdpPackage.STATIC_SCHEMA:
				sequence_StaticSchema(context, (StaticSchema) semanticObject); 
				return; 
			case RmOdpPackage.SUBPROCESS:
				sequence_Subprocess(context, (Subprocess) semanticObject); 
				return; 
			case RmOdpPackage.TV_SPEC:
				sequence_TV_spec(context, (TV_spec) semanticObject); 
				return; 
			}
		else if (epackage == TypesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TypesPackage.JVM_FORMAL_PARAMETER:
				if (rule == grammarAccess.getFullJvmFormalParameterRule()) {
					sequence_FullJvmFormalParameter(context, (JvmFormalParameter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmFormalParameterRule()) {
					sequence_JvmFormalParameter(context, (JvmFormalParameter) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_GENERIC_ARRAY_TYPE_REFERENCE:
				sequence_JvmTypeReference(context, (JvmGenericArrayTypeReference) semanticObject); 
				return; 
			case TypesPackage.JVM_INNER_TYPE_REFERENCE:
				sequence_JvmParameterizedTypeReference(context, (JvmInnerTypeReference) semanticObject); 
				return; 
			case TypesPackage.JVM_LOWER_BOUND:
				if (rule == grammarAccess.getJvmLowerBoundAndedRule()) {
					sequence_JvmLowerBoundAnded(context, (JvmLowerBound) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmLowerBoundRule()) {
					sequence_JvmLowerBound(context, (JvmLowerBound) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_PARAMETERIZED_TYPE_REFERENCE:
				if (action == grammarAccess.getJvmParameterizedTypeReferenceAccess().getJvmInnerTypeReferenceOuterAction_1_4_0_0_0()) {
					sequence_JvmParameterizedTypeReference_JvmInnerTypeReference_1_4_0_0_0(context, (JvmParameterizedTypeReference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmTypeReferenceRule()
						|| action == grammarAccess.getJvmTypeReferenceAccess().getJvmGenericArrayTypeReferenceComponentTypeAction_0_1_0_0()
						|| rule == grammarAccess.getJvmParameterizedTypeReferenceRule()
						|| rule == grammarAccess.getJvmArgumentTypeReferenceRule()) {
					sequence_JvmParameterizedTypeReference(context, (JvmParameterizedTypeReference) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_TYPE_PARAMETER:
				sequence_JvmTypeParameter(context, (JvmTypeParameter) semanticObject); 
				return; 
			case TypesPackage.JVM_UPPER_BOUND:
				if (rule == grammarAccess.getJvmUpperBoundAndedRule()) {
					sequence_JvmUpperBoundAnded(context, (JvmUpperBound) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmUpperBoundRule()) {
					sequence_JvmUpperBound(context, (JvmUpperBound) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_WILDCARD_TYPE_REFERENCE:
				sequence_JvmWildcardTypeReference(context, (JvmWildcardTypeReference) semanticObject); 
				return; 
			}
		else if (epackage == XbasePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XbasePackage.XASSIGNMENT:
				sequence_XAssignment_XMemberFeatureCall(context, (XAssignment) semanticObject); 
				return; 
			case XbasePackage.XBASIC_FOR_LOOP_EXPRESSION:
				sequence_XBasicForLoopExpression(context, (XBasicForLoopExpression) semanticObject); 
				return; 
			case XbasePackage.XBINARY_OPERATION:
				sequence_XAdditiveExpression_XAndExpression_XAssignment_XEqualityExpression_XMultiplicativeExpression_XOrExpression_XOtherOperatorExpression_XRelationalExpression(context, (XBinaryOperation) semanticObject); 
				return; 
			case XbasePackage.XBLOCK_EXPRESSION:
				if (rule == grammarAccess.getXExpressionRule()
						|| rule == grammarAccess.getXAssignmentRule()
						|| action == grammarAccess.getXAssignmentAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOrExpressionRule()
						|| action == grammarAccess.getXOrExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAndExpressionRule()
						|| action == grammarAccess.getXAndExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXEqualityExpressionRule()
						|| action == grammarAccess.getXEqualityExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXRelationalExpressionRule()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXInstanceOfExpressionExpressionAction_1_0_0_0_0()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOtherOperatorExpressionRule()
						|| action == grammarAccess.getXOtherOperatorExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAdditiveExpressionRule()
						|| action == grammarAccess.getXAdditiveExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXMultiplicativeExpressionRule()
						|| action == grammarAccess.getXMultiplicativeExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXUnaryOperationRule()
						|| rule == grammarAccess.getXCastedExpressionRule()
						|| action == grammarAccess.getXCastedExpressionAccess().getXCastedExpressionTargetAction_1_0_0_0()
						|| rule == grammarAccess.getXPostfixOperationRule()
						|| action == grammarAccess.getXPostfixOperationAccess().getXPostfixOperationOperandAction_1_0_0()
						|| rule == grammarAccess.getXMemberFeatureCallRule()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXAssignmentAssignableAction_1_0_0_0_0()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXMemberFeatureCallMemberCallTargetAction_1_1_0_0_0()
						|| rule == grammarAccess.getXPrimaryExpressionRule()
						|| rule == grammarAccess.getXParenthesizedExpressionRule()
						|| rule == grammarAccess.getXBlockExpressionRule()
						|| rule == grammarAccess.getXExpressionOrVarDeclarationRule()) {
					sequence_XBlockExpression(context, (XBlockExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getXExpressionInClosureRule()) {
					sequence_XExpressionInClosure(context, (XBlockExpression) semanticObject); 
					return; 
				}
				else break;
			case XbasePackage.XBOOLEAN_LITERAL:
				sequence_XBooleanLiteral(context, (XBooleanLiteral) semanticObject); 
				return; 
			case XbasePackage.XCASE_PART:
				sequence_XCasePart(context, (XCasePart) semanticObject); 
				return; 
			case XbasePackage.XCASTED_EXPRESSION:
				sequence_XCastedExpression(context, (XCastedExpression) semanticObject); 
				return; 
			case XbasePackage.XCATCH_CLAUSE:
				sequence_XCatchClause(context, (XCatchClause) semanticObject); 
				return; 
			case XbasePackage.XCLOSURE:
				if (rule == grammarAccess.getXExpressionRule()
						|| rule == grammarAccess.getXAssignmentRule()
						|| action == grammarAccess.getXAssignmentAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOrExpressionRule()
						|| action == grammarAccess.getXOrExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAndExpressionRule()
						|| action == grammarAccess.getXAndExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXEqualityExpressionRule()
						|| action == grammarAccess.getXEqualityExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXRelationalExpressionRule()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXInstanceOfExpressionExpressionAction_1_0_0_0_0()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOtherOperatorExpressionRule()
						|| action == grammarAccess.getXOtherOperatorExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAdditiveExpressionRule()
						|| action == grammarAccess.getXAdditiveExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXMultiplicativeExpressionRule()
						|| action == grammarAccess.getXMultiplicativeExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXUnaryOperationRule()
						|| rule == grammarAccess.getXCastedExpressionRule()
						|| action == grammarAccess.getXCastedExpressionAccess().getXCastedExpressionTargetAction_1_0_0_0()
						|| rule == grammarAccess.getXPostfixOperationRule()
						|| action == grammarAccess.getXPostfixOperationAccess().getXPostfixOperationOperandAction_1_0_0()
						|| rule == grammarAccess.getXMemberFeatureCallRule()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXAssignmentAssignableAction_1_0_0_0_0()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXMemberFeatureCallMemberCallTargetAction_1_1_0_0_0()
						|| rule == grammarAccess.getXPrimaryExpressionRule()
						|| rule == grammarAccess.getXLiteralRule()
						|| rule == grammarAccess.getXClosureRule()
						|| rule == grammarAccess.getXParenthesizedExpressionRule()
						|| rule == grammarAccess.getXExpressionOrVarDeclarationRule()) {
					sequence_XClosure(context, (XClosure) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getXShortClosureRule()) {
					sequence_XShortClosure(context, (XClosure) semanticObject); 
					return; 
				}
				else break;
			case XbasePackage.XCONSTRUCTOR_CALL:
				sequence_XConstructorCall(context, (XConstructorCall) semanticObject); 
				return; 
			case XbasePackage.XDO_WHILE_EXPRESSION:
				sequence_XDoWhileExpression(context, (XDoWhileExpression) semanticObject); 
				return; 
			case XbasePackage.XFEATURE_CALL:
				sequence_XFeatureCall(context, (XFeatureCall) semanticObject); 
				return; 
			case XbasePackage.XFOR_LOOP_EXPRESSION:
				sequence_XForLoopExpression(context, (XForLoopExpression) semanticObject); 
				return; 
			case XbasePackage.XIF_EXPRESSION:
				sequence_XIfExpression(context, (XIfExpression) semanticObject); 
				return; 
			case XbasePackage.XINSTANCE_OF_EXPRESSION:
				sequence_XRelationalExpression(context, (XInstanceOfExpression) semanticObject); 
				return; 
			case XbasePackage.XLIST_LITERAL:
				sequence_XListLiteral(context, (XListLiteral) semanticObject); 
				return; 
			case XbasePackage.XMEMBER_FEATURE_CALL:
				sequence_XMemberFeatureCall(context, (XMemberFeatureCall) semanticObject); 
				return; 
			case XbasePackage.XNULL_LITERAL:
				sequence_XNullLiteral(context, (XNullLiteral) semanticObject); 
				return; 
			case XbasePackage.XNUMBER_LITERAL:
				sequence_XNumberLiteral(context, (XNumberLiteral) semanticObject); 
				return; 
			case XbasePackage.XPOSTFIX_OPERATION:
				sequence_XPostfixOperation(context, (XPostfixOperation) semanticObject); 
				return; 
			case XbasePackage.XRETURN_EXPRESSION:
				sequence_XReturnExpression(context, (XReturnExpression) semanticObject); 
				return; 
			case XbasePackage.XSET_LITERAL:
				sequence_XSetLiteral(context, (XSetLiteral) semanticObject); 
				return; 
			case XbasePackage.XSTRING_LITERAL:
				sequence_XStringLiteral(context, (XStringLiteral) semanticObject); 
				return; 
			case XbasePackage.XSWITCH_EXPRESSION:
				sequence_XSwitchExpression(context, (XSwitchExpression) semanticObject); 
				return; 
			case XbasePackage.XSYNCHRONIZED_EXPRESSION:
				sequence_XSynchronizedExpression(context, (XSynchronizedExpression) semanticObject); 
				return; 
			case XbasePackage.XTHROW_EXPRESSION:
				sequence_XThrowExpression(context, (XThrowExpression) semanticObject); 
				return; 
			case XbasePackage.XTRY_CATCH_FINALLY_EXPRESSION:
				sequence_XTryCatchFinallyExpression(context, (XTryCatchFinallyExpression) semanticObject); 
				return; 
			case XbasePackage.XTYPE_LITERAL:
				sequence_XTypeLiteral(context, (XTypeLiteral) semanticObject); 
				return; 
			case XbasePackage.XUNARY_OPERATION:
				sequence_XUnaryOperation(context, (XUnaryOperation) semanticObject); 
				return; 
			case XbasePackage.XVARIABLE_DECLARATION:
				sequence_XVariableDeclaration(context, (XVariableDeclaration) semanticObject); 
				return; 
			case XbasePackage.XWHILE_EXPRESSION:
				sequence_XWhileExpression(context, (XWhileExpression) semanticObject); 
				return; 
			}
		else if (epackage == XtypePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XtypePackage.XFUNCTION_TYPE_REF:
				sequence_XFunctionTypeRef(context, (XFunctionTypeRef) semanticObject); 
				return; 
			case XtypePackage.XIMPORT_DECLARATION:
				sequence_XImportDeclaration(context, (XImportDeclaration) semanticObject); 
				return; 
			case XtypePackage.XIMPORT_SECTION:
				sequence_XImportSection(context, (XImportSection) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     ActionProperty returns ActionProperty
	 *
	 * Constraint:
	 *     (name=QualifiedName type=[ModelElement|QualifiedName] many?='[]'?)
	 * </pre>
	 */
	protected void sequence_ActionProperty(ISerializationContext context, ActionProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ActionType returns ActionType
	 *
	 * Constraint:
	 *     (name=QualifiedName actionTypes+=ActionProperty*)
	 * </pre>
	 */
	protected void sequence_ActionType(ISerializationContext context, ActionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns Action
	 *     Action returns Action
	 *
	 * Constraint:
	 *     (name=QualifiedName incomings+=Incoming* outgoings+=Outgoing*)
	 * </pre>
	 */
	protected void sequence_Action(ISerializationContext context, org.xtext.example.rmodp.rmOdp.Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns Artefact
	 *     Artefact returns Artefact
	 *
	 * Constraint:
	 *     (name=QualifiedName incoming=[Node|QualifiedName]? outgoing=[Node|QualifiedName]?)
	 * </pre>
	 */
	protected void sequence_Artefact(ISerializationContext context, Artefact semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ModelElement returns CV_spec
	 *     Spec returns CV_spec
	 *     CV_spec returns CV_spec
	 *
	 * Constraint:
	 *     (name=QualifiedName cdatatypes+=Type* signatureDefs+=SignatureDef* objects+=Object*)
	 * </pre>
	 */
	protected void sequence_CV_spec(ISerializationContext context, CV_spec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Command returns Command
	 *
	 * Constraint:
	 *     name=QualifiedName
	 * </pre>
	 */
	protected void sequence_Command(ISerializationContext context, Command semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RmOdpPackage.Literals.COMMAND__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RmOdpPackage.Literals.COMMAND__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommandAccess().getNameQualifiedNameParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CommunityContract returns CommunityContract
	 *
	 * Constraint:
	 *     (name=QualifiedName objective=Objective community=Community)
	 * </pre>
	 */
	protected void sequence_CommunityContract(ISerializationContext context, CommunityContract semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RmOdpPackage.Literals.COMMUNITY_CONTRACT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RmOdpPackage.Literals.COMMUNITY_CONTRACT__NAME));
			if (transientValues.isValueTransient(semanticObject, RmOdpPackage.Literals.COMMUNITY_CONTRACT__OBJECTIVE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RmOdpPackage.Literals.COMMUNITY_CONTRACT__OBJECTIVE));
			if (transientValues.isValueTransient(semanticObject, RmOdpPackage.Literals.COMMUNITY_CONTRACT__COMMUNITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RmOdpPackage.Literals.COMMUNITY_CONTRACT__COMMUNITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommunityContractAccess().getNameQualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCommunityContractAccess().getObjectiveObjectiveParserRuleCall_3_0(), semanticObject.getObjective());
		feeder.accept(grammarAccess.getCommunityContractAccess().getCommunityCommunityParserRuleCall_4_0(), semanticObject.getCommunity());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Community returns Community
	 *
	 * Constraint:
	 *     (
	 *         name=QualifiedName 
	 *         localObjects+=Object* 
	 *         roles+=Role* 
	 *         or_relations+=OR_Relation* 
	 *         processes+=Process* 
	 *         interactions+=Interaction* 
	 *         policies+=Policy*
	 *     )
	 * </pre>
	 */
	protected void sequence_Community(ISerializationContext context, Community semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ModelElement returns Corr_spec
	 *     Spec returns Corr_spec
	 *     Corr_spec returns Corr_spec
	 *
	 * Constraint:
	 *     (
	 *         name=QualifiedName 
	 *         (viewpoint1='enterprise' | viewpoint1='information' | viewpoint1='computational' | viewpoint1='engineering' | viewpoint1='technololgy') 
	 *         endpoints1+=EndPoint* 
	 *         (viewpoint2='enterprise' | viewpoint2='information' | viewpoint2='computational' | viewpoint2='engineering' | viewpoint2='technololgy') 
	 *         endpoints2+=EndPoint* 
	 *         description=STRING
	 *     )
	 * </pre>
	 */
	protected void sequence_Corr_spec(ISerializationContext context, Corr_spec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns Decision
	 *     Decision returns Decision
	 *
	 * Constraint:
	 *     (name=QualifiedName incomings+=Incoming* outgoings+=Outgoing*)
	 * </pre>
	 */
	protected void sequence_Decision(ISerializationContext context, Decision semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DynamicSchema returns DynamicSchema
	 *
	 * Constraint:
	 *     (name=QualifiedName stateMachine=StateMachine)
	 * </pre>
	 */
	protected void sequence_DynamicSchema(ISerializationContext context, DynamicSchema semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RmOdpPackage.Literals.DYNAMIC_SCHEMA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RmOdpPackage.Literals.DYNAMIC_SCHEMA__NAME));
			if (transientValues.isValueTransient(semanticObject, RmOdpPackage.Literals.DYNAMIC_SCHEMA__STATE_MACHINE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RmOdpPackage.Literals.DYNAMIC_SCHEMA__STATE_MACHINE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDynamicSchemaAccess().getNameQualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDynamicSchemaAccess().getStateMachineStateMachineParserRuleCall_3_0(), semanticObject.getStateMachine());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ModelElement returns EV_spec
	 *     Spec returns EV_spec
	 *     EV_spec returns EV_spec
	 *
	 * Constraint:
	 *     (name=QualifiedName foa=FieldOfApplication globalObjects+=Object* communityContracts+=CommunityContract+)
	 * </pre>
	 */
	protected void sequence_EV_spec(ISerializationContext context, EV_spec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EndPoint returns EndPoint
	 *
	 * Constraint:
	 *     type=[ModelElement|QualifiedName]
	 * </pre>
	 */
	protected void sequence_EndPoint(ISerializationContext context, EndPoint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RmOdpPackage.Literals.END_POINT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RmOdpPackage.Literals.END_POINT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEndPointAccess().getTypeModelElementQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(RmOdpPackage.Literals.END_POINT__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns End
	 *     End returns End
	 *
	 * Constraint:
	 *     (name=QualifiedName incomings+=Incoming*)
	 * </pre>
	 */
	protected void sequence_End(ISerializationContext context, End semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ModelElement returns Enumeration
	 *     Type returns Enumeration
	 *     Enumeration returns Enumeration
	 *
	 * Constraint:
	 *     (name=QualifiedName valueItems+=STRING*)
	 * </pre>
	 */
	protected void sequence_Enumeration(ISerializationContext context, Enumeration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Event returns Event
	 *
	 * Constraint:
	 *     name=QualifiedName
	 * </pre>
	 */
	protected void sequence_Event(ISerializationContext context, Event semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RmOdpPackage.Literals.EVENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RmOdpPackage.Literals.EVENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEventAccess().getNameQualifiedNameParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FieldOfApplication returns FieldOfApplication
	 *
	 * Constraint:
	 *     foa=STRING
	 * </pre>
	 */
	protected void sequence_FieldOfApplication(ISerializationContext context, FieldOfApplication semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RmOdpPackage.Literals.FIELD_OF_APPLICATION__FOA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RmOdpPackage.Literals.FIELD_OF_APPLICATION__FOA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldOfApplicationAccess().getFoaSTRINGTerminalRuleCall_1_0(), semanticObject.getFoa());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     HostNode returns HostNode
	 *
	 * Constraint:
	 *     (name=QualifiedName link+=Link* signatureDefs+=SignatureDef* objects+=Object*)
	 * </pre>
	 */
	protected void sequence_HostNode(ISerializationContext context, HostNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ModelElement returns IV_spec
	 *     Spec returns IV_spec
	 *     IV_spec returns IV_spec
	 *
	 * Constraint:
	 *     (name=QualifiedName invariantSchema+=InvariantSchema* dynamicSchema+=DynamicSchema* staticSchema+=StaticSchema*)
	 * </pre>
	 */
	protected void sequence_IV_spec(ISerializationContext context, IV_spec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IXIT returns IXIT
	 *
	 * Constraint:
	 *     description=STRING
	 * </pre>
	 */
	protected void sequence_IXIT(ISerializationContext context, IXIT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RmOdpPackage.Literals.IXIT__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RmOdpPackage.Literals.IXIT__DESCRIPTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIXITAccess().getDescriptionSTRINGTerminalRuleCall_1_0(), semanticObject.getDescription());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ImplementableStandard returns ImplementableStandard
	 *
	 * Constraint:
	 *     name=QualifiedName
	 * </pre>
	 */
	protected void sequence_ImplementableStandard(ISerializationContext context, ImplementableStandard semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RmOdpPackage.Literals.IMPLEMENTABLE_STANDARD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RmOdpPackage.Literals.IMPLEMENTABLE_STANDARD__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImplementableStandardAccess().getNameQualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ModelElement returns Import
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildCard_1
	 * </pre>
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RmOdpPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RmOdpPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildCard_1ParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Incoming returns Incoming
	 *
	 * Constraint:
	 *     (incoming+=[Node|QualifiedName]* inCondition=STRING?)
	 * </pre>
	 */
	protected void sequence_Incoming(ISerializationContext context, Incoming semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InteractionArtefact returns InteractionArtefact
	 *
	 * Constraint:
	 *     (name=QualifiedName fromRole=[Role|QualifiedName] toRole=[Role|QualifiedName])
	 * </pre>
	 */
	protected void sequence_InteractionArtefact(ISerializationContext context, InteractionArtefact semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RmOdpPackage.Literals.INTERACTION_ARTEFACT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RmOdpPackage.Literals.INTERACTION_ARTEFACT__NAME));
			if (transientValues.isValueTransient(semanticObject, RmOdpPackage.Literals.INTERACTION_ARTEFACT__FROM_ROLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RmOdpPackage.Literals.INTERACTION_ARTEFACT__FROM_ROLE));
			if (transientValues.isValueTransient(semanticObject, RmOdpPackage.Literals.INTERACTION_ARTEFACT__TO_ROLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RmOdpPackage.Literals.INTERACTION_ARTEFACT__TO_ROLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInteractionArtefactAccess().getNameQualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getInteractionArtefactAccess().getFromRoleRoleQualifiedNameParserRuleCall_3_0_1(), semanticObject.eGet(RmOdpPackage.Literals.INTERACTION_ARTEFACT__FROM_ROLE, false));
		feeder.accept(grammarAccess.getInteractionArtefactAccess().getToRoleRoleQualifiedNameParserRuleCall_5_0_1(), semanticObject.eGet(RmOdpPackage.Literals.INTERACTION_ARTEFACT__TO_ROLE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Interaction returns Interaction
	 *
	 * Constraint:
	 *     (
	 *         name=QualifiedName 
	 *         (
	 *             process_def=[Process|QualifiedName]? 
	 *             initiator=[Role|QualifiedName] 
	 *             initiator_statemachine=StateMachine 
	 *             responder=[Role|QualifiedName] 
	 *             responder_statemachine=StateMachine 
	 *             interactionArtefacts+=InteractionArtefact*
	 *         )?
	 *     )
	 * </pre>
	 */
	protected void sequence_Interaction(ISerializationContext context, Interaction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Interface returns Interface
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             interfaceType='CV_StreamInterface' | 
	 *             interfaceType='CV_OperationInterface' | 
	 *             interfaceType='CV_SignalInterface' | 
	 *             interfaceType='NV_StreamInterface' | 
	 *             interfaceType='NV_OperationInterface' | 
	 *             interfaceType='NV_SignalInterface'
	 *         ) 
	 *         name=QualifiedName 
	 *         signatureReferences+=SignatureReference*
	 *     )
	 * </pre>
	 */
	protected void sequence_Interface(ISerializationContext context, Interface semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InvariantSchema returns InvariantSchema
	 *
	 * Constraint:
	 *     (name=QualifiedName objects+=Object* actionTypes+=ActionType*)
	 * </pre>
	 */
	protected void sequence_InvariantSchema(ISerializationContext context, InvariantSchema semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Lane returns Lane
	 *
	 * Constraint:
	 *     (role=[Role|QualifiedName] nodes+=Node*)
	 * </pre>
	 */
	protected void sequence_Lane(ISerializationContext context, Lane semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Link returns Link
	 *
	 * Constraint:
	 *     (name=QualifiedName hostNode=[HostNode|QualifiedName])
	 * </pre>
	 */
	protected void sequence_Link(ISerializationContext context, Link semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RmOdpPackage.Literals.LINK__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RmOdpPackage.Literals.LINK__NAME));
			if (transientValues.isValueTransient(semanticObject, RmOdpPackage.Literals.LINK__HOST_NODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RmOdpPackage.Literals.LINK__HOST_NODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLinkAccess().getNameQualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLinkAccess().getHostNodeHostNodeQualifiedNameParserRuleCall_3_0_1(), semanticObject.eGet(RmOdpPackage.Literals.LINK__HOST_NODE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     elements+=ModelElement+
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ModelElement returns NV_spec
	 *     Spec returns NV_spec
	 *     NV_spec returns NV_spec
	 *
	 * Constraint:
	 *     (name=QualifiedName hostNode+=HostNode*)
	 * </pre>
	 */
	protected void sequence_NV_spec(ISerializationContext context, NV_spec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OR_Relation returns OR_Relation
	 *
	 * Constraint:
	 *     (object=[Object|QualifiedName] role=[Role|QualifiedName])
	 * </pre>
	 */
	protected void sequence_OR_Relation(ISerializationContext context, OR_Relation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RmOdpPackage.Literals.OR_RELATION__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RmOdpPackage.Literals.OR_RELATION__OBJECT));
			if (transientValues.isValueTransient(semanticObject, RmOdpPackage.Literals.OR_RELATION__ROLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RmOdpPackage.Literals.OR_RELATION__ROLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOR_RelationAccess().getObjectObjectQualifiedNameParserRuleCall_1_0_1(), semanticObject.eGet(RmOdpPackage.Literals.OR_RELATION__OBJECT, false));
		feeder.accept(grammarAccess.getOR_RelationAccess().getRoleRoleQualifiedNameParserRuleCall_3_0_1(), semanticObject.eGet(RmOdpPackage.Literals.OR_RELATION__ROLE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ObjectInstance returns ObjectInstance
	 *
	 * Constraint:
	 *     (typeName=[Object|QualifiedName] name=QualifiedName propertyInstances+=PropertyInstance*)
	 * </pre>
	 */
	protected void sequence_ObjectInstance(ISerializationContext context, ObjectInstance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ObjectObligation returns ObjectObligation
	 *
	 * Constraint:
	 *     (name=QualifiedName inforce?='current'? objo=[Object|ID] object_obligation=STRING)
	 * </pre>
	 */
	protected void sequence_ObjectObligation(ISerializationContext context, ObjectObligation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ObjectPermission returns ObjectPermission
	 *
	 * Constraint:
	 *     (name=QualifiedName inforce?='current'? objp=[Object|QualifiedName] object_permission=STRING)
	 * </pre>
	 */
	protected void sequence_ObjectPermission(ISerializationContext context, ObjectPermission semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ObjectProhibition returns ObjectProhibition
	 *
	 * Constraint:
	 *     (name=QualifiedName inforce?='current'? objp=[Object|QualifiedName] object_prohibition=STRING)
	 * </pre>
	 */
	protected void sequence_ObjectProhibition(ISerializationContext context, ObjectProhibition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ModelElement returns Object
	 *     Object returns Object
	 *
	 * Constraint:
	 *     (
	 *         (ObjectType='EV_Object' | ObjectType='IV_Object' | ObjectType='CV_Object' | ObjectType='NV_Object' | ObjectType='TV_Object') 
	 *         name=QualifiedName 
	 *         superObject=[Object|QualifiedName]? 
	 *         properties+=Property* 
	 *         stateMachine=StateMachine? 
	 *         interfaces+=Interface* 
	 *         innerObjects+=Object* 
	 *         nvObject=[Object|QualifiedName]?
	 *     )
	 * </pre>
	 */
	protected void sequence_Object(ISerializationContext context, org.xtext.example.rmodp.rmOdp.Object semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Objective returns Objective
	 *
	 * Constraint:
	 *     (name=QualifiedName objective=STRING subobj+=Objective*)
	 * </pre>
	 */
	protected void sequence_Objective(ISerializationContext context, Objective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Outgoing returns Outgoing
	 *
	 * Constraint:
	 *     (outgoing+=[Node|QualifiedName]* outCondition=STRING?)
	 * </pre>
	 */
	protected void sequence_Outgoing(ISerializationContext context, Outgoing semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ModelElement returns PackageDeclaration
	 *     PackageDeclaration returns PackageDeclaration
	 *
	 * Constraint:
	 *     (name=QualifiedName elements+=ModelElement*)
	 * </pre>
	 */
	protected void sequence_PackageDeclaration(ISerializationContext context, PackageDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Param returns Param
	 *
	 * Constraint:
	 *     ((direction='in' | direction='out' | direction='inout') name=QualifiedName type=[Type|ID])
	 * </pre>
	 */
	protected void sequence_Param(ISerializationContext context, Param semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Policy returns Policy
	 *
	 * Constraint:
	 *     (
	 *         name=QualifiedName 
	 *         policy=STRING 
	 *         obligations+=ObjectObligation* 
	 *         obligations+=RoleObligation* 
	 *         permissions+=ObjectPermission* 
	 *         permissions+=RolePermission* 
	 *         prohibitions+=ObjectProhibition* 
	 *         prohibitions+=RoleProhibition* 
	 *         process=[Process|QualifiedName] 
	 *         affectedRole+=Role* 
	 *         affectedProcess+=Process* 
	 *         affectedInteraction+=Interaction*
	 *     )
	 * </pre>
	 */
	protected void sequence_Policy(ISerializationContext context, Policy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Process returns Process
	 *
	 * Constraint:
	 *     (name=QualifiedName processObjective=[Objective|QualifiedName]? lanes+=Lane*)
	 * </pre>
	 */
	protected void sequence_Process(ISerializationContext context, org.xtext.example.rmodp.rmOdp.Process semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PropertyInstance returns PropertyInstance
	 *
	 * Constraint:
	 *     (typeProperty=[Property|QualifiedName] propertyValue=STRING)
	 * </pre>
	 */
	protected void sequence_PropertyInstance(ISerializationContext context, PropertyInstance semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RmOdpPackage.Literals.PROPERTY_INSTANCE__TYPE_PROPERTY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RmOdpPackage.Literals.PROPERTY_INSTANCE__TYPE_PROPERTY));
			if (transientValues.isValueTransient(semanticObject, RmOdpPackage.Literals.PROPERTY_INSTANCE__PROPERTY_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RmOdpPackage.Literals.PROPERTY_INSTANCE__PROPERTY_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyInstanceAccess().getTypePropertyPropertyQualifiedNameParserRuleCall_0_0_1(), semanticObject.eGet(RmOdpPackage.Literals.PROPERTY_INSTANCE__TYPE_PROPERTY, false));
		feeder.accept(grammarAccess.getPropertyInstanceAccess().getPropertyValueSTRINGTerminalRuleCall_2_0(), semanticObject.getPropertyValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns Property
	 *
	 * Constraint:
	 *     (name=QualifiedName type=[ModelElement|QualifiedName] many?='[]'?)
	 * </pre>
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RoleObligation returns RoleObligation
	 *
	 * Constraint:
	 *     (name=QualifiedName inforce?='current'? roleo=[Role|QualifiedName] role_obligation=STRING)
	 * </pre>
	 */
	protected void sequence_RoleObligation(ISerializationContext context, RoleObligation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RolePermission returns RolePermission
	 *
	 * Constraint:
	 *     (name=QualifiedName inforce?='current'? rolep=[Role|QualifiedName] role_permission=STRING)
	 * </pre>
	 */
	protected void sequence_RolePermission(ISerializationContext context, RolePermission semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RoleProhibition returns RoleProhibition
	 *
	 * Constraint:
	 *     (name=QualifiedName inforce?='current'? rolep=[Role|QualifiedName] role_prohibition=STRING)
	 * </pre>
	 */
	protected void sequence_RoleProhibition(ISerializationContext context, RoleProhibition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Role returns Role
	 *
	 * Constraint:
	 *     (name=QualifiedName target=[Role|QualifiedName]?)
	 * </pre>
	 */
	protected void sequence_Role(ISerializationContext context, Role semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SignatureDef returns SignatureDef
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             signatureType='CV_SignalInterfaceSignature' | 
	 *             signatureType='CV_StreamInterfaceSignature' | 
	 *             signatureType='CV_OperationInterfaceSignature' | 
	 *             signatureType='CV_FlowSignature' | 
	 *             signatureType='NV_SignalInterfaceSignature' | 
	 *             signatureType='NV_StreamInterfaceSignature' | 
	 *             signatureType='NV_OperationInterfaceSignature' | 
	 *             signatureType='NV_FlowSignature'
	 *         ) 
	 *         name=QualifiedName 
	 *         params+=Param*
	 *     )
	 * </pre>
	 */
	protected void sequence_SignatureDef(ISerializationContext context, SignatureDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SignatureReference returns SignatureReference
	 *
	 * Constraint:
	 *     ((role='providing' | role='using') ref=[SignatureDef|ID])
	 * </pre>
	 */
	protected void sequence_SignatureReference(ISerializationContext context, SignatureReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ModelElement returns SimpleType
	 *     Type returns SimpleType
	 *     SimpleType returns SimpleType
	 *
	 * Constraint:
	 *     (name=QualifiedName superType=[SimpleType|ID]? properties+=Property*)
	 * </pre>
	 */
	protected void sequence_SimpleType(ISerializationContext context, SimpleType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns Start
	 *     Start returns Start
	 *
	 * Constraint:
	 *     (name=QualifiedName outgoing+=[Node|QualifiedName]*)
	 * </pre>
	 */
	protected void sequence_Start(ISerializationContext context, Start semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StateMachine returns StateMachine
	 *
	 * Constraint:
	 *     (events+=Event+ commands+=Command+ states+=State+)
	 * </pre>
	 */
	protected void sequence_StateMachine(ISerializationContext context, StateMachine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StateTransition returns StateTransition
	 *
	 * Constraint:
	 *     (event=[Event|ID] state=[State|ID])
	 * </pre>
	 */
	protected void sequence_StateTransition(ISerializationContext context, StateTransition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, RmOdpPackage.Literals.STATE_TRANSITION__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RmOdpPackage.Literals.STATE_TRANSITION__EVENT));
			if (transientValues.isValueTransient(semanticObject, RmOdpPackage.Literals.STATE_TRANSITION__STATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, RmOdpPackage.Literals.STATE_TRANSITION__STATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStateTransitionAccess().getEventEventIDTerminalRuleCall_0_0_1(), semanticObject.eGet(RmOdpPackage.Literals.STATE_TRANSITION__EVENT, false));
		feeder.accept(grammarAccess.getStateTransitionAccess().getStateStateIDTerminalRuleCall_2_0_1(), semanticObject.eGet(RmOdpPackage.Literals.STATE_TRANSITION__STATE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     State returns State
	 *
	 * Constraint:
	 *     (name=QualifiedName actions+=[Command|ID]* stateTransitions+=StateTransition*)
	 * </pre>
	 */
	protected void sequence_State(ISerializationContext context, State semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StaticSchema returns StaticSchema
	 *
	 * Constraint:
	 *     (name=QualifiedName time=STRING objectInstances+=ObjectInstance*)
	 * </pre>
	 */
	protected void sequence_StaticSchema(ISerializationContext context, StaticSchema semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Node returns Subprocess
	 *     Subprocess returns Subprocess
	 *
	 * Constraint:
	 *     (name=QualifiedName incomings+=Incoming* outgoings+=Outgoing*)
	 * </pre>
	 */
	protected void sequence_Subprocess(ISerializationContext context, Subprocess semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ModelElement returns TV_spec
	 *     Spec returns TV_spec
	 *     TV_spec returns TV_spec
	 *
	 * Constraint:
	 *     (name=QualifiedName objects+=Object* implementableStandards+=ImplementableStandard* ixits+=IXIT*)
	 * </pre>
	 */
	protected void sequence_TV_spec(ISerializationContext context, TV_spec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}

/*
 * generated by Xtext 2.35.0
 */
package ch.vobos.serializer;

import ch.vobos.services.TypescriptGrammarAccess;
import ch.vobos.typescript.AnnotationLine;
import ch.vobos.typescript.ArrayType;
import ch.vobos.typescript.ClassDeclaration;
import ch.vobos.typescript.ClassOrInterfaceTypeList;
import ch.vobos.typescript.Declaration;
import ch.vobos.typescript.DocComment;
import ch.vobos.typescript.ImportDeclaration;
import ch.vobos.typescript.IndexSignature;
import ch.vobos.typescript.InterfaceDeclaration;
import ch.vobos.typescript.InterfacesAndClasses;
import ch.vobos.typescript.ModuleBody;
import ch.vobos.typescript.ModuleDeclaration;
import ch.vobos.typescript.ModuleElement;
import ch.vobos.typescript.ObjectType;
import ch.vobos.typescript.PredefinedType;
import ch.vobos.typescript.PropertySignature;
import ch.vobos.typescript.TypeMember;
import ch.vobos.typescript.TypeReference;
import ch.vobos.typescript.Typescript;
import ch.vobos.typescript.TypescriptPackage;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class TypescriptSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private TypescriptGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == TypescriptPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TypescriptPackage.ANNOTATION_LINE:
				sequence_AnnotationLine(context, (AnnotationLine) semanticObject); 
				return; 
			case TypescriptPackage.ARRAY_TYPE:
				sequence_ArrayType(context, (ArrayType) semanticObject); 
				return; 
			case TypescriptPackage.CLASS_DECLARATION:
				if (rule == grammarAccess.getClassDeclarationRule()) {
					sequence_ClassDeclaration(context, (ClassDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getInterfaceOrClassDeclarationRule()) {
					sequence_ClassDeclaration_InterfaceOrClassDeclaration(context, (ClassDeclaration) semanticObject); 
					return; 
				}
				else break;
			case TypescriptPackage.CLASS_OR_INTERFACE_TYPE_LIST:
				sequence_ClassOrInterfaceTypeList(context, (ClassOrInterfaceTypeList) semanticObject); 
				return; 
			case TypescriptPackage.DECLARATION:
				sequence_Declaration(context, (Declaration) semanticObject); 
				return; 
			case TypescriptPackage.DOC_COMMENT:
				sequence_DocComment(context, (DocComment) semanticObject); 
				return; 
			case TypescriptPackage.IMPORT_DECLARATION:
				sequence_ImportDeclaration(context, (ImportDeclaration) semanticObject); 
				return; 
			case TypescriptPackage.INDEX_SIGNATURE:
				sequence_IndexSignature(context, (IndexSignature) semanticObject); 
				return; 
			case TypescriptPackage.INTERFACE_DECLARATION:
				if (rule == grammarAccess.getInterfaceDeclarationRule()) {
					sequence_InterfaceDeclaration(context, (InterfaceDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getInterfaceOrClassDeclarationRule()) {
					sequence_InterfaceDeclaration_InterfaceOrClassDeclaration(context, (InterfaceDeclaration) semanticObject); 
					return; 
				}
				else break;
			case TypescriptPackage.INTERFACES_AND_CLASSES:
				sequence_InterfacesAndClasses(context, (InterfacesAndClasses) semanticObject); 
				return; 
			case TypescriptPackage.MODULE_BODY:
				sequence_ModuleBody(context, (ModuleBody) semanticObject); 
				return; 
			case TypescriptPackage.MODULE_DECLARATION:
				sequence_ModuleDeclaration(context, (ModuleDeclaration) semanticObject); 
				return; 
			case TypescriptPackage.MODULE_ELEMENT:
				sequence_ModuleElement(context, (ModuleElement) semanticObject); 
				return; 
			case TypescriptPackage.OBJECT_TYPE:
				sequence_ObjectType(context, (ObjectType) semanticObject); 
				return; 
			case TypescriptPackage.PREDEFINED_TYPE:
				sequence_PredefinedType(context, (PredefinedType) semanticObject); 
				return; 
			case TypescriptPackage.PROPERTY_SIGNATURE:
				sequence_PropertySignature(context, (PropertySignature) semanticObject); 
				return; 
			case TypescriptPackage.TYPE_MEMBER:
				sequence_TypeMember(context, (TypeMember) semanticObject); 
				return; 
			case TypescriptPackage.TYPE_REFERENCE:
				sequence_TypeReference(context, (TypeReference) semanticObject); 
				return; 
			case TypescriptPackage.TYPESCRIPT:
				sequence_Typescript(context, (Typescript) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     AnnotationLine returns AnnotationLine
	 *
	 * Constraint:
	 *     annotationName=ID
	 * </pre>
	 */
	protected void sequence_AnnotationLine(ISerializationContext context, AnnotationLine semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypescriptPackage.Literals.ANNOTATION_LINE__ANNOTATION_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypescriptPackage.Literals.ANNOTATION_LINE__ANNOTATION_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnnotationLineAccess().getAnnotationNameIDTerminalRuleCall_1_0(), semanticObject.getAnnotationName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns ArrayType
	 *     TypeLiteral returns ArrayType
	 *     ArrayType returns ArrayType
	 *
	 * Constraint:
	 *     array=PredefinedType
	 * </pre>
	 */
	protected void sequence_ArrayType(ISerializationContext context, ArrayType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypescriptPackage.Literals.ARRAY_TYPE__ARRAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypescriptPackage.Literals.ARRAY_TYPE__ARRAY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayTypeAccess().getArrayPredefinedTypeParserRuleCall_0_1_0(), semanticObject.getArray());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ClassDeclaration returns ClassDeclaration
	 *
	 * Constraint:
	 *     name=Identifier
	 * </pre>
	 */
	protected void sequence_ClassDeclaration(ISerializationContext context, ClassDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypescriptPackage.Literals.INTERFACE_OR_CLASS_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypescriptPackage.Literals.INTERFACE_OR_CLASS_DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClassDeclarationAccess().getNameIdentifierParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InterfaceOrClassDeclaration returns ClassDeclaration
	 *
	 * Constraint:
	 *     (name=Identifier objectType=ObjectType)
	 * </pre>
	 */
	protected void sequence_ClassDeclaration_InterfaceOrClassDeclaration(ISerializationContext context, ClassDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypescriptPackage.Literals.INTERFACE_OR_CLASS_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypescriptPackage.Literals.INTERFACE_OR_CLASS_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, TypescriptPackage.Literals.INTERFACE_OR_CLASS_DECLARATION__OBJECT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypescriptPackage.Literals.INTERFACE_OR_CLASS_DECLARATION__OBJECT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClassDeclarationAccess().getNameIdentifierParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getInterfaceOrClassDeclarationAccess().getObjectTypeObjectTypeParserRuleCall_1_0(), semanticObject.getObjectType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InterfaceExtendsClause returns ClassOrInterfaceTypeList
	 *     ClassOrInterfaceTypeList returns ClassOrInterfaceTypeList
	 *
	 * Constraint:
	 *     (parents+=TypeReference parents+=TypeReference*)
	 * </pre>
	 */
	protected void sequence_ClassOrInterfaceTypeList(ISerializationContext context, ClassOrInterfaceTypeList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Declaration returns Declaration
	 *
	 * Constraint:
	 *     (docComment=DocComment? declaration=InterfaceOrClassDeclaration)
	 * </pre>
	 */
	protected void sequence_Declaration(ISerializationContext context, Declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DocComment returns DocComment
	 *
	 * Constraint:
	 *     (lines+=DOC_COMMENT_LINE* annotations+=AnnotationLine*)
	 * </pre>
	 */
	protected void sequence_DocComment(ISerializationContext context, DocComment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ImportDeclaration returns ImportDeclaration
	 *
	 * Constraint:
	 *     (alias=Identifier name=QualifiedName)
	 * </pre>
	 */
	protected void sequence_ImportDeclaration(ISerializationContext context, ImportDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypescriptPackage.Literals.IMPORT_DECLARATION__ALIAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypescriptPackage.Literals.IMPORT_DECLARATION__ALIAS));
			if (transientValues.isValueTransient(semanticObject, TypescriptPackage.Literals.IMPORT_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypescriptPackage.Literals.IMPORT_DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportDeclarationAccess().getAliasIdentifierParserRuleCall_1_0(), semanticObject.getAlias());
		feeder.accept(grammarAccess.getImportDeclarationAccess().getNameQualifiedNameParserRuleCall_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     IndexSignature returns IndexSignature
	 *
	 * Constraint:
	 *     (indexType=IndexType valueType=Type)
	 * </pre>
	 */
	protected void sequence_IndexSignature(ISerializationContext context, IndexSignature semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypescriptPackage.Literals.INDEX_SIGNATURE__INDEX_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypescriptPackage.Literals.INDEX_SIGNATURE__INDEX_TYPE));
			if (transientValues.isValueTransient(semanticObject, TypescriptPackage.Literals.INDEX_SIGNATURE__VALUE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypescriptPackage.Literals.INDEX_SIGNATURE__VALUE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIndexSignatureAccess().getIndexTypeIndexTypeEnumRuleCall_3_0(), semanticObject.getIndexType());
		feeder.accept(grammarAccess.getIndexSignatureAccess().getValueTypeTypeParserRuleCall_5_0(), semanticObject.getValueType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InterfaceDeclaration returns InterfaceDeclaration
	 *
	 * Constraint:
	 *     (name=Identifier extendClause=InterfaceExtendsClause?)
	 * </pre>
	 */
	protected void sequence_InterfaceDeclaration(ISerializationContext context, InterfaceDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InterfaceOrClassDeclaration returns InterfaceDeclaration
	 *
	 * Constraint:
	 *     (name=Identifier extendClause=InterfaceExtendsClause? objectType=ObjectType)
	 * </pre>
	 */
	protected void sequence_InterfaceDeclaration_InterfaceOrClassDeclaration(ISerializationContext context, InterfaceDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InterfacesAndClasses returns InterfacesAndClasses
	 *
	 * Constraint:
	 *     (modules+=ModuleDeclaration | types+=Declaration)*
	 * </pre>
	 */
	protected void sequence_InterfacesAndClasses(ISerializationContext context, InterfacesAndClasses semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ModuleBody returns ModuleBody
	 *
	 * Constraint:
	 *     elements+=ModuleElement*
	 * </pre>
	 */
	protected void sequence_ModuleBody(ISerializationContext context, ModuleBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ModuleDeclaration returns ModuleDeclaration
	 *
	 * Constraint:
	 *     (docComment=DocComment? name=Identifier body=ModuleBody)
	 * </pre>
	 */
	protected void sequence_ModuleDeclaration(ISerializationContext context, ModuleDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ModuleElement returns ModuleElement
	 *
	 * Constraint:
	 *     (exported?='export'? (moduleContent=Declaration | moduleContent=ModuleDeclaration | moduleContent=ImportDeclaration))
	 * </pre>
	 */
	protected void sequence_ModuleElement(ISerializationContext context, ModuleElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ObjectType returns ObjectType
	 *     Type returns ObjectType
	 *     TypeLiteral returns ObjectType
	 *
	 * Constraint:
	 *     members+=TypeMember*
	 * </pre>
	 */
	protected void sequence_ObjectType(ISerializationContext context, ObjectType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns PredefinedType
	 *     PredefinedType returns PredefinedType
	 *
	 * Constraint:
	 *     predefinedType=PredefinedTypeEnum
	 * </pre>
	 */
	protected void sequence_PredefinedType(ISerializationContext context, PredefinedType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypescriptPackage.Literals.PREDEFINED_TYPE__PREDEFINED_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypescriptPackage.Literals.PREDEFINED_TYPE__PREDEFINED_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPredefinedTypeAccess().getPredefinedTypePredefinedTypeEnumEnumRuleCall_0(), semanticObject.getPredefinedType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PropertySignature returns PropertySignature
	 *
	 * Constraint:
	 *     (name=IdentifierName optional?='?'? type=Type)
	 * </pre>
	 */
	protected void sequence_PropertySignature(ISerializationContext context, PropertySignature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeMember returns TypeMember
	 *
	 * Constraint:
	 *     (docComment=DocComment? (signature=PropertySignature | signature=IndexSignature))
	 * </pre>
	 */
	protected void sequence_TypeMember(ISerializationContext context, TypeMember semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Type returns TypeReference
	 *     TypeLiteral returns TypeReference
	 *     ArrayType returns TypeReference
	 *     TypeReference returns TypeReference
	 *
	 * Constraint:
	 *     reference=[InterfaceOrClassDeclaration|QualifiedName]
	 * </pre>
	 */
	protected void sequence_TypeReference(ISerializationContext context, TypeReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypescriptPackage.Literals.TYPE_REFERENCE__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypescriptPackage.Literals.TYPE_REFERENCE__REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeReferenceAccess().getReferenceInterfaceOrClassDeclarationQualifiedNameParserRuleCall_0_1(), semanticObject.eGet(TypescriptPackage.Literals.TYPE_REFERENCE__REFERENCE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Typescript returns Typescript
	 *
	 * Constraint:
	 *     (imports+=ImportDeclaration* interfacesAndClasses=InterfacesAndClasses)
	 * </pre>
	 */
	protected void sequence_Typescript(ISerializationContext context, Typescript semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}

/*
 * generated by Xtext 2.35.0
 */
package ch.vobos.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class TypescriptGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class TypescriptElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.Typescript");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cImportsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cImportsImportDeclarationParserRuleCall_0_0 = (RuleCall)cImportsAssignment_0.eContents().get(0);
		private final Assignment cInterfacesAndClassesAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cInterfacesAndClassesInterfacesAndClassesParserRuleCall_1_0 = (RuleCall)cInterfacesAndClassesAssignment_1.eContents().get(0);
		
		//// TODO complete this to be the full TS grammar...
		//// ... based on a full JS grammar.. looking at e.g. http://www.antlr3.org/grammar/1153976512034/ecmascriptA3.g for inspiration?
		//Typescript:
		//    imports+= ImportDeclaration*
		//    interfacesAndClasses=InterfacesAndClasses;
		@Override public ParserRule getRule() { return rule; }
		
		//imports+= ImportDeclaration*
		//interfacesAndClasses=InterfacesAndClasses
		public Group getGroup() { return cGroup; }
		
		//imports+= ImportDeclaration*
		public Assignment getImportsAssignment_0() { return cImportsAssignment_0; }
		
		//ImportDeclaration
		public RuleCall getImportsImportDeclarationParserRuleCall_0_0() { return cImportsImportDeclarationParserRuleCall_0_0; }
		
		//interfacesAndClasses=InterfacesAndClasses
		public Assignment getInterfacesAndClassesAssignment_1() { return cInterfacesAndClassesAssignment_1; }
		
		//InterfacesAndClasses
		public RuleCall getInterfacesAndClassesInterfacesAndClassesParserRuleCall_1_0() { return cInterfacesAndClassesInterfacesAndClassesParserRuleCall_1_0; }
	}
	public class InterfacesAndClassesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.InterfacesAndClasses");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cInterfacesAndClassesAction_0 = (Action)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Assignment cModulesAssignment_1_0 = (Assignment)cAlternatives_1.eContents().get(0);
		private final RuleCall cModulesModuleDeclarationParserRuleCall_1_0_0 = (RuleCall)cModulesAssignment_1_0.eContents().get(0);
		private final Assignment cTypesAssignment_1_1 = (Assignment)cAlternatives_1.eContents().get(1);
		private final RuleCall cTypesDeclarationParserRuleCall_1_1_0 = (RuleCall)cTypesAssignment_1_1.eContents().get(0);
		
		//InterfacesAndClasses: {InterfacesAndClasses}
		//    (modules+=ModuleDeclaration  | types+=Declaration)*;
		@Override public ParserRule getRule() { return rule; }
		
		//{InterfacesAndClasses}
		//   (modules+=ModuleDeclaration  | types+=Declaration)*
		public Group getGroup() { return cGroup; }
		
		//{InterfacesAndClasses}
		public Action getInterfacesAndClassesAction_0() { return cInterfacesAndClassesAction_0; }
		
		//(modules+=ModuleDeclaration  | types+=Declaration)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//modules+=ModuleDeclaration
		public Assignment getModulesAssignment_1_0() { return cModulesAssignment_1_0; }
		
		//ModuleDeclaration
		public RuleCall getModulesModuleDeclarationParserRuleCall_1_0_0() { return cModulesModuleDeclarationParserRuleCall_1_0_0; }
		
		//types+=Declaration
		public Assignment getTypesAssignment_1_1() { return cTypesAssignment_1_1; }
		
		//Declaration
		public RuleCall getTypesDeclarationParserRuleCall_1_1_0() { return cTypesDeclarationParserRuleCall_1_1_0; }
	}
	public class ImportDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.ImportDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cAliasAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cAliasIdentifierParserRuleCall_1_0 = (RuleCall)cAliasAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNameAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNameQualifiedNameParserRuleCall_3_0 = (RuleCall)cNameAssignment_3.eContents().get(0);
		
		//ImportDeclaration:
		//    "import" alias=Identifier "=" name=QualifiedName ;
		@Override public ParserRule getRule() { return rule; }
		
		//"import" alias=Identifier "=" name=QualifiedName
		public Group getGroup() { return cGroup; }
		
		//"import"
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }
		
		//alias=Identifier
		public Assignment getAliasAssignment_1() { return cAliasAssignment_1; }
		
		//Identifier
		public RuleCall getAliasIdentifierParserRuleCall_1_0() { return cAliasIdentifierParserRuleCall_1_0; }
		
		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }
		
		//name=QualifiedName
		public Assignment getNameAssignment_3() { return cNameAssignment_3; }
		
		//QualifiedName
		public RuleCall getNameQualifiedNameParserRuleCall_3_0() { return cNameQualifiedNameParserRuleCall_3_0; }
	}
	public class ModuleDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.ModuleDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDocCommentAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDocCommentDocCommentParserRuleCall_0_0 = (RuleCall)cDocCommentAssignment_0.eContents().get(0);
		private final Keyword cModuleKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameIdentifierParserRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cFullStopKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final RuleCall cIdentifierParserRuleCall_3_1 = (RuleCall)cGroup_3.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cBodyAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cBodyModuleBodyParserRuleCall_5_0 = (RuleCall)cBodyAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//ModuleDeclaration:
		//    docComment=DocComment?  "module" name=Identifier ("." Identifier)*  "{" body=ModuleBody "}" ;
		@Override public ParserRule getRule() { return rule; }
		
		//docComment=DocComment?  "module" name=Identifier ("." Identifier)*  "{" body=ModuleBody "}"
		public Group getGroup() { return cGroup; }
		
		//docComment=DocComment?
		public Assignment getDocCommentAssignment_0() { return cDocCommentAssignment_0; }
		
		//DocComment
		public RuleCall getDocCommentDocCommentParserRuleCall_0_0() { return cDocCommentDocCommentParserRuleCall_0_0; }
		
		//"module"
		public Keyword getModuleKeyword_1() { return cModuleKeyword_1; }
		
		//name=Identifier
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//Identifier
		public RuleCall getNameIdentifierParserRuleCall_2_0() { return cNameIdentifierParserRuleCall_2_0; }
		
		//("." Identifier)*
		public Group getGroup_3() { return cGroup_3; }
		
		//"."
		public Keyword getFullStopKeyword_3_0() { return cFullStopKeyword_3_0; }
		
		//Identifier
		public RuleCall getIdentifierParserRuleCall_3_1() { return cIdentifierParserRuleCall_3_1; }
		
		//"{"
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//body=ModuleBody
		public Assignment getBodyAssignment_5() { return cBodyAssignment_5; }
		
		//ModuleBody
		public RuleCall getBodyModuleBodyParserRuleCall_5_0() { return cBodyModuleBodyParserRuleCall_5_0; }
		
		//"}"
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}
	public class ModuleBodyElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.ModuleBody");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cModuleBodyAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cElementsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cElementsModuleElementParserRuleCall_1_0 = (RuleCall)cElementsAssignment_1.eContents().get(0);
		
		//ModuleBody: {ModuleBody}
		//    elements+=ModuleElement*;
		@Override public ParserRule getRule() { return rule; }
		
		//{ModuleBody}
		//   elements+=ModuleElement*
		public Group getGroup() { return cGroup; }
		
		//{ModuleBody}
		public Action getModuleBodyAction_0() { return cModuleBodyAction_0; }
		
		//elements+=ModuleElement*
		public Assignment getElementsAssignment_1() { return cElementsAssignment_1; }
		
		//ModuleElement
		public RuleCall getElementsModuleElementParserRuleCall_1_0() { return cElementsModuleElementParserRuleCall_1_0; }
	}
	public class ModuleElementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.ModuleElement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cExportedAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cExportedExportKeyword_0_0 = (Keyword)cExportedAssignment_0.eContents().get(0);
		private final Assignment cModuleContentAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cModuleContentAlternatives_1_0 = (Alternatives)cModuleContentAssignment_1.eContents().get(0);
		private final RuleCall cModuleContentDeclarationParserRuleCall_1_0_0 = (RuleCall)cModuleContentAlternatives_1_0.eContents().get(0);
		private final RuleCall cModuleContentModuleDeclarationParserRuleCall_1_0_1 = (RuleCall)cModuleContentAlternatives_1_0.eContents().get(1);
		private final RuleCall cModuleContentImportDeclarationParserRuleCall_1_0_2 = (RuleCall)cModuleContentAlternatives_1_0.eContents().get(2);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//ModuleElement:
		//        /*Statement |  */
		//     exported?="export"? moduleContent=( Declaration
		//     /* | EnumDeclaration |VariableDeclaration | FunctionDeclaration  */ | ModuleDeclaration | ImportDeclaration )
		//     ';'?;
		@Override public ParserRule getRule() { return rule; }
		
		//   /*Statement |  */
		//exported?="export"? moduleContent=( Declaration
		///* | EnumDeclaration |VariableDeclaration | FunctionDeclaration  */ | ModuleDeclaration | ImportDeclaration )
		//';'?
		public Group getGroup() { return cGroup; }
		
		//   /*Statement |  */
		//exported?="export"?
		public Assignment getExportedAssignment_0() { return cExportedAssignment_0; }
		
		//"export"
		public Keyword getExportedExportKeyword_0_0() { return cExportedExportKeyword_0_0; }
		
		//moduleContent=( Declaration
		//    /* | EnumDeclaration |VariableDeclaration | FunctionDeclaration  */ | ModuleDeclaration | ImportDeclaration )
		public Assignment getModuleContentAssignment_1() { return cModuleContentAssignment_1; }
		
		//( Declaration
		//     /* | EnumDeclaration |VariableDeclaration | FunctionDeclaration  */ | ModuleDeclaration | ImportDeclaration )
		public Alternatives getModuleContentAlternatives_1_0() { return cModuleContentAlternatives_1_0; }
		
		//Declaration
		public RuleCall getModuleContentDeclarationParserRuleCall_1_0_0() { return cModuleContentDeclarationParserRuleCall_1_0_0; }
		
		//ModuleDeclaration
		public RuleCall getModuleContentModuleDeclarationParserRuleCall_1_0_1() { return cModuleContentModuleDeclarationParserRuleCall_1_0_1; }
		
		//ImportDeclaration
		public RuleCall getModuleContentImportDeclarationParserRuleCall_1_0_2() { return cModuleContentImportDeclarationParserRuleCall_1_0_2; }
		
		//';'?
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
	}
	public class DeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.Declaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDocCommentAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDocCommentDocCommentParserRuleCall_0_0 = (RuleCall)cDocCommentAssignment_0.eContents().get(0);
		private final Assignment cDeclarationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cDeclarationInterfaceOrClassDeclarationParserRuleCall_1_0 = (RuleCall)cDeclarationAssignment_1.eContents().get(0);
		
		//Declaration:
		//    docComment=DocComment? declaration=InterfaceOrClassDeclaration;
		@Override public ParserRule getRule() { return rule; }
		
		//docComment=DocComment? declaration=InterfaceOrClassDeclaration
		public Group getGroup() { return cGroup; }
		
		//docComment=DocComment?
		public Assignment getDocCommentAssignment_0() { return cDocCommentAssignment_0; }
		
		//DocComment
		public RuleCall getDocCommentDocCommentParserRuleCall_0_0() { return cDocCommentDocCommentParserRuleCall_0_0; }
		
		//declaration=InterfaceOrClassDeclaration
		public Assignment getDeclarationAssignment_1() { return cDeclarationAssignment_1; }
		
		//InterfaceOrClassDeclaration
		public RuleCall getDeclarationInterfaceOrClassDeclarationParserRuleCall_1_0() { return cDeclarationInterfaceOrClassDeclarationParserRuleCall_1_0; }
	}
	public class InterfaceOrClassDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.InterfaceOrClassDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cInterfaceDeclarationParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cClassDeclarationParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final Assignment cObjectTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cObjectTypeObjectTypeParserRuleCall_1_0 = (RuleCall)cObjectTypeAssignment_1.eContents().get(0);
		
		//InterfaceOrClassDeclaration: (InterfaceDeclaration | ClassDeclaration) objectType=ObjectType;
		@Override public ParserRule getRule() { return rule; }
		
		//(InterfaceDeclaration | ClassDeclaration) objectType=ObjectType
		public Group getGroup() { return cGroup; }
		
		//(InterfaceDeclaration | ClassDeclaration)
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//InterfaceDeclaration
		public RuleCall getInterfaceDeclarationParserRuleCall_0_0() { return cInterfaceDeclarationParserRuleCall_0_0; }
		
		//ClassDeclaration
		public RuleCall getClassDeclarationParserRuleCall_0_1() { return cClassDeclarationParserRuleCall_0_1; }
		
		//objectType=ObjectType
		public Assignment getObjectTypeAssignment_1() { return cObjectTypeAssignment_1; }
		
		//ObjectType
		public RuleCall getObjectTypeObjectTypeParserRuleCall_1_0() { return cObjectTypeObjectTypeParserRuleCall_1_0; }
	}
	public class InterfaceDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.InterfaceDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cInterfaceKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIdentifierParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Assignment cExtendClauseAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExtendClauseInterfaceExtendsClauseParserRuleCall_2_0 = (RuleCall)cExtendClauseAssignment_2.eContents().get(0);
		
		//InterfaceDeclaration:
		//    "interface" name=Identifier /* TypeParameters? */ extendClause=InterfaceExtendsClause?;
		@Override public ParserRule getRule() { return rule; }
		
		//"interface" name=Identifier /* TypeParameters? */ extendClause=InterfaceExtendsClause?
		public Group getGroup() { return cGroup; }
		
		//"interface"
		public Keyword getInterfaceKeyword_0() { return cInterfaceKeyword_0; }
		
		//name=Identifier
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//Identifier
		public RuleCall getNameIdentifierParserRuleCall_1_0() { return cNameIdentifierParserRuleCall_1_0; }
		
		///* TypeParameters? */ extendClause=InterfaceExtendsClause?
		public Assignment getExtendClauseAssignment_2() { return cExtendClauseAssignment_2; }
		
		//InterfaceExtendsClause
		public RuleCall getExtendClauseInterfaceExtendsClauseParserRuleCall_2_0() { return cExtendClauseInterfaceExtendsClauseParserRuleCall_2_0; }
	}
	public class ClassDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.ClassDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cClassKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameIdentifierParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//ClassDeclaration:
		//    "class" name=Identifier /* TypeParameter ClassHeritage */;
		@Override public ParserRule getRule() { return rule; }
		
		//"class" name=Identifier
		public Group getGroup() { return cGroup; }
		
		//"class"
		public Keyword getClassKeyword_0() { return cClassKeyword_0; }
		
		//name=Identifier
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//Identifier
		public RuleCall getNameIdentifierParserRuleCall_1_0() { return cNameIdentifierParserRuleCall_1_0; }
	}
	public class IdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.Identifier");
		private final RuleCall cIDTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		// // TODO: for now we treat interfaces and classes the same
		//Identifier:
		//    ID;
		@Override public ParserRule getRule() { return rule; }
		
		//ID
		public RuleCall getIDTerminalRuleCall() { return cIDTerminalRuleCall; }
	}
	public class InterfaceExtendsClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.InterfaceExtendsClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cExtendsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cClassOrInterfaceTypeListParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//InterfaceExtendsClause:
		//    "extends" ClassOrInterfaceTypeList;
		@Override public ParserRule getRule() { return rule; }
		
		//"extends" ClassOrInterfaceTypeList
		public Group getGroup() { return cGroup; }
		
		//"extends"
		public Keyword getExtendsKeyword_0() { return cExtendsKeyword_0; }
		
		//ClassOrInterfaceTypeList
		public RuleCall getClassOrInterfaceTypeListParserRuleCall_1() { return cClassOrInterfaceTypeListParserRuleCall_1; }
	}
	public class ClassOrInterfaceTypeListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.ClassOrInterfaceTypeList");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cClassOrInterfaceTypeListAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cParentsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cParentsTypeReferenceParserRuleCall_1_0 = (RuleCall)cParentsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cParentsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cParentsTypeReferenceParserRuleCall_2_1_0 = (RuleCall)cParentsAssignment_2_1.eContents().get(0);
		
		//ClassOrInterfaceTypeList: { ClassOrInterfaceTypeList }
		//    parents += TypeReference (',' parents += TypeReference)*
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//{ ClassOrInterfaceTypeList }
		//   parents += TypeReference (',' parents += TypeReference)*
		public Group getGroup() { return cGroup; }
		
		//{ ClassOrInterfaceTypeList }
		public Action getClassOrInterfaceTypeListAction_0() { return cClassOrInterfaceTypeListAction_0; }
		
		//parents += TypeReference
		public Assignment getParentsAssignment_1() { return cParentsAssignment_1; }
		
		//TypeReference
		public RuleCall getParentsTypeReferenceParserRuleCall_1_0() { return cParentsTypeReferenceParserRuleCall_1_0; }
		
		//(',' parents += TypeReference)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//parents += TypeReference
		public Assignment getParentsAssignment_2_1() { return cParentsAssignment_2_1; }
		
		//TypeReference
		public RuleCall getParentsTypeReferenceParserRuleCall_2_1_0() { return cParentsTypeReferenceParserRuleCall_2_1_0; }
	}
	public class ObjectTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.ObjectType");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cObjectTypeAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cMembersAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cMembersTypeMemberParserRuleCall_2_0_0 = (RuleCall)cMembersAssignment_2_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ObjectType: { ObjectType }
		//    "{" (members += TypeMember ';'?)* "}";
		@Override public ParserRule getRule() { return rule; }
		
		//{ ObjectType }
		//   "{" (members += TypeMember ';'?)* "}"
		public Group getGroup() { return cGroup; }
		
		//{ ObjectType }
		public Action getObjectTypeAction_0() { return cObjectTypeAction_0; }
		
		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//(members += TypeMember ';'?)*
		public Group getGroup_2() { return cGroup_2; }
		
		//members += TypeMember
		public Assignment getMembersAssignment_2_0() { return cMembersAssignment_2_0; }
		
		//TypeMember
		public RuleCall getMembersTypeMemberParserRuleCall_2_0_0() { return cMembersTypeMemberParserRuleCall_2_0_0; }
		
		//';'?
		public Keyword getSemicolonKeyword_2_1() { return cSemicolonKeyword_2_1; }
		
		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class TypeMemberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.TypeMember");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cDocCommentAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cDocCommentDocCommentParserRuleCall_0_0 = (RuleCall)cDocCommentAssignment_0.eContents().get(0);
		private final Assignment cSignatureAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Alternatives cSignatureAlternatives_1_0 = (Alternatives)cSignatureAssignment_1.eContents().get(0);
		private final RuleCall cSignaturePropertySignatureParserRuleCall_1_0_0 = (RuleCall)cSignatureAlternatives_1_0.eContents().get(0);
		private final RuleCall cSignatureIndexSignatureParserRuleCall_1_0_1 = (RuleCall)cSignatureAlternatives_1_0.eContents().get(1);
		
		//TypeMember:
		//    docComment = DocComment?
		//    signature = ( PropertySignature
		//    /*    | CallSignature
		//        | ConstructSignature */
		//        | IndexSignature
		//    /*  | MethodSignature */
		//    );
		@Override public ParserRule getRule() { return rule; }
		
		//docComment = DocComment?
		//signature = ( PropertySignature
		///*    | CallSignature
		//    | ConstructSignature */
		//    | IndexSignature
		///*  | MethodSignature */
		//)
		public Group getGroup() { return cGroup; }
		
		//docComment = DocComment?
		public Assignment getDocCommentAssignment_0() { return cDocCommentAssignment_0; }
		
		//DocComment
		public RuleCall getDocCommentDocCommentParserRuleCall_0_0() { return cDocCommentDocCommentParserRuleCall_0_0; }
		
		//signature = ( PropertySignature
		///*    | CallSignature
		//    | ConstructSignature */
		//    | IndexSignature
		///*  | MethodSignature */
		//)
		public Assignment getSignatureAssignment_1() { return cSignatureAssignment_1; }
		
		//( PropertySignature
		//   /*    | CallSignature
		//       | ConstructSignature */
		//       | IndexSignature
		//   /*  | MethodSignature */
		//   )
		public Alternatives getSignatureAlternatives_1_0() { return cSignatureAlternatives_1_0; }
		
		//PropertySignature
		public RuleCall getSignaturePropertySignatureParserRuleCall_1_0_0() { return cSignaturePropertySignatureParserRuleCall_1_0_0; }
		
		//IndexSignature
		public RuleCall getSignatureIndexSignatureParserRuleCall_1_0_1() { return cSignatureIndexSignatureParserRuleCall_1_0_1; }
	}
	public class PropertySignatureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.PropertySignature");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameIdentifierNameParserRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cOptionalAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cOptionalQuestionMarkKeyword_1_0 = (Keyword)cOptionalAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cTypeTypeParserRuleCall_3_0 = (RuleCall)cTypeAssignment_3.eContents().get(0);
		
		//PropertySignature:
		//    name = IdentifierName // | StringLiteral | NumericLiteral
		//    optional ?= "?"?
		//    ":"
		//    type=Type;
		@Override public ParserRule getRule() { return rule; }
		
		//name = IdentifierName // | StringLiteral | NumericLiteral
		//optional ?= "?"?
		//":"
		//type=Type
		public Group getGroup() { return cGroup; }
		
		//name = IdentifierName
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//IdentifierName
		public RuleCall getNameIdentifierNameParserRuleCall_0_0() { return cNameIdentifierNameParserRuleCall_0_0; }
		
		//// | StringLiteral | NumericLiteral
		//   optional ?= "?"?
		public Assignment getOptionalAssignment_1() { return cOptionalAssignment_1; }
		
		//"?"
		public Keyword getOptionalQuestionMarkKeyword_1_0() { return cOptionalQuestionMarkKeyword_1_0; }
		
		//":"
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//type=Type
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }
		
		//Type
		public RuleCall getTypeTypeParserRuleCall_3_0() { return cTypeTypeParserRuleCall_3_0; }
	}
	public class IdentifierNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.IdentifierName");
		private final RuleCall cIDTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//IdentifierName:
		//    ID;
		@Override public ParserRule getRule() { return rule; }
		
		//ID
		public RuleCall getIDTerminalRuleCall() { return cIDTerminalRuleCall; }
	}
	public class StringLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.StringLiteral");
		private final RuleCall cSTRINGTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//StringLiteral:
		//    STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//STRING
		public RuleCall getSTRINGTerminalRuleCall() { return cSTRINGTerminalRuleCall; }
	}
	public class NumericLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.NumericLiteral");
		private final RuleCall cINTTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//NumericLiteral:
		//    INT // TODO valid NumericLiteral in http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//INT
		public RuleCall getINTTerminalRuleCall() { return cINTTerminalRuleCall; }
	}
	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.Type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPredefinedTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypeReferenceParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cTypeLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Type: PredefinedType | TypeReference | TypeLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//PredefinedType | TypeReference | TypeLiteral
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PredefinedType
		public RuleCall getPredefinedTypeParserRuleCall_0() { return cPredefinedTypeParserRuleCall_0; }
		
		//TypeReference
		public RuleCall getTypeReferenceParserRuleCall_1() { return cTypeReferenceParserRuleCall_1; }
		
		//TypeLiteral
		public RuleCall getTypeLiteralParserRuleCall_2() { return cTypeLiteralParserRuleCall_2; }
	}
	public class PredefinedTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.PredefinedType");
		private final Assignment cPredefinedTypeAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cPredefinedTypePredefinedTypeEnumEnumRuleCall_0 = (RuleCall)cPredefinedTypeAssignment.eContents().get(0);
		
		// // | TypeQuery
		//PredefinedType:
		//    predefinedType = PredefinedTypeEnum;
		@Override public ParserRule getRule() { return rule; }
		
		//predefinedType = PredefinedTypeEnum
		public Assignment getPredefinedTypeAssignment() { return cPredefinedTypeAssignment; }
		
		//PredefinedTypeEnum
		public RuleCall getPredefinedTypePredefinedTypeEnumEnumRuleCall_0() { return cPredefinedTypePredefinedTypeEnumEnumRuleCall_0; }
	}
	public class TypeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.TypeLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cObjectTypeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cArrayTypeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//TypeLiteral:
		//    ObjectType | ArrayType  /* | FunctionType | ConstructorType */ ;
		@Override public ParserRule getRule() { return rule; }
		
		//ObjectType | ArrayType
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ObjectType
		public RuleCall getObjectTypeParserRuleCall_0() { return cObjectTypeParserRuleCall_0; }
		
		//ArrayType
		public RuleCall getArrayTypeParserRuleCall_1() { return cArrayTypeParserRuleCall_1; }
	}
	public class ArrayTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.ArrayType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Action cArrayTypeAction_0_0 = (Action)cGroup_0.eContents().get(0);
		private final Assignment cArrayAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cArrayPredefinedTypeParserRuleCall_0_1_0 = (RuleCall)cArrayAssignment_0_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final Keyword cRightSquareBracketKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cTypeReferenceParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cRightSquareBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//ArrayType: {ArrayType}
		//    array = PredefinedType "[" "]" |  TypeReference "[" "]"
		//    /*ObjectType [ ]
		//    ArrayType [ ] */;
		@Override public ParserRule getRule() { return rule; }
		
		//{ArrayType}
		//   array = PredefinedType "[" "]" |  TypeReference "[" "]"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//{ArrayType}
		//   array = PredefinedType "[" "]"
		public Group getGroup_0() { return cGroup_0; }
		
		//{ArrayType}
		public Action getArrayTypeAction_0_0() { return cArrayTypeAction_0_0; }
		
		//array = PredefinedType
		public Assignment getArrayAssignment_0_1() { return cArrayAssignment_0_1; }
		
		//PredefinedType
		public RuleCall getArrayPredefinedTypeParserRuleCall_0_1_0() { return cArrayPredefinedTypeParserRuleCall_0_1_0; }
		
		//"["
		public Keyword getLeftSquareBracketKeyword_0_2() { return cLeftSquareBracketKeyword_0_2; }
		
		//"]"
		public Keyword getRightSquareBracketKeyword_0_3() { return cRightSquareBracketKeyword_0_3; }
		
		//TypeReference "[" "]"
		public Group getGroup_1() { return cGroup_1; }
		
		//TypeReference
		public RuleCall getTypeReferenceParserRuleCall_1_0() { return cTypeReferenceParserRuleCall_1_0; }
		
		//"["
		public Keyword getLeftSquareBracketKeyword_1_1() { return cLeftSquareBracketKeyword_1_1; }
		
		//"]"
		public Keyword getRightSquareBracketKeyword_1_2() { return cRightSquareBracketKeyword_1_2; }
	}
	public class TypeReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.TypeReference");
		private final Assignment cReferenceAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cReferenceInterfaceOrClassDeclarationCrossReference_0 = (CrossReference)cReferenceAssignment.eContents().get(0);
		private final RuleCall cReferenceInterfaceOrClassDeclarationQualifiedNameParserRuleCall_0_1 = (RuleCall)cReferenceInterfaceOrClassDeclarationCrossReference_0.eContents().get(1);
		
		//TypeReference:
		//    reference = [InterfaceOrClassDeclaration|QualifiedName];
		@Override public ParserRule getRule() { return rule; }
		
		//reference = [InterfaceOrClassDeclaration|QualifiedName]
		public Assignment getReferenceAssignment() { return cReferenceAssignment; }
		
		//[InterfaceOrClassDeclaration|QualifiedName]
		public CrossReference getReferenceInterfaceOrClassDeclarationCrossReference_0() { return cReferenceInterfaceOrClassDeclarationCrossReference_0; }
		
		//QualifiedName
		public RuleCall getReferenceInterfaceOrClassDeclarationQualifiedNameParserRuleCall_0_1() { return cReferenceInterfaceOrClassDeclarationQualifiedNameParserRuleCall_0_1; }
	}
	public class QualifiedNameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.QualifiedName");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cFullStopKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//QualifiedName:
		//    ID ('.' ID)* ;
		@Override public ParserRule getRule() { return rule; }
		
		//ID ('.' ID)*
		public Group getGroup() { return cGroup; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//('.' ID)*
		public Group getGroup_1() { return cGroup_1; }
		
		//'.'
		public Keyword getFullStopKeyword_1_0() { return cFullStopKeyword_1_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1_1() { return cIDTerminalRuleCall_1_1; }
	}
	public class DocCommentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.DocComment");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cDocCommentAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSolidusAsteriskAsteriskKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cLinesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cLinesDOC_COMMENT_LINETerminalRuleCall_2_0 = (RuleCall)cLinesAssignment_2.eContents().get(0);
		private final Assignment cAnnotationsAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAnnotationsAnnotationLineParserRuleCall_3_0 = (RuleCall)cAnnotationsAssignment_3.eContents().get(0);
		private final RuleCall cDOC_COMMENT_ENDTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//DocComment: {DocComment}
		//    '/**' lines+=DOC_COMMENT_LINE* annotations+=AnnotationLine* DOC_COMMENT_END;
		@Override public ParserRule getRule() { return rule; }
		
		//{DocComment}
		//   '/**' lines+=DOC_COMMENT_LINE* annotations+=AnnotationLine* DOC_COMMENT_END
		public Group getGroup() { return cGroup; }
		
		//{DocComment}
		public Action getDocCommentAction_0() { return cDocCommentAction_0; }
		
		//'/**'
		public Keyword getSolidusAsteriskAsteriskKeyword_1() { return cSolidusAsteriskAsteriskKeyword_1; }
		
		//lines+=DOC_COMMENT_LINE*
		public Assignment getLinesAssignment_2() { return cLinesAssignment_2; }
		
		//DOC_COMMENT_LINE
		public RuleCall getLinesDOC_COMMENT_LINETerminalRuleCall_2_0() { return cLinesDOC_COMMENT_LINETerminalRuleCall_2_0; }
		
		//annotations+=AnnotationLine*
		public Assignment getAnnotationsAssignment_3() { return cAnnotationsAssignment_3; }
		
		//AnnotationLine
		public RuleCall getAnnotationsAnnotationLineParserRuleCall_3_0() { return cAnnotationsAnnotationLineParserRuleCall_3_0; }
		
		//DOC_COMMENT_END
		public RuleCall getDOC_COMMENT_ENDTerminalRuleCall_4() { return cDOC_COMMENT_ENDTerminalRuleCall_4; }
	}
	public class AnnotationLineElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.AnnotationLine");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cDOC_ANNOTATION_PREFIXTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cAnnotationNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cAnnotationNameIDTerminalRuleCall_1_0 = (RuleCall)cAnnotationNameAssignment_1.eContents().get(0);
		
		//AnnotationLine:
		//    DOC_ANNOTATION_PREFIX annotationName=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//DOC_ANNOTATION_PREFIX annotationName=ID
		public Group getGroup() { return cGroup; }
		
		//DOC_ANNOTATION_PREFIX
		public RuleCall getDOC_ANNOTATION_PREFIXTerminalRuleCall_0() { return cDOC_ANNOTATION_PREFIXTerminalRuleCall_0; }
		
		//annotationName=ID
		public Assignment getAnnotationNameAssignment_1() { return cAnnotationNameAssignment_1; }
		
		//ID
		public RuleCall getAnnotationNameIDTerminalRuleCall_1_0() { return cAnnotationNameIDTerminalRuleCall_1_0; }
	}
	public class IndexSignatureElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.IndexSignature");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cIndexTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cIndexTypeIndexTypeEnumRuleCall_3_0 = (RuleCall)cIndexTypeAssignment_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cValueTypeAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cValueTypeTypeParserRuleCall_5_0 = (RuleCall)cValueTypeAssignment_5.eContents().get(0);
		
		//IndexSignature:
		//    '[' ID ':' indexType=IndexType ']' valueType=Type;
		@Override public ParserRule getRule() { return rule; }
		
		//'[' ID ':' indexType=IndexType ']' valueType=Type
		public Group getGroup() { return cGroup; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1() { return cIDTerminalRuleCall_1; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//indexType=IndexType
		public Assignment getIndexTypeAssignment_3() { return cIndexTypeAssignment_3; }
		
		//IndexType
		public RuleCall getIndexTypeIndexTypeEnumRuleCall_3_0() { return cIndexTypeIndexTypeEnumRuleCall_3_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
		
		//valueType=Type
		public Assignment getValueTypeAssignment_5() { return cValueTypeAssignment_5; }
		
		//Type
		public RuleCall getValueTypeTypeParserRuleCall_5_0() { return cValueTypeTypeParserRuleCall_5_0; }
	}
	
	public class PredefinedTypeEnumElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.PredefinedTypeEnum");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cAnyEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cAnyAnyKeyword_0_0 = (Keyword)cAnyEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNumberEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNumberNumberKeyword_1_0 = (Keyword)cNumberEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cBooleanEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cBooleanBooleanKeyword_2_0 = (Keyword)cBooleanEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cStringEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cStringStringKeyword_3_0 = (Keyword)cStringEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cVoidEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cVoidVoidKeyword_4_0 = (Keyword)cVoidEnumLiteralDeclaration_4.eContents().get(0);
		
		//enum PredefinedTypeEnum:
		//    any | number | boolean | string | void;
		public EnumRule getRule() { return rule; }
		
		//any | number | boolean | string | void
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//any
		public EnumLiteralDeclaration getAnyEnumLiteralDeclaration_0() { return cAnyEnumLiteralDeclaration_0; }
		
		public Keyword getAnyAnyKeyword_0_0() { return cAnyAnyKeyword_0_0; }
		
		//number
		public EnumLiteralDeclaration getNumberEnumLiteralDeclaration_1() { return cNumberEnumLiteralDeclaration_1; }
		
		public Keyword getNumberNumberKeyword_1_0() { return cNumberNumberKeyword_1_0; }
		
		//boolean
		public EnumLiteralDeclaration getBooleanEnumLiteralDeclaration_2() { return cBooleanEnumLiteralDeclaration_2; }
		
		public Keyword getBooleanBooleanKeyword_2_0() { return cBooleanBooleanKeyword_2_0; }
		
		//string
		public EnumLiteralDeclaration getStringEnumLiteralDeclaration_3() { return cStringEnumLiteralDeclaration_3; }
		
		public Keyword getStringStringKeyword_3_0() { return cStringStringKeyword_3_0; }
		
		//void
		public EnumLiteralDeclaration getVoidEnumLiteralDeclaration_4() { return cVoidEnumLiteralDeclaration_4; }
		
		public Keyword getVoidVoidKeyword_4_0() { return cVoidVoidKeyword_4_0; }
	}
	public class IndexTypeElements extends AbstractElementFinder.AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.IndexType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cNumberEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cNumberNumberKeyword_0_0 = (Keyword)cNumberEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cStringEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cStringStringKeyword_1_0 = (Keyword)cStringEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum IndexType:
		//      number | string;
		public EnumRule getRule() { return rule; }
		
		//number | string
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//number
		public EnumLiteralDeclaration getNumberEnumLiteralDeclaration_0() { return cNumberEnumLiteralDeclaration_0; }
		
		public Keyword getNumberNumberKeyword_0_0() { return cNumberNumberKeyword_0_0; }
		
		//string
		public EnumLiteralDeclaration getStringEnumLiteralDeclaration_1() { return cStringEnumLiteralDeclaration_1; }
		
		public Keyword getStringStringKeyword_1_0() { return cStringStringKeyword_1_0; }
	}
	
	private final TypescriptElements pTypescript;
	private final InterfacesAndClassesElements pInterfacesAndClasses;
	private final ImportDeclarationElements pImportDeclaration;
	private final ModuleDeclarationElements pModuleDeclaration;
	private final ModuleBodyElements pModuleBody;
	private final ModuleElementElements pModuleElement;
	private final DeclarationElements pDeclaration;
	private final InterfaceOrClassDeclarationElements pInterfaceOrClassDeclaration;
	private final InterfaceDeclarationElements pInterfaceDeclaration;
	private final ClassDeclarationElements pClassDeclaration;
	private final IdentifierElements pIdentifier;
	private final InterfaceExtendsClauseElements pInterfaceExtendsClause;
	private final ClassOrInterfaceTypeListElements pClassOrInterfaceTypeList;
	private final ObjectTypeElements pObjectType;
	private final TypeMemberElements pTypeMember;
	private final PropertySignatureElements pPropertySignature;
	private final IdentifierNameElements pIdentifierName;
	private final StringLiteralElements pStringLiteral;
	private final NumericLiteralElements pNumericLiteral;
	private final TypeElements pType;
	private final PredefinedTypeElements pPredefinedType;
	private final TypeLiteralElements pTypeLiteral;
	private final ArrayTypeElements pArrayType;
	private final TypeReferenceElements pTypeReference;
	private final QualifiedNameElements pQualifiedName;
	private final PredefinedTypeEnumElements ePredefinedTypeEnum;
	private final DocCommentElements pDocComment;
	private final AnnotationLineElements pAnnotationLine;
	private final IndexSignatureElements pIndexSignature;
	private final IndexTypeElements eIndexType;
	private final TerminalRule tDOC_COMMENT_END;
	private final TerminalRule tDOC_ANNOTATION_PREFIX;
	private final TerminalRule tDOC_COMMENT_LINE;
	private final TerminalRule tML_COMMENT;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public TypescriptGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pTypescript = new TypescriptElements();
		this.pInterfacesAndClasses = new InterfacesAndClassesElements();
		this.pImportDeclaration = new ImportDeclarationElements();
		this.pModuleDeclaration = new ModuleDeclarationElements();
		this.pModuleBody = new ModuleBodyElements();
		this.pModuleElement = new ModuleElementElements();
		this.pDeclaration = new DeclarationElements();
		this.pInterfaceOrClassDeclaration = new InterfaceOrClassDeclarationElements();
		this.pInterfaceDeclaration = new InterfaceDeclarationElements();
		this.pClassDeclaration = new ClassDeclarationElements();
		this.pIdentifier = new IdentifierElements();
		this.pInterfaceExtendsClause = new InterfaceExtendsClauseElements();
		this.pClassOrInterfaceTypeList = new ClassOrInterfaceTypeListElements();
		this.pObjectType = new ObjectTypeElements();
		this.pTypeMember = new TypeMemberElements();
		this.pPropertySignature = new PropertySignatureElements();
		this.pIdentifierName = new IdentifierNameElements();
		this.pStringLiteral = new StringLiteralElements();
		this.pNumericLiteral = new NumericLiteralElements();
		this.pType = new TypeElements();
		this.pPredefinedType = new PredefinedTypeElements();
		this.pTypeLiteral = new TypeLiteralElements();
		this.pArrayType = new ArrayTypeElements();
		this.pTypeReference = new TypeReferenceElements();
		this.pQualifiedName = new QualifiedNameElements();
		this.ePredefinedTypeEnum = new PredefinedTypeEnumElements();
		this.pDocComment = new DocCommentElements();
		this.pAnnotationLine = new AnnotationLineElements();
		this.pIndexSignature = new IndexSignatureElements();
		this.eIndexType = new IndexTypeElements();
		this.tDOC_COMMENT_END = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.DOC_COMMENT_END");
		this.tDOC_ANNOTATION_PREFIX = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.DOC_ANNOTATION_PREFIX");
		this.tDOC_COMMENT_LINE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.DOC_COMMENT_LINE");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "ch.vobos.Typescript.ML_COMMENT");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("ch.vobos.Typescript".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//// TODO complete this to be the full TS grammar...
	//// ... based on a full JS grammar.. looking at e.g. http://www.antlr3.org/grammar/1153976512034/ecmascriptA3.g for inspiration?
	//Typescript:
	//    imports+= ImportDeclaration*
	//    interfacesAndClasses=InterfacesAndClasses;
	public TypescriptElements getTypescriptAccess() {
		return pTypescript;
	}
	
	public ParserRule getTypescriptRule() {
		return getTypescriptAccess().getRule();
	}
	
	//InterfacesAndClasses: {InterfacesAndClasses}
	//    (modules+=ModuleDeclaration  | types+=Declaration)*;
	public InterfacesAndClassesElements getInterfacesAndClassesAccess() {
		return pInterfacesAndClasses;
	}
	
	public ParserRule getInterfacesAndClassesRule() {
		return getInterfacesAndClassesAccess().getRule();
	}
	
	//ImportDeclaration:
	//    "import" alias=Identifier "=" name=QualifiedName ;
	public ImportDeclarationElements getImportDeclarationAccess() {
		return pImportDeclaration;
	}
	
	public ParserRule getImportDeclarationRule() {
		return getImportDeclarationAccess().getRule();
	}
	
	//ModuleDeclaration:
	//    docComment=DocComment?  "module" name=Identifier ("." Identifier)*  "{" body=ModuleBody "}" ;
	public ModuleDeclarationElements getModuleDeclarationAccess() {
		return pModuleDeclaration;
	}
	
	public ParserRule getModuleDeclarationRule() {
		return getModuleDeclarationAccess().getRule();
	}
	
	//ModuleBody: {ModuleBody}
	//    elements+=ModuleElement*;
	public ModuleBodyElements getModuleBodyAccess() {
		return pModuleBody;
	}
	
	public ParserRule getModuleBodyRule() {
		return getModuleBodyAccess().getRule();
	}
	
	//ModuleElement:
	//        /*Statement |  */
	//     exported?="export"? moduleContent=( Declaration
	//     /* | EnumDeclaration |VariableDeclaration | FunctionDeclaration  */ | ModuleDeclaration | ImportDeclaration )
	//     ';'?;
	public ModuleElementElements getModuleElementAccess() {
		return pModuleElement;
	}
	
	public ParserRule getModuleElementRule() {
		return getModuleElementAccess().getRule();
	}
	
	//Declaration:
	//    docComment=DocComment? declaration=InterfaceOrClassDeclaration;
	public DeclarationElements getDeclarationAccess() {
		return pDeclaration;
	}
	
	public ParserRule getDeclarationRule() {
		return getDeclarationAccess().getRule();
	}
	
	//InterfaceOrClassDeclaration: (InterfaceDeclaration | ClassDeclaration) objectType=ObjectType;
	public InterfaceOrClassDeclarationElements getInterfaceOrClassDeclarationAccess() {
		return pInterfaceOrClassDeclaration;
	}
	
	public ParserRule getInterfaceOrClassDeclarationRule() {
		return getInterfaceOrClassDeclarationAccess().getRule();
	}
	
	//InterfaceDeclaration:
	//    "interface" name=Identifier /* TypeParameters? */ extendClause=InterfaceExtendsClause?;
	public InterfaceDeclarationElements getInterfaceDeclarationAccess() {
		return pInterfaceDeclaration;
	}
	
	public ParserRule getInterfaceDeclarationRule() {
		return getInterfaceDeclarationAccess().getRule();
	}
	
	//ClassDeclaration:
	//    "class" name=Identifier /* TypeParameter ClassHeritage */;
	public ClassDeclarationElements getClassDeclarationAccess() {
		return pClassDeclaration;
	}
	
	public ParserRule getClassDeclarationRule() {
		return getClassDeclarationAccess().getRule();
	}
	
	// // TODO: for now we treat interfaces and classes the same
	//Identifier:
	//    ID;
	public IdentifierElements getIdentifierAccess() {
		return pIdentifier;
	}
	
	public ParserRule getIdentifierRule() {
		return getIdentifierAccess().getRule();
	}
	
	//InterfaceExtendsClause:
	//    "extends" ClassOrInterfaceTypeList;
	public InterfaceExtendsClauseElements getInterfaceExtendsClauseAccess() {
		return pInterfaceExtendsClause;
	}
	
	public ParserRule getInterfaceExtendsClauseRule() {
		return getInterfaceExtendsClauseAccess().getRule();
	}
	
	//ClassOrInterfaceTypeList: { ClassOrInterfaceTypeList }
	//    parents += TypeReference (',' parents += TypeReference)*
	//;
	public ClassOrInterfaceTypeListElements getClassOrInterfaceTypeListAccess() {
		return pClassOrInterfaceTypeList;
	}
	
	public ParserRule getClassOrInterfaceTypeListRule() {
		return getClassOrInterfaceTypeListAccess().getRule();
	}
	
	//ObjectType: { ObjectType }
	//    "{" (members += TypeMember ';'?)* "}";
	public ObjectTypeElements getObjectTypeAccess() {
		return pObjectType;
	}
	
	public ParserRule getObjectTypeRule() {
		return getObjectTypeAccess().getRule();
	}
	
	//TypeMember:
	//    docComment = DocComment?
	//    signature = ( PropertySignature
	//    /*    | CallSignature
	//        | ConstructSignature */
	//        | IndexSignature
	//    /*  | MethodSignature */
	//    );
	public TypeMemberElements getTypeMemberAccess() {
		return pTypeMember;
	}
	
	public ParserRule getTypeMemberRule() {
		return getTypeMemberAccess().getRule();
	}
	
	//PropertySignature:
	//    name = IdentifierName // | StringLiteral | NumericLiteral
	//    optional ?= "?"?
	//    ":"
	//    type=Type;
	public PropertySignatureElements getPropertySignatureAccess() {
		return pPropertySignature;
	}
	
	public ParserRule getPropertySignatureRule() {
		return getPropertySignatureAccess().getRule();
	}
	
	//IdentifierName:
	//    ID;
	public IdentifierNameElements getIdentifierNameAccess() {
		return pIdentifierName;
	}
	
	public ParserRule getIdentifierNameRule() {
		return getIdentifierNameAccess().getRule();
	}
	
	//StringLiteral:
	//    STRING;
	public StringLiteralElements getStringLiteralAccess() {
		return pStringLiteral;
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}
	
	//NumericLiteral:
	//    INT // TODO valid NumericLiteral in http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
	//;
	public NumericLiteralElements getNumericLiteralAccess() {
		return pNumericLiteral;
	}
	
	public ParserRule getNumericLiteralRule() {
		return getNumericLiteralAccess().getRule();
	}
	
	//Type: PredefinedType | TypeReference | TypeLiteral;
	public TypeElements getTypeAccess() {
		return pType;
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}
	
	// // | TypeQuery
	//PredefinedType:
	//    predefinedType = PredefinedTypeEnum;
	public PredefinedTypeElements getPredefinedTypeAccess() {
		return pPredefinedType;
	}
	
	public ParserRule getPredefinedTypeRule() {
		return getPredefinedTypeAccess().getRule();
	}
	
	//TypeLiteral:
	//    ObjectType | ArrayType  /* | FunctionType | ConstructorType */ ;
	public TypeLiteralElements getTypeLiteralAccess() {
		return pTypeLiteral;
	}
	
	public ParserRule getTypeLiteralRule() {
		return getTypeLiteralAccess().getRule();
	}
	
	//ArrayType: {ArrayType}
	//    array = PredefinedType "[" "]" |  TypeReference "[" "]"
	//    /*ObjectType [ ]
	//    ArrayType [ ] */;
	public ArrayTypeElements getArrayTypeAccess() {
		return pArrayType;
	}
	
	public ParserRule getArrayTypeRule() {
		return getArrayTypeAccess().getRule();
	}
	
	//TypeReference:
	//    reference = [InterfaceOrClassDeclaration|QualifiedName];
	public TypeReferenceElements getTypeReferenceAccess() {
		return pTypeReference;
	}
	
	public ParserRule getTypeReferenceRule() {
		return getTypeReferenceAccess().getRule();
	}
	
	//QualifiedName:
	//    ID ('.' ID)* ;
	public QualifiedNameElements getQualifiedNameAccess() {
		return pQualifiedName;
	}
	
	public ParserRule getQualifiedNameRule() {
		return getQualifiedNameAccess().getRule();
	}
	
	//enum PredefinedTypeEnum:
	//    any | number | boolean | string | void;
	public PredefinedTypeEnumElements getPredefinedTypeEnumAccess() {
		return ePredefinedTypeEnum;
	}
	
	public EnumRule getPredefinedTypeEnumRule() {
		return getPredefinedTypeEnumAccess().getRule();
	}
	
	//DocComment: {DocComment}
	//    '/**' lines+=DOC_COMMENT_LINE* annotations+=AnnotationLine* DOC_COMMENT_END;
	public DocCommentElements getDocCommentAccess() {
		return pDocComment;
	}
	
	public ParserRule getDocCommentRule() {
		return getDocCommentAccess().getRule();
	}
	
	//AnnotationLine:
	//    DOC_ANNOTATION_PREFIX annotationName=ID;
	public AnnotationLineElements getAnnotationLineAccess() {
		return pAnnotationLine;
	}
	
	public ParserRule getAnnotationLineRule() {
		return getAnnotationLineAccess().getRule();
	}
	
	//IndexSignature:
	//    '[' ID ':' indexType=IndexType ']' valueType=Type;
	public IndexSignatureElements getIndexSignatureAccess() {
		return pIndexSignature;
	}
	
	public ParserRule getIndexSignatureRule() {
		return getIndexSignatureAccess().getRule();
	}
	
	//enum IndexType:
	//      number | string;
	public IndexTypeElements getIndexTypeAccess() {
		return eIndexType;
	}
	
	public EnumRule getIndexTypeRule() {
		return getIndexTypeAccess().getRule();
	}
	
	//terminal DOC_COMMENT_END: (' '|'\t')* '*' '/';
	public TerminalRule getDOC_COMMENT_ENDRule() {
		return tDOC_COMMENT_END;
	}
	
	//terminal DOC_ANNOTATION_PREFIX: (' '|'\t')* '* @';
	public TerminalRule getDOC_ANNOTATION_PREFIXRule() {
		return tDOC_ANNOTATION_PREFIX;
	}
	
	//terminal DOC_COMMENT_LINE : (' '|'\t')* '*'!'/' !'@' -> ('\r'? '\n');
	public TerminalRule getDOC_COMMENT_LINERule() {
		return tDOC_COMMENT_LINE;
	}
	
	//terminal ML_COMMENT : '/*'!'*' -> '*/';
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	}
	
	//terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt: ('0'..'9')+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//            '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
	//            "'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
	//        ;
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS         : (' '|'\t'|'\r'|'\n')+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER: .;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}

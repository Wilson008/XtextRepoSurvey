/*
 * generated by Xtext 2.35.0
 */
package de.sebastianbenz.xgherkin.serializer;

import com.google.inject.Inject;
import de.sebastianbenz.xgherkin.gherkin.AndStep;
import de.sebastianbenz.xgherkin.gherkin.AsA;
import de.sebastianbenz.xgherkin.gherkin.Background;
import de.sebastianbenz.xgherkin.gherkin.Example;
import de.sebastianbenz.xgherkin.gherkin.ExampleCell;
import de.sebastianbenz.xgherkin.gherkin.ExampleRow;
import de.sebastianbenz.xgherkin.gherkin.Feature;
import de.sebastianbenz.xgherkin.gherkin.FreeText;
import de.sebastianbenz.xgherkin.gherkin.GherkinPackage;
import de.sebastianbenz.xgherkin.gherkin.GivenStep;
import de.sebastianbenz.xgherkin.gherkin.IWantTo;
import de.sebastianbenz.xgherkin.gherkin.InOrderTo;
import de.sebastianbenz.xgherkin.gherkin.Scenario;
import de.sebastianbenz.xgherkin.gherkin.ScenarioWithOutline;
import de.sebastianbenz.xgherkin.gherkin.ThenStep;
import de.sebastianbenz.xgherkin.gherkin.WhenStep;
import de.sebastianbenz.xgherkin.services.GherkinGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class GherkinSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GherkinGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GherkinPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GherkinPackage.AND_STEP:
				sequence_AndStep(context, (AndStep) semanticObject); 
				return; 
			case GherkinPackage.AS_A:
				sequence_AsA(context, (AsA) semanticObject); 
				return; 
			case GherkinPackage.BACKGROUND:
				sequence_Background(context, (Background) semanticObject); 
				return; 
			case GherkinPackage.EXAMPLE:
				sequence_Example(context, (Example) semanticObject); 
				return; 
			case GherkinPackage.EXAMPLE_CELL:
				sequence_ExampleCell(context, (ExampleCell) semanticObject); 
				return; 
			case GherkinPackage.EXAMPLE_ROW:
				sequence_ExampleRow(context, (ExampleRow) semanticObject); 
				return; 
			case GherkinPackage.FEATURE:
				sequence_Feature(context, (Feature) semanticObject); 
				return; 
			case GherkinPackage.FREE_TEXT:
				sequence_FreeText(context, (FreeText) semanticObject); 
				return; 
			case GherkinPackage.GIVEN_STEP:
				sequence_GivenStep(context, (GivenStep) semanticObject); 
				return; 
			case GherkinPackage.IWANT_TO:
				sequence_IWantTo(context, (IWantTo) semanticObject); 
				return; 
			case GherkinPackage.IN_ORDER_TO:
				sequence_InOrderTo(context, (InOrderTo) semanticObject); 
				return; 
			case GherkinPackage.SCENARIO:
				sequence_Scenario(context, (Scenario) semanticObject); 
				return; 
			case GherkinPackage.SCENARIO_WITH_OUTLINE:
				sequence_ScenarioWithOutline(context, (ScenarioWithOutline) semanticObject); 
				return; 
			case GherkinPackage.THEN_STEP:
				sequence_ThenStep(context, (ThenStep) semanticObject); 
				return; 
			case GherkinPackage.WHEN_STEP:
				sequence_WhenStep(context, (WhenStep) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns AndStep
	 *     AndStep returns AndStep
	 *
	 * Constraint:
	 *     (desc+=AND_TEXT desc+=OptionalText* rows+=ExampleRow*)
	 * </pre>
	 */
	protected void sequence_AndStep(ISerializationContext context, AndStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NarrativeElement returns AsA
	 *     AsA returns AsA
	 *
	 * Constraint:
	 *     name=AS_A
	 * </pre>
	 */
	protected void sequence_AsA(ISerializationContext context, AsA semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GherkinPackage.Literals.NARRATIVE_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GherkinPackage.Literals.NARRATIVE_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAsAAccess().getNameAS_ATerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractScenario returns Background
	 *     Background returns Background
	 *
	 * Constraint:
	 *     (tags+=TAG* name=BACKGROUND_TEXT steps+=Step*)
	 * </pre>
	 */
	protected void sequence_Background(ISerializationContext context, Background semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExampleCell returns ExampleCell
	 *
	 * Constraint:
	 *     value=EXAMPLE_CELL
	 * </pre>
	 */
	protected void sequence_ExampleCell(ISerializationContext context, ExampleCell semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GherkinPackage.Literals.EXAMPLE_CELL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GherkinPackage.Literals.EXAMPLE_CELL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExampleCellAccess().getValueEXAMPLE_CELLTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExampleRow returns ExampleRow
	 *
	 * Constraint:
	 *     cells+=ExampleCell+
	 * </pre>
	 */
	protected void sequence_ExampleRow(ISerializationContext context, ExampleRow semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Example returns Example
	 *
	 * Constraint:
	 *     (heading=ExampleRow rows+=ExampleRow*)
	 * </pre>
	 */
	protected void sequence_Example(ISerializationContext context, Example semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Feature returns Feature
	 *
	 * Constraint:
	 *     (
	 *         (tags+=TAG+ ((name=FEATURE_TEXT scenarios+=AbstractScenario+) | scenarios+=AbstractScenario+)) | 
	 *         (((tags+=TAG+ name=FEATURE_TEXT) | name=FEATURE_TEXT)? elements+=NarrativeElement+ scenarios+=AbstractScenario+) | 
	 *         (name=FEATURE_TEXT scenarios+=AbstractScenario+) | 
	 *         scenarios+=AbstractScenario+
	 *     )?
	 * </pre>
	 */
	protected void sequence_Feature(ISerializationContext context, Feature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NarrativeElement returns FreeText
	 *     FreeText returns FreeText
	 *
	 * Constraint:
	 *     name=TEXT
	 * </pre>
	 */
	protected void sequence_FreeText(ISerializationContext context, FreeText semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GherkinPackage.Literals.NARRATIVE_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GherkinPackage.Literals.NARRATIVE_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFreeTextAccess().getNameTEXTTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns GivenStep
	 *     GivenStep returns GivenStep
	 *
	 * Constraint:
	 *     (tags+=TAG* desc+=GIVEN_TEXT desc+=OptionalText* rows+=ExampleRow*)
	 * </pre>
	 */
	protected void sequence_GivenStep(ISerializationContext context, GivenStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NarrativeElement returns IWantTo
	 *     IWantTo returns IWantTo
	 *
	 * Constraint:
	 *     name=I_WANT_TO
	 * </pre>
	 */
	protected void sequence_IWantTo(ISerializationContext context, IWantTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GherkinPackage.Literals.NARRATIVE_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GherkinPackage.Literals.NARRATIVE_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIWantToAccess().getNameI_WANT_TOTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NarrativeElement returns InOrderTo
	 *     InOrderTo returns InOrderTo
	 *
	 * Constraint:
	 *     name=IN_ORDER_TO
	 * </pre>
	 */
	protected void sequence_InOrderTo(ISerializationContext context, InOrderTo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GherkinPackage.Literals.NARRATIVE_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GherkinPackage.Literals.NARRATIVE_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInOrderToAccess().getNameIN_ORDER_TOTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractScenario returns ScenarioWithOutline
	 *     ScenarioWithOutline returns ScenarioWithOutline
	 *
	 * Constraint:
	 *     (tags+=TAG* name=SCENARIO_OUTLINE_TEXT elements+=NarrativeElement* steps+=Step+ example=Example)
	 * </pre>
	 */
	protected void sequence_ScenarioWithOutline(ISerializationContext context, ScenarioWithOutline semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractScenario returns Scenario
	 *     Scenario returns Scenario
	 *
	 * Constraint:
	 *     (tags+=TAG* name=SCENARIO_TEXT elements+=NarrativeElement* steps+=Step+)
	 * </pre>
	 */
	protected void sequence_Scenario(ISerializationContext context, Scenario semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns ThenStep
	 *     ThenStep returns ThenStep
	 *
	 * Constraint:
	 *     (tags+=TAG* desc+=THEN_TEXT desc+=OptionalText* rows+=ExampleRow*)
	 * </pre>
	 */
	protected void sequence_ThenStep(ISerializationContext context, ThenStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Step returns WhenStep
	 *     WhenStep returns WhenStep
	 *
	 * Constraint:
	 *     (tags+=TAG* desc+=WHEN_TEXT desc+=OptionalText* rows+=ExampleRow*)
	 * </pre>
	 */
	protected void sequence_WhenStep(ISerializationContext context, WhenStep semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}

/*
 * generated by Xtext 2.35.0
 */
package hu.sze.aut.ros.middleware.statepubsub.serializer;

import com.google.inject.Inject;
import hu.sze.aut.ros.middleware.statepubsub.services.RosNetworkDslGrammarAccess;
import hu.sze.jkk.middleware.statepubsub.model.statepubsubmodel.BooleanParameter;
import hu.sze.jkk.middleware.statepubsub.model.statepubsubmodel.ContinousState;
import hu.sze.jkk.middleware.statepubsub.model.statepubsubmodel.DoubleParameter;
import hu.sze.jkk.middleware.statepubsub.model.statepubsubmodel.FilePackage;
import hu.sze.jkk.middleware.statepubsub.model.statepubsubmodel.FilterConnection;
import hu.sze.jkk.middleware.statepubsub.model.statepubsubmodel.FilterDefinition;
import hu.sze.jkk.middleware.statepubsub.model.statepubsubmodel.InputPort;
import hu.sze.jkk.middleware.statepubsub.model.statepubsubmodel.IntegerParameter;
import hu.sze.jkk.middleware.statepubsub.model.statepubsubmodel.Node;
import hu.sze.jkk.middleware.statepubsub.model.statepubsubmodel.NodeParameterGroup;
import hu.sze.jkk.middleware.statepubsub.model.statepubsubmodel.OutputPort;
import hu.sze.jkk.middleware.statepubsub.model.statepubsubmodel.SerializedField;
import hu.sze.jkk.middleware.statepubsub.model.statepubsubmodel.Service;
import hu.sze.jkk.middleware.statepubsub.model.statepubsubmodel.ServiceType;
import hu.sze.jkk.middleware.statepubsub.model.statepubsubmodel.Stack;
import hu.sze.jkk.middleware.statepubsub.model.statepubsubmodel.StatepubsubmodelPackage;
import hu.sze.jkk.middleware.statepubsub.model.statepubsubmodel.TemplateNode;
import hu.sze.jkk.middleware.statepubsub.model.statepubsubmodel.Topic;
import hu.sze.jkk.middleware.statepubsub.model.statepubsubmodel.TopicMessage;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractRosNetworkDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private RosNetworkDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == StatepubsubmodelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case StatepubsubmodelPackage.BOOLEAN_PARAMETER:
				sequence_BooleanParameter(context, (BooleanParameter) semanticObject); 
				return; 
			case StatepubsubmodelPackage.CONTINOUS_STATE:
				sequence_ContinuousState(context, (ContinousState) semanticObject); 
				return; 
			case StatepubsubmodelPackage.DOUBLE_PARAMETER:
				sequence_DoubleParameter(context, (DoubleParameter) semanticObject); 
				return; 
			case StatepubsubmodelPackage.FILE_PACKAGE:
				sequence_FilePackage(context, (FilePackage) semanticObject); 
				return; 
			case StatepubsubmodelPackage.FILTER_CONNECTION:
				sequence_FilterConnection(context, (FilterConnection) semanticObject); 
				return; 
			case StatepubsubmodelPackage.FILTER_DEFINITION:
				sequence_FilterDefinition(context, (FilterDefinition) semanticObject); 
				return; 
			case StatepubsubmodelPackage.INPUT_PORT:
				sequence_InputPort(context, (InputPort) semanticObject); 
				return; 
			case StatepubsubmodelPackage.INTEGER_PARAMETER:
				sequence_IntegerParameter(context, (IntegerParameter) semanticObject); 
				return; 
			case StatepubsubmodelPackage.NODE:
				sequence_Node(context, (Node) semanticObject); 
				return; 
			case StatepubsubmodelPackage.NODE_PARAMETER_GROUP:
				sequence_NodeParameterGroup(context, (NodeParameterGroup) semanticObject); 
				return; 
			case StatepubsubmodelPackage.OUTPUT_PORT:
				sequence_OutputPort(context, (OutputPort) semanticObject); 
				return; 
			case StatepubsubmodelPackage.SERIALIZED_FIELD:
				sequence_SerializedField(context, (SerializedField) semanticObject); 
				return; 
			case StatepubsubmodelPackage.SERVICE:
				sequence_Service(context, (Service) semanticObject); 
				return; 
			case StatepubsubmodelPackage.SERVICE_TYPE:
				sequence_ServiceType(context, (ServiceType) semanticObject); 
				return; 
			case StatepubsubmodelPackage.STACK:
				sequence_MiddleWareNetwork(context, (Stack) semanticObject); 
				return; 
			case StatepubsubmodelPackage.TEMPLATE_NODE:
				sequence_Library(context, (TemplateNode) semanticObject); 
				return; 
			case StatepubsubmodelPackage.TOPIC:
				sequence_Topic(context, (Topic) semanticObject); 
				return; 
			case StatepubsubmodelPackage.TOPIC_MESSAGE:
				sequence_TopicMessage(context, (TopicMessage) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     NodeParameter returns BooleanParameter
	 *     BooleanParameter returns BooleanParameter
	 *     AbstractNodeParameter returns BooleanParameter
	 *
	 * Constraint:
	 *     (name=EString defaultval=EBoolean targetvar=EString?)
	 * </pre>
	 */
	protected void sequence_BooleanParameter(ISerializationContext context, BooleanParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ContinuousState returns ContinousState
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_ContinuousState(ISerializationContext context, ContinousState semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatepubsubmodelPackage.Literals.INTERNAL_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatepubsubmodelPackage.Literals.INTERNAL_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContinuousStateAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NodeParameter returns DoubleParameter
	 *     DoubleParameter returns DoubleParameter
	 *     AbstractNodeParameter returns DoubleParameter
	 *
	 * Constraint:
	 *     (name=EString defaultval=Double minval=Double maxval=Double targetvar=EString?)
	 * </pre>
	 */
	protected void sequence_DoubleParameter(ISerializationContext context, DoubleParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FilePackage returns FilePackage
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         generateartifact?='generate'? 
	 *         abstractroselement+=AbstractRosFileElement 
	 *         abstractroselement+=AbstractRosFileElement* 
	 *         (filter+=FilterDefinition filter+=FilterDefinition*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_FilePackage(ISerializationContext context, FilePackage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FilterConnection returns FilterConnection
	 *
	 * Constraint:
	 *     (name=EString usedfilter=[FilterDefinition|EString] input+=[InternalNode|EString] input+=[InternalNode|EString]* output=[InternalNode|EString])
	 * </pre>
	 */
	protected void sequence_FilterConnection(ISerializationContext context, FilterConnection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FilterDefinition returns FilterDefinition
	 *
	 * Constraint:
	 *     (name=EString input_field+=SerializedField input_field+=SerializedField* output_field=SerializedField)
	 * </pre>
	 */
	protected void sequence_FilterDefinition(ISerializationContext context, FilterDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Port returns InputPort
	 *     InputPort returns InputPort
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         channel=[Channel|EString] 
	 *         (estimated_freq=EInt sample_tolerance=Double debug?='debug'?)? 
	 *         synchronizesState=[ContinousState|EString]?
	 *     )
	 * </pre>
	 */
	protected void sequence_InputPort(ISerializationContext context, InputPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NodeParameter returns IntegerParameter
	 *     IntegerParameter returns IntegerParameter
	 *     AbstractNodeParameter returns IntegerParameter
	 *
	 * Constraint:
	 *     (name=EString defaultval=EInt minval=EInt maxval=EInt targetvar=EString?)
	 * </pre>
	 */
	protected void sequence_IntegerParameter(ISerializationContext context, IntegerParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RosRuntimeElement returns TemplateNode
	 *     Library returns TemplateNode
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         namespace=EString 
	 *         implements=[Node|EString]? 
	 *         generateartifact?='generate'? 
	 *         language+=LanguageType 
	 *         language+=LanguageType* 
	 *         (nodeparameters+=AbstractNodeParameter nodeparameters+=AbstractNodeParameter*)? 
	 *         continousstate+=ContinuousState? 
	 *         (port+=Port port+=Port*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Library(ISerializationContext context, TemplateNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     MiddleWareNetwork returns Stack
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         networktype+=NetworkType 
	 *         networktype+=NetworkType* 
	 *         filepackage+=FilePackage 
	 *         filepackage+=FilePackage* 
	 *         (channels+=Channel channels+=Channel*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_MiddleWareNetwork(ISerializationContext context, Stack semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NodeParameterGroup returns NodeParameterGroup
	 *     AbstractNodeParameter returns NodeParameterGroup
	 *
	 * Constraint:
	 *     (name=EString config_obj=EString? generate_struct=EBoolean? nodeparameter+=NodeParameter nodeparameter+=NodeParameter*)
	 * </pre>
	 */
	protected void sequence_NodeParameterGroup(ISerializationContext context, NodeParameterGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractRosFileElement returns Node
	 *     RosRuntimeElement returns Node
	 *     Node returns Node
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         namespace=EString 
	 *         implements=[Node|EString]? 
	 *         generateartifact?='generate'? 
	 *         language+=LanguageType 
	 *         language+=LanguageType* 
	 *         (nodeparameters+=AbstractNodeParameter nodeparameters+=AbstractNodeParameter*)? 
	 *         continousstate+=ContinuousState? 
	 *         (port+=Port port+=Port*)? 
	 *         (filterconnection+=FilterConnection filterconnection+=FilterConnection*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_Node(ISerializationContext context, Node semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Port returns OutputPort
	 *     OutputPort returns OutputPort
	 *
	 * Constraint:
	 *     (name=EString channel=[Channel|EString] estimated_freq=EInt debug?='debug'?)
	 * </pre>
	 */
	protected void sequence_OutputPort(ISerializationContext context, OutputPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SerializedField returns SerializedField
	 *
	 * Constraint:
	 *     (id=EString topicmessage=[TopicMessage|EString])
	 * </pre>
	 */
	protected void sequence_SerializedField(ISerializationContext context, SerializedField semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatepubsubmodelPackage.Literals.SERIALIZED_FIELD__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatepubsubmodelPackage.Literals.SERIALIZED_FIELD__ID));
			if (transientValues.isValueTransient(semanticObject, StatepubsubmodelPackage.Literals.SERIALIZED_FIELD__TOPICMESSAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatepubsubmodelPackage.Literals.SERIALIZED_FIELD__TOPICMESSAGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSerializedFieldAccess().getIdEStringParserRuleCall_2_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getSerializedFieldAccess().getTopicmessageTopicMessageEStringParserRuleCall_3_0_1(), semanticObject.eGet(StatepubsubmodelPackage.Literals.SERIALIZED_FIELD__TOPICMESSAGE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractRosFileElement returns ServiceType
	 *     AbstractMessageType returns ServiceType
	 *     ServiceType returns ServiceType
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_ServiceType(ISerializationContext context, ServiceType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatepubsubmodelPackage.Literals.ROS_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatepubsubmodelPackage.Literals.ROS_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getServiceTypeAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Channel returns Service
	 *     Service returns Service
	 *
	 * Constraint:
	 *     (name=EString type=[ServiceType|EString])
	 * </pre>
	 */
	protected void sequence_Service(ISerializationContext context, Service semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatepubsubmodelPackage.Literals.CHANNEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatepubsubmodelPackage.Literals.CHANNEL__NAME));
			if (transientValues.isValueTransient(semanticObject, StatepubsubmodelPackage.Literals.SERVICE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatepubsubmodelPackage.Literals.SERVICE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getServiceAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getServiceAccess().getTypeServiceTypeEStringParserRuleCall_4_0_1(), semanticObject.eGet(StatepubsubmodelPackage.Literals.SERVICE__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AbstractRosFileElement returns TopicMessage
	 *     AbstractMessageType returns TopicMessage
	 *     TopicMessage returns TopicMessage
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_TopicMessage(ISerializationContext context, TopicMessage semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatepubsubmodelPackage.Literals.ROS_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatepubsubmodelPackage.Literals.ROS_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTopicMessageAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Channel returns Topic
	 *     Topic returns Topic
	 *
	 * Constraint:
	 *     (name=EString type=[TopicMessage|EString])
	 * </pre>
	 */
	protected void sequence_Topic(ISerializationContext context, Topic semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatepubsubmodelPackage.Literals.CHANNEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatepubsubmodelPackage.Literals.CHANNEL__NAME));
			if (transientValues.isValueTransient(semanticObject, StatepubsubmodelPackage.Literals.TOPIC__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatepubsubmodelPackage.Literals.TOPIC__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTopicAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTopicAccess().getTypeTopicMessageEStringParserRuleCall_4_0_1(), semanticObject.eGet(StatepubsubmodelPackage.Literals.TOPIC__TYPE, false));
		feeder.finish();
	}
	
	
}

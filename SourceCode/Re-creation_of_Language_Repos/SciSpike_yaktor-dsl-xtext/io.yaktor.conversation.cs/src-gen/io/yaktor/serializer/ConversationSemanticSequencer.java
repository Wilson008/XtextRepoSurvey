/*
 * generated by Xtext 2.35.0
 */
package io.yaktor.serializer;

import com.google.inject.Inject;
import io.yaktor.access.AccessGroup;
import io.yaktor.access.AccessPackage;
import io.yaktor.access.RestService;
import io.yaktor.access.Service;
import io.yaktor.access.ServiceMethod;
import io.yaktor.access.View;
import io.yaktor.conversation.Agent;
import io.yaktor.conversation.AgentImport;
import io.yaktor.conversation.Conversation;
import io.yaktor.conversation.ConversationPackage;
import io.yaktor.conversation.Decision;
import io.yaktor.conversation.Join;
import io.yaktor.conversation.Junction;
import io.yaktor.conversation.PrivatePubSub;
import io.yaktor.conversation.PublicPubSub;
import io.yaktor.conversation.PubliclySubscribable;
import io.yaktor.conversation.State;
import io.yaktor.conversation.StateMachine;
import io.yaktor.conversation.Transition;
import io.yaktor.conversation.TypeImport;
import io.yaktor.domain.AmountField;
import io.yaktor.domain.AnyField;
import io.yaktor.domain.Association;
import io.yaktor.domain.AssociationEnd;
import io.yaktor.domain.AssociationRef;
import io.yaktor.domain.BooleanField;
import io.yaktor.domain.CountField;
import io.yaktor.domain.DateField;
import io.yaktor.domain.DomainModel;
import io.yaktor.domain.DomainModelImport;
import io.yaktor.domain.DomainPackage;
import io.yaktor.domain.Entity;
import io.yaktor.domain.EntityReferenceField;
import io.yaktor.domain.EnumField;
import io.yaktor.domain.EnumType;
import io.yaktor.domain.EnumValue;
import io.yaktor.domain.GenerationInclusion;
import io.yaktor.domain.GeoLocationField;
import io.yaktor.domain.IdField;
import io.yaktor.domain.IndexConstraint;
import io.yaktor.domain.IntegerField;
import io.yaktor.domain.JpaGenOptions;
import io.yaktor.domain.JpaTableOptions;
import io.yaktor.domain.MongoNodeGenOptions;
import io.yaktor.domain.MongoNodeTableOptions;
import io.yaktor.domain.NumericField;
import io.yaktor.domain.PersistenceOptions;
import io.yaktor.domain.PriceField;
import io.yaktor.domain.ProjectOptions;
import io.yaktor.domain.ShortIdField;
import io.yaktor.domain.StringField;
import io.yaktor.domain.Type;
import io.yaktor.domain.TypeField;
import io.yaktor.domain.UniqueConstraint;
import io.yaktor.mongoNode.MongoNodePackage;
import io.yaktor.mongoNode.Ttl;
import io.yaktor.services.ConversationGrammarAccess;
import io.yaktor.types.MappedField;
import io.yaktor.types.NewField;
import io.yaktor.types.Projection;
import io.yaktor.types.ProjectionContainmentField;
import io.yaktor.types.TypeContainmentField;
import io.yaktor.types.TypesPackage;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ConversationSemanticSequencer extends DomainSemanticSequencer {

	@Inject
	private ConversationGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AccessPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AccessPackage.ACCESS_GROUP:
				sequence_AccessGroup(context, (AccessGroup) semanticObject); 
				return; 
			case AccessPackage.REST_SERVICE:
				sequence_RestService(context, (RestService) semanticObject); 
				return; 
			case AccessPackage.SERVICE:
				sequence_Service(context, (Service) semanticObject); 
				return; 
			case AccessPackage.SERVICE_METHOD:
				sequence_ServiceMethod(context, (ServiceMethod) semanticObject); 
				return; 
			case AccessPackage.VIEW:
				sequence_View(context, (View) semanticObject); 
				return; 
			}
		else if (epackage == ConversationPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ConversationPackage.AGENT:
				sequence_Agent(context, (Agent) semanticObject); 
				return; 
			case ConversationPackage.AGENT_IMPORT:
				sequence_AgentImport(context, (AgentImport) semanticObject); 
				return; 
			case ConversationPackage.CONVERSATION:
				sequence_Conversation(context, (Conversation) semanticObject); 
				return; 
			case ConversationPackage.DECISION:
				sequence_Decision(context, (Decision) semanticObject); 
				return; 
			case ConversationPackage.JOIN:
				sequence_Join(context, (Join) semanticObject); 
				return; 
			case ConversationPackage.JUNCTION:
				sequence_Junction(context, (Junction) semanticObject); 
				return; 
			case ConversationPackage.PRIVATE_PUB_SUB:
				sequence_PrivatePubSub(context, (PrivatePubSub) semanticObject); 
				return; 
			case ConversationPackage.PUBLIC_PUB_SUB:
				if (rule == grammarAccess.getInitialPublicPubSubRule()) {
					sequence_InitialPublicPubSub(context, (PublicPubSub) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSubsequentPublicPubSubRule()) {
					sequence_SubsequentPublicPubSub(context, (PublicPubSub) semanticObject); 
					return; 
				}
				else break;
			case ConversationPackage.PUBLICLY_SUBSCRIBABLE:
				if (rule == grammarAccess.getInitialPubliclySubscribableRule()) {
					sequence_InitialPubliclySubscribable(context, (PubliclySubscribable) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSubsequentPubliclySubscribableRule()) {
					sequence_SubsequentPubliclySubscribable(context, (PubliclySubscribable) semanticObject); 
					return; 
				}
				else break;
			case ConversationPackage.STATE:
				sequence_State(context, (State) semanticObject); 
				return; 
			case ConversationPackage.STATE_MACHINE:
				sequence_StateMachine(context, (StateMachine) semanticObject); 
				return; 
			case ConversationPackage.TRANSITION:
				if (rule == grammarAccess.getInternalTransitionRule()) {
					sequence_InternalTransition(context, (Transition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTransitionRule()) {
					sequence_Transition(context, (Transition) semanticObject); 
					return; 
				}
				else break;
			case ConversationPackage.TYPE_IMPORT:
				sequence_TypeImport(context, (TypeImport) semanticObject); 
				return; 
			}
		else if (epackage == DomainPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DomainPackage.AMOUNT_FIELD:
				sequence_AmountField(context, (AmountField) semanticObject); 
				return; 
			case DomainPackage.ANY_FIELD:
				sequence_AnyField(context, (AnyField) semanticObject); 
				return; 
			case DomainPackage.ASSOCIATION:
				sequence_Association(context, (Association) semanticObject); 
				return; 
			case DomainPackage.ASSOCIATION_END:
				sequence_AssociationEnd(context, (AssociationEnd) semanticObject); 
				return; 
			case DomainPackage.ASSOCIATION_REF:
				sequence_AssociationRef(context, (AssociationRef) semanticObject); 
				return; 
			case DomainPackage.BOOLEAN_FIELD:
				sequence_BooleanField(context, (BooleanField) semanticObject); 
				return; 
			case DomainPackage.COUNT_FIELD:
				sequence_CountField(context, (CountField) semanticObject); 
				return; 
			case DomainPackage.DATE_FIELD:
				sequence_DateField(context, (DateField) semanticObject); 
				return; 
			case DomainPackage.DOMAIN_MODEL:
				sequence_DomainModel(context, (DomainModel) semanticObject); 
				return; 
			case DomainPackage.DOMAIN_MODEL_IMPORT:
				sequence_DomainModelImport(context, (DomainModelImport) semanticObject); 
				return; 
			case DomainPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case DomainPackage.ENTITY_REFERENCE_FIELD:
				sequence_EntityReferenceField(context, (EntityReferenceField) semanticObject); 
				return; 
			case DomainPackage.ENUM_FIELD:
				sequence_EnumField(context, (EnumField) semanticObject); 
				return; 
			case DomainPackage.ENUM_TYPE:
				sequence_EnumType(context, (EnumType) semanticObject); 
				return; 
			case DomainPackage.ENUM_VALUE:
				sequence_EnumValue(context, (EnumValue) semanticObject); 
				return; 
			case DomainPackage.GENERATION_INCLUSION:
				sequence_GenerationInclusion(context, (GenerationInclusion) semanticObject); 
				return; 
			case DomainPackage.GEO_LOCATION_FIELD:
				sequence_GeoLocationField(context, (GeoLocationField) semanticObject); 
				return; 
			case DomainPackage.ID_FIELD:
				sequence_IdField(context, (IdField) semanticObject); 
				return; 
			case DomainPackage.INDEX_CONSTRAINT:
				sequence_IndexConstraint(context, (IndexConstraint) semanticObject); 
				return; 
			case DomainPackage.INTEGER_FIELD:
				sequence_IntegerField(context, (IntegerField) semanticObject); 
				return; 
			case DomainPackage.JPA_GEN_OPTIONS:
				sequence_JpaGenOptions(context, (JpaGenOptions) semanticObject); 
				return; 
			case DomainPackage.JPA_TABLE_OPTIONS:
				sequence_JpaTableOptions(context, (JpaTableOptions) semanticObject); 
				return; 
			case DomainPackage.MONGO_NODE_GEN_OPTIONS:
				sequence_MongoNodeGenOptions(context, (MongoNodeGenOptions) semanticObject); 
				return; 
			case DomainPackage.MONGO_NODE_TABLE_OPTIONS:
				sequence_MongoNodeTableOptions(context, (MongoNodeTableOptions) semanticObject); 
				return; 
			case DomainPackage.NUMERIC_FIELD:
				sequence_NumericField(context, (NumericField) semanticObject); 
				return; 
			case DomainPackage.PERSISTENCE_OPTIONS:
				sequence_PersistenceOptions(context, (PersistenceOptions) semanticObject); 
				return; 
			case DomainPackage.PRICE_FIELD:
				sequence_PriceField(context, (PriceField) semanticObject); 
				return; 
			case DomainPackage.PROJECT_OPTIONS:
				sequence_ProjectOptions(context, (ProjectOptions) semanticObject); 
				return; 
			case DomainPackage.SHORT_ID_FIELD:
				sequence_ShortIdField(context, (ShortIdField) semanticObject); 
				return; 
			case DomainPackage.STRING_FIELD:
				sequence_StringField(context, (StringField) semanticObject); 
				return; 
			case DomainPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case DomainPackage.TYPE_FIELD:
				sequence_TypeField(context, (TypeField) semanticObject); 
				return; 
			case DomainPackage.UNIQUE_CONSTRAINT:
				sequence_UniqueConstraint(context, (UniqueConstraint) semanticObject); 
				return; 
			}
		else if (epackage == MongoNodePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MongoNodePackage.TTL:
				sequence_Ttl(context, (Ttl) semanticObject); 
				return; 
			}
		else if (epackage == TypesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TypesPackage.MAPPED_FIELD:
				sequence_MappedField(context, (MappedField) semanticObject); 
				return; 
			case TypesPackage.NEW_FIELD:
				sequence_NewField(context, (NewField) semanticObject); 
				return; 
			case TypesPackage.PROJECTION:
				if (rule == grammarAccess.getNestedProjectionRule()) {
					sequence_NestedProjection(context, (Projection) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTopLevelProjectionRule()) {
					sequence_TopLevelProjection(context, (Projection) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.PROJECTION_CONTAINMENT_FIELD:
				sequence_ProjectionContainmentField(context, (ProjectionContainmentField) semanticObject); 
				return; 
			case TypesPackage.TYPE_CONTAINMENT_FIELD:
				sequence_TypeContainmentField(context, (TypeContainmentField) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     AccessGroup returns AccessGroup
	 *
	 * Constraint:
	 *     (accessRequirement=AccessRequirement? accessMethods+=RestAccess+)
	 * </pre>
	 */
	protected void sequence_AccessGroup(ISerializationContext context, AccessGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AgentImport returns AgentImport
	 *
	 * Constraint:
	 *     (agent=[Agent|QualifiedName] alias=ID?)
	 * </pre>
	 */
	protected void sequence_AgentImport(ISerializationContext context, AgentImport semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Agent returns Agent
	 *
	 * Constraint:
	 *     (
	 *         stateMachineType=StateMachineType? 
	 *         accessRequirement=AccessRequirement? 
	 *         name=ID 
	 *         projection=[Projection|PossiblyQualifiedName] 
	 *         (sendables+=InitialPubliclySubscribable sendables+=SubsequentPubliclySubscribable*)? 
	 *         (sendables+=InitialPublicPubSub sendables+=SubsequentPublicPubSub*)? 
	 *         stateMachine=StateMachine
	 *     )
	 * </pre>
	 */
	protected void sequence_Agent(ISerializationContext context, Agent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Conversation returns Conversation
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (importedAgents+=AgentImport | importedTypes+=TypeImport)* 
	 *         agents+=Agent? 
	 *         ((views+=View | restServices+=RestService | definedTypes+=TopLevelProjection | services+=Service)? agents+=Agent?)*
	 *     )
	 * </pre>
	 */
	protected void sequence_Conversation(ISerializationContext context, Conversation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StateLike returns Decision
	 *     Decision returns Decision
	 *
	 * Constraint:
	 *     (name=ID transitions+=InternalTransition*)
	 * </pre>
	 */
	protected void sequence_Decision(ISerializationContext context, Decision semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InitialPublicPubSub returns PublicPubSub
	 *
	 * Constraint:
	 *     (name=ID refType=[Projection|PossiblyQualifiedName]?)
	 * </pre>
	 */
	protected void sequence_InitialPublicPubSub(ISerializationContext context, PublicPubSub semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InitialPubliclySubscribable returns PubliclySubscribable
	 *
	 * Constraint:
	 *     (name=ID refType=[Projection|PossiblyQualifiedName]?)
	 * </pre>
	 */
	protected void sequence_InitialPubliclySubscribable(ISerializationContext context, PubliclySubscribable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     InternalTransition returns Transition
	 *
	 * Constraint:
	 *     (
	 *         requiresExecution?='custom'? 
	 *         (causedBy=PrivatePubSub | exCausedBy=[SubscribableByOthers|QualifiedName]) 
	 *         toState=[State|ID] 
	 *         triggers=[PublishableByMe|ID]?
	 *     )
	 * </pre>
	 */
	protected void sequence_InternalTransition(ISerializationContext context, Transition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StateLike returns Join
	 *     Join returns Join
	 *
	 * Constraint:
	 *     (requiresExecution?='custom'? name=ID joins+=Junction joins+=Junction* transitions+=Transition*)
	 * </pre>
	 */
	protected void sequence_Join(ISerializationContext context, Join semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Junction returns Junction
	 *
	 * Constraint:
	 *     (
	 *         message=[SubscribableByOthers|QualifiedName] 
	 *         (fieldMapping=[ProjectionField|PossiblyQualifiedName] | fieldMapping=[ProjectionField|PossiblyQualifiedName])?
	 *     )
	 * </pre>
	 */
	protected void sequence_Junction(ISerializationContext context, Junction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProjectionField returns MappedField
	 *     MappedField returns MappedField
	 *
	 * Constraint:
	 *     (oldField=[Field|ID] alias=ID? projection=NestedProjection?)
	 * </pre>
	 */
	protected void sequence_MappedField(ISerializationContext context, MappedField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NestedProjection returns Projection
	 *
	 * Constraint:
	 *     fields+=ProjectionField*
	 * </pre>
	 */
	protected void sequence_NestedProjection(ISerializationContext context, Projection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProjectionField returns NewField
	 *     NewField returns NewField
	 *
	 * Constraint:
	 *     (newField=SimpleField | newField=AnyField)
	 * </pre>
	 */
	protected void sequence_NewField(ISerializationContext context, NewField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PrivatePubSub returns PrivatePubSub
	 *
	 * Constraint:
	 *     (name=ID refType=[Projection|PossiblyQualifiedName]?)
	 * </pre>
	 */
	protected void sequence_PrivatePubSub(ISerializationContext context, PrivatePubSub semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProjectionField returns ProjectionContainmentField
	 *     ProjectionContainmentField returns ProjectionContainmentField
	 *
	 * Constraint:
	 *     (projection=[Projection|PossiblyQualifiedName] alias=ID cardinality=Cardinality?)
	 * </pre>
	 */
	protected void sequence_ProjectionContainmentField(ISerializationContext context, ProjectionContainmentField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     RestService returns RestService
	 *
	 * Constraint:
	 *     (url=Path refType=[Projection|PossiblyQualifiedName] accessGroups+=AccessGroup+ supportedDocumentTypes+=RestDocumentType* server=ID?)
	 * </pre>
	 */
	protected void sequence_RestService(ISerializationContext context, RestService semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ServiceMethod returns ServiceMethod
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (inputParams+=[Projection|PossiblyQualifiedName] inputParams+=[Projection|PossiblyQualifiedName]*)? 
	 *         (outputParams+=[Projection|PossiblyQualifiedName] outputParams+=[Projection|PossiblyQualifiedName]*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_ServiceMethod(ISerializationContext context, ServiceMethod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Service returns Service
	 *
	 * Constraint:
	 *     (name=ID methods+=ServiceMethod+)
	 * </pre>
	 */
	protected void sequence_Service(ISerializationContext context, Service semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StateMachine returns StateMachine
	 *
	 * Constraint:
	 *     ((initialState=[State|ID] | initialTransition=Transition) states+=StateLike*)
	 * </pre>
	 */
	protected void sequence_StateMachine(ISerializationContext context, StateMachine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StateLike returns State
	 *     State returns State
	 *
	 * Constraint:
	 *     (requiresExecution?='custom'? name=ID transitions+=Transition*)
	 * </pre>
	 */
	protected void sequence_State(ISerializationContext context, State semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SubsequentPublicPubSub returns PublicPubSub
	 *
	 * Constraint:
	 *     (name=ID refType=[Projection|PossiblyQualifiedName]?)
	 * </pre>
	 */
	protected void sequence_SubsequentPublicPubSub(ISerializationContext context, PublicPubSub semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SubsequentPubliclySubscribable returns PubliclySubscribable
	 *
	 * Constraint:
	 *     (name=ID refType=[Projection|PossiblyQualifiedName]?)
	 * </pre>
	 */
	protected void sequence_SubsequentPubliclySubscribable(ISerializationContext context, PubliclySubscribable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TopLevelProjection returns Projection
	 *
	 * Constraint:
	 *     (name=ID entity=[Entity|PossiblyQualifiedName]? fields+=ProjectionField*)
	 * </pre>
	 */
	protected void sequence_TopLevelProjection(ISerializationContext context, Projection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Transition returns Transition
	 *
	 * Constraint:
	 *     (
	 *         requiresExecution?='custom'? 
	 *         (
	 *             causedBy=PrivatePubSub | 
	 *             (
	 *                 exCausedBy=[SubscribableByOthers|QualifiedName] 
	 *                 (fieldMapping=[ProjectionField|PossiblyQualifiedName] | fieldMapping=[ProjectionField|PossiblyQualifiedName])?
	 *             )
	 *         ) 
	 *         toState=[State|ID] 
	 *         triggers=[PublishableByMe|ID]?
	 *     )
	 * </pre>
	 */
	protected void sequence_Transition(ISerializationContext context, Transition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ProjectionField returns TypeContainmentField
	 *     TypeContainmentField returns TypeContainmentField
	 *
	 * Constraint:
	 *     (newField=TypeField projection=NestedProjection)
	 * </pre>
	 */
	protected void sequence_TypeContainmentField(ISerializationContext context, TypeContainmentField semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.PROJECTION_FIELD__NEW_FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.PROJECTION_FIELD__NEW_FIELD));
			if (transientValues.isValueTransient(semanticObject, TypesPackage.Literals.MAPPED_FIELD__PROJECTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TypesPackage.Literals.MAPPED_FIELD__PROJECTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeContainmentFieldAccess().getNewFieldTypeFieldParserRuleCall_2_0(), semanticObject.getNewField());
		feeder.accept(grammarAccess.getTypeContainmentFieldAccess().getProjectionNestedProjectionParserRuleCall_3_0(), semanticObject.getProjection());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeImport returns TypeImport
	 *
	 * Constraint:
	 *     (type=[Projection|QualifiedName] alias=ID?)
	 * </pre>
	 */
	protected void sequence_TypeImport(ISerializationContext context, TypeImport semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     View returns View
	 *
	 * Constraint:
	 *     (url=Path backedBy=[RestService|Path])
	 * </pre>
	 */
	protected void sequence_View(ISerializationContext context, View semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AccessPackage.Literals.VIEW__URL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AccessPackage.Literals.VIEW__URL));
			if (transientValues.isValueTransient(semanticObject, AccessPackage.Literals.VIEW__BACKED_BY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AccessPackage.Literals.VIEW__BACKED_BY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getViewAccess().getUrlPathParserRuleCall_1_0(), semanticObject.getUrl());
		feeder.accept(grammarAccess.getViewAccess().getBackedByRestServicePathParserRuleCall_3_0_1(), semanticObject.eGet(AccessPackage.Literals.VIEW__BACKED_BY, false));
		feeder.finish();
	}
	
	
}

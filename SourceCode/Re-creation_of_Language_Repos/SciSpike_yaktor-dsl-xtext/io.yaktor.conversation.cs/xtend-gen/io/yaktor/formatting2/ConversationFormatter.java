/**
 * generated by Xtext 2.35.0
 */
package io.yaktor.formatting2;

import com.google.inject.Inject;
import io.yaktor.access.RestService;
import io.yaktor.access.Service;
import io.yaktor.access.View;
import io.yaktor.conversation.Agent;
import io.yaktor.conversation.AgentImport;
import io.yaktor.conversation.Conversation;
import io.yaktor.conversation.PubliclySubscribable;
import io.yaktor.conversation.StateMachine;
import io.yaktor.conversation.TypeImport;
import io.yaktor.domain.Association;
import io.yaktor.domain.DomainModel;
import io.yaktor.services.ConversationGrammarAccess;
import io.yaktor.types.Projection;
import java.util.Arrays;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.formatting2.IFormattableDocument;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.xbase.lib.Extension;

@SuppressWarnings("all")
public class ConversationFormatter extends DomainFormatter {
  @Inject
  @Extension
  private ConversationGrammarAccess _conversationGrammarAccess;

  protected void _format(final Conversation conversation, @Extension final IFormattableDocument document) {
    EList<AgentImport> _importedAgents = conversation.getImportedAgents();
    for (final AgentImport agentImport : _importedAgents) {
      document.<AgentImport>format(agentImport);
    }
    EList<TypeImport> _importedTypes = conversation.getImportedTypes();
    for (final TypeImport typeImport : _importedTypes) {
      document.<TypeImport>format(typeImport);
    }
    EList<Agent> _agents = conversation.getAgents();
    for (final Agent agent : _agents) {
      document.<Agent>format(agent);
    }
    EList<View> _views = conversation.getViews();
    for (final View view : _views) {
      document.<View>format(view);
    }
    EList<RestService> _restServices = conversation.getRestServices();
    for (final RestService restService : _restServices) {
      document.<RestService>format(restService);
    }
    EList<Projection> _definedTypes = conversation.getDefinedTypes();
    for (final Projection projection : _definedTypes) {
      document.<Projection>format(projection);
    }
    EList<Service> _services = conversation.getServices();
    for (final Service service : _services) {
      document.<Service>format(service);
    }
  }

  protected void _format(final Agent agent, @Extension final IFormattableDocument document) {
    EList<PubliclySubscribable> _sendables = agent.getSendables();
    for (final PubliclySubscribable publiclySubscribable : _sendables) {
      document.<PubliclySubscribable>format(publiclySubscribable);
    }
    document.<StateMachine>format(agent.getStateMachine());
  }

  public void format(final Object agent, final IFormattableDocument document) {
    if (agent instanceof XtextResource) {
      _format((XtextResource)agent, document);
      return;
    } else if (agent instanceof Association) {
      _format((Association)agent, document);
      return;
    } else if (agent instanceof Agent) {
      _format((Agent)agent, document);
      return;
    } else if (agent instanceof Conversation) {
      _format((Conversation)agent, document);
      return;
    } else if (agent instanceof DomainModel) {
      _format((DomainModel)agent, document);
      return;
    } else if (agent instanceof EObject) {
      _format((EObject)agent, document);
      return;
    } else if (agent == null) {
      _format((Void)null, document);
      return;
    } else if (agent != null) {
      _format(agent, document);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(agent, document).toString());
    }
  }
}
